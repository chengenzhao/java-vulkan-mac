// Generated by jextract

package org.vulkan;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct VkPhysicalDeviceDescriptorIndexingFeatures {
 *     VkStructureType sType;
 *     void *pNext;
 *     VkBool32 shaderInputAttachmentArrayDynamicIndexing;
 *     VkBool32 shaderUniformTexelBufferArrayDynamicIndexing;
 *     VkBool32 shaderStorageTexelBufferArrayDynamicIndexing;
 *     VkBool32 shaderUniformBufferArrayNonUniformIndexing;
 *     VkBool32 shaderSampledImageArrayNonUniformIndexing;
 *     VkBool32 shaderStorageBufferArrayNonUniformIndexing;
 *     VkBool32 shaderStorageImageArrayNonUniformIndexing;
 *     VkBool32 shaderInputAttachmentArrayNonUniformIndexing;
 *     VkBool32 shaderUniformTexelBufferArrayNonUniformIndexing;
 *     VkBool32 shaderStorageTexelBufferArrayNonUniformIndexing;
 *     VkBool32 descriptorBindingUniformBufferUpdateAfterBind;
 *     VkBool32 descriptorBindingSampledImageUpdateAfterBind;
 *     VkBool32 descriptorBindingStorageImageUpdateAfterBind;
 *     VkBool32 descriptorBindingStorageBufferUpdateAfterBind;
 *     VkBool32 descriptorBindingUniformTexelBufferUpdateAfterBind;
 *     VkBool32 descriptorBindingStorageTexelBufferUpdateAfterBind;
 *     VkBool32 descriptorBindingUpdateUnusedWhilePending;
 *     VkBool32 descriptorBindingPartiallyBound;
 *     VkBool32 descriptorBindingVariableDescriptorCount;
 *     VkBool32 runtimeDescriptorArray;
 * }
 * }
 */
public class VkPhysicalDeviceDescriptorIndexingFeatures {

    VkPhysicalDeviceDescriptorIndexingFeatures() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        vulkan_h.C_INT.withName("sType"),
        MemoryLayout.paddingLayout(4),
        vulkan_h.C_POINTER.withName("pNext"),
        vulkan_h.C_INT.withName("shaderInputAttachmentArrayDynamicIndexing"),
        vulkan_h.C_INT.withName("shaderUniformTexelBufferArrayDynamicIndexing"),
        vulkan_h.C_INT.withName("shaderStorageTexelBufferArrayDynamicIndexing"),
        vulkan_h.C_INT.withName("shaderUniformBufferArrayNonUniformIndexing"),
        vulkan_h.C_INT.withName("shaderSampledImageArrayNonUniformIndexing"),
        vulkan_h.C_INT.withName("shaderStorageBufferArrayNonUniformIndexing"),
        vulkan_h.C_INT.withName("shaderStorageImageArrayNonUniformIndexing"),
        vulkan_h.C_INT.withName("shaderInputAttachmentArrayNonUniformIndexing"),
        vulkan_h.C_INT.withName("shaderUniformTexelBufferArrayNonUniformIndexing"),
        vulkan_h.C_INT.withName("shaderStorageTexelBufferArrayNonUniformIndexing"),
        vulkan_h.C_INT.withName("descriptorBindingUniformBufferUpdateAfterBind"),
        vulkan_h.C_INT.withName("descriptorBindingSampledImageUpdateAfterBind"),
        vulkan_h.C_INT.withName("descriptorBindingStorageImageUpdateAfterBind"),
        vulkan_h.C_INT.withName("descriptorBindingStorageBufferUpdateAfterBind"),
        vulkan_h.C_INT.withName("descriptorBindingUniformTexelBufferUpdateAfterBind"),
        vulkan_h.C_INT.withName("descriptorBindingStorageTexelBufferUpdateAfterBind"),
        vulkan_h.C_INT.withName("descriptorBindingUpdateUnusedWhilePending"),
        vulkan_h.C_INT.withName("descriptorBindingPartiallyBound"),
        vulkan_h.C_INT.withName("descriptorBindingVariableDescriptorCount"),
        vulkan_h.C_INT.withName("runtimeDescriptorArray")
    ).withName("VkPhysicalDeviceDescriptorIndexingFeatures");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final OfInt sType$LAYOUT = (OfInt)$LAYOUT.select(groupElement("sType"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * VkStructureType sType
     * }
     */
    public static final OfInt sType$layout() {
        return sType$LAYOUT;
    }

    private static final long sType$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * VkStructureType sType
     * }
     */
    public static final long sType$offset() {
        return sType$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * VkStructureType sType
     * }
     */
    public static int sType(MemorySegment struct) {
        return struct.get(sType$LAYOUT, sType$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * VkStructureType sType
     * }
     */
    public static void sType(MemorySegment struct, int fieldValue) {
        struct.set(sType$LAYOUT, sType$OFFSET, fieldValue);
    }

    private static final AddressLayout pNext$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("pNext"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void *pNext
     * }
     */
    public static final AddressLayout pNext$layout() {
        return pNext$LAYOUT;
    }

    private static final long pNext$OFFSET = 8;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void *pNext
     * }
     */
    public static final long pNext$offset() {
        return pNext$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void *pNext
     * }
     */
    public static MemorySegment pNext(MemorySegment struct) {
        return struct.get(pNext$LAYOUT, pNext$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void *pNext
     * }
     */
    public static void pNext(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(pNext$LAYOUT, pNext$OFFSET, fieldValue);
    }

    private static final OfInt shaderInputAttachmentArrayDynamicIndexing$LAYOUT = (OfInt)$LAYOUT.select(groupElement("shaderInputAttachmentArrayDynamicIndexing"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * VkBool32 shaderInputAttachmentArrayDynamicIndexing
     * }
     */
    public static final OfInt shaderInputAttachmentArrayDynamicIndexing$layout() {
        return shaderInputAttachmentArrayDynamicIndexing$LAYOUT;
    }

    private static final long shaderInputAttachmentArrayDynamicIndexing$OFFSET = 16;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * VkBool32 shaderInputAttachmentArrayDynamicIndexing
     * }
     */
    public static final long shaderInputAttachmentArrayDynamicIndexing$offset() {
        return shaderInputAttachmentArrayDynamicIndexing$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * VkBool32 shaderInputAttachmentArrayDynamicIndexing
     * }
     */
    public static int shaderInputAttachmentArrayDynamicIndexing(MemorySegment struct) {
        return struct.get(shaderInputAttachmentArrayDynamicIndexing$LAYOUT, shaderInputAttachmentArrayDynamicIndexing$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * VkBool32 shaderInputAttachmentArrayDynamicIndexing
     * }
     */
    public static void shaderInputAttachmentArrayDynamicIndexing(MemorySegment struct, int fieldValue) {
        struct.set(shaderInputAttachmentArrayDynamicIndexing$LAYOUT, shaderInputAttachmentArrayDynamicIndexing$OFFSET, fieldValue);
    }

    private static final OfInt shaderUniformTexelBufferArrayDynamicIndexing$LAYOUT = (OfInt)$LAYOUT.select(groupElement("shaderUniformTexelBufferArrayDynamicIndexing"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * VkBool32 shaderUniformTexelBufferArrayDynamicIndexing
     * }
     */
    public static final OfInt shaderUniformTexelBufferArrayDynamicIndexing$layout() {
        return shaderUniformTexelBufferArrayDynamicIndexing$LAYOUT;
    }

    private static final long shaderUniformTexelBufferArrayDynamicIndexing$OFFSET = 20;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * VkBool32 shaderUniformTexelBufferArrayDynamicIndexing
     * }
     */
    public static final long shaderUniformTexelBufferArrayDynamicIndexing$offset() {
        return shaderUniformTexelBufferArrayDynamicIndexing$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * VkBool32 shaderUniformTexelBufferArrayDynamicIndexing
     * }
     */
    public static int shaderUniformTexelBufferArrayDynamicIndexing(MemorySegment struct) {
        return struct.get(shaderUniformTexelBufferArrayDynamicIndexing$LAYOUT, shaderUniformTexelBufferArrayDynamicIndexing$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * VkBool32 shaderUniformTexelBufferArrayDynamicIndexing
     * }
     */
    public static void shaderUniformTexelBufferArrayDynamicIndexing(MemorySegment struct, int fieldValue) {
        struct.set(shaderUniformTexelBufferArrayDynamicIndexing$LAYOUT, shaderUniformTexelBufferArrayDynamicIndexing$OFFSET, fieldValue);
    }

    private static final OfInt shaderStorageTexelBufferArrayDynamicIndexing$LAYOUT = (OfInt)$LAYOUT.select(groupElement("shaderStorageTexelBufferArrayDynamicIndexing"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * VkBool32 shaderStorageTexelBufferArrayDynamicIndexing
     * }
     */
    public static final OfInt shaderStorageTexelBufferArrayDynamicIndexing$layout() {
        return shaderStorageTexelBufferArrayDynamicIndexing$LAYOUT;
    }

    private static final long shaderStorageTexelBufferArrayDynamicIndexing$OFFSET = 24;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * VkBool32 shaderStorageTexelBufferArrayDynamicIndexing
     * }
     */
    public static final long shaderStorageTexelBufferArrayDynamicIndexing$offset() {
        return shaderStorageTexelBufferArrayDynamicIndexing$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * VkBool32 shaderStorageTexelBufferArrayDynamicIndexing
     * }
     */
    public static int shaderStorageTexelBufferArrayDynamicIndexing(MemorySegment struct) {
        return struct.get(shaderStorageTexelBufferArrayDynamicIndexing$LAYOUT, shaderStorageTexelBufferArrayDynamicIndexing$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * VkBool32 shaderStorageTexelBufferArrayDynamicIndexing
     * }
     */
    public static void shaderStorageTexelBufferArrayDynamicIndexing(MemorySegment struct, int fieldValue) {
        struct.set(shaderStorageTexelBufferArrayDynamicIndexing$LAYOUT, shaderStorageTexelBufferArrayDynamicIndexing$OFFSET, fieldValue);
    }

    private static final OfInt shaderUniformBufferArrayNonUniformIndexing$LAYOUT = (OfInt)$LAYOUT.select(groupElement("shaderUniformBufferArrayNonUniformIndexing"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * VkBool32 shaderUniformBufferArrayNonUniformIndexing
     * }
     */
    public static final OfInt shaderUniformBufferArrayNonUniformIndexing$layout() {
        return shaderUniformBufferArrayNonUniformIndexing$LAYOUT;
    }

    private static final long shaderUniformBufferArrayNonUniformIndexing$OFFSET = 28;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * VkBool32 shaderUniformBufferArrayNonUniformIndexing
     * }
     */
    public static final long shaderUniformBufferArrayNonUniformIndexing$offset() {
        return shaderUniformBufferArrayNonUniformIndexing$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * VkBool32 shaderUniformBufferArrayNonUniformIndexing
     * }
     */
    public static int shaderUniformBufferArrayNonUniformIndexing(MemorySegment struct) {
        return struct.get(shaderUniformBufferArrayNonUniformIndexing$LAYOUT, shaderUniformBufferArrayNonUniformIndexing$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * VkBool32 shaderUniformBufferArrayNonUniformIndexing
     * }
     */
    public static void shaderUniformBufferArrayNonUniformIndexing(MemorySegment struct, int fieldValue) {
        struct.set(shaderUniformBufferArrayNonUniformIndexing$LAYOUT, shaderUniformBufferArrayNonUniformIndexing$OFFSET, fieldValue);
    }

    private static final OfInt shaderSampledImageArrayNonUniformIndexing$LAYOUT = (OfInt)$LAYOUT.select(groupElement("shaderSampledImageArrayNonUniformIndexing"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * VkBool32 shaderSampledImageArrayNonUniformIndexing
     * }
     */
    public static final OfInt shaderSampledImageArrayNonUniformIndexing$layout() {
        return shaderSampledImageArrayNonUniformIndexing$LAYOUT;
    }

    private static final long shaderSampledImageArrayNonUniformIndexing$OFFSET = 32;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * VkBool32 shaderSampledImageArrayNonUniformIndexing
     * }
     */
    public static final long shaderSampledImageArrayNonUniformIndexing$offset() {
        return shaderSampledImageArrayNonUniformIndexing$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * VkBool32 shaderSampledImageArrayNonUniformIndexing
     * }
     */
    public static int shaderSampledImageArrayNonUniformIndexing(MemorySegment struct) {
        return struct.get(shaderSampledImageArrayNonUniformIndexing$LAYOUT, shaderSampledImageArrayNonUniformIndexing$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * VkBool32 shaderSampledImageArrayNonUniformIndexing
     * }
     */
    public static void shaderSampledImageArrayNonUniformIndexing(MemorySegment struct, int fieldValue) {
        struct.set(shaderSampledImageArrayNonUniformIndexing$LAYOUT, shaderSampledImageArrayNonUniformIndexing$OFFSET, fieldValue);
    }

    private static final OfInt shaderStorageBufferArrayNonUniformIndexing$LAYOUT = (OfInt)$LAYOUT.select(groupElement("shaderStorageBufferArrayNonUniformIndexing"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * VkBool32 shaderStorageBufferArrayNonUniformIndexing
     * }
     */
    public static final OfInt shaderStorageBufferArrayNonUniformIndexing$layout() {
        return shaderStorageBufferArrayNonUniformIndexing$LAYOUT;
    }

    private static final long shaderStorageBufferArrayNonUniformIndexing$OFFSET = 36;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * VkBool32 shaderStorageBufferArrayNonUniformIndexing
     * }
     */
    public static final long shaderStorageBufferArrayNonUniformIndexing$offset() {
        return shaderStorageBufferArrayNonUniformIndexing$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * VkBool32 shaderStorageBufferArrayNonUniformIndexing
     * }
     */
    public static int shaderStorageBufferArrayNonUniformIndexing(MemorySegment struct) {
        return struct.get(shaderStorageBufferArrayNonUniformIndexing$LAYOUT, shaderStorageBufferArrayNonUniformIndexing$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * VkBool32 shaderStorageBufferArrayNonUniformIndexing
     * }
     */
    public static void shaderStorageBufferArrayNonUniformIndexing(MemorySegment struct, int fieldValue) {
        struct.set(shaderStorageBufferArrayNonUniformIndexing$LAYOUT, shaderStorageBufferArrayNonUniformIndexing$OFFSET, fieldValue);
    }

    private static final OfInt shaderStorageImageArrayNonUniformIndexing$LAYOUT = (OfInt)$LAYOUT.select(groupElement("shaderStorageImageArrayNonUniformIndexing"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * VkBool32 shaderStorageImageArrayNonUniformIndexing
     * }
     */
    public static final OfInt shaderStorageImageArrayNonUniformIndexing$layout() {
        return shaderStorageImageArrayNonUniformIndexing$LAYOUT;
    }

    private static final long shaderStorageImageArrayNonUniformIndexing$OFFSET = 40;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * VkBool32 shaderStorageImageArrayNonUniformIndexing
     * }
     */
    public static final long shaderStorageImageArrayNonUniformIndexing$offset() {
        return shaderStorageImageArrayNonUniformIndexing$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * VkBool32 shaderStorageImageArrayNonUniformIndexing
     * }
     */
    public static int shaderStorageImageArrayNonUniformIndexing(MemorySegment struct) {
        return struct.get(shaderStorageImageArrayNonUniformIndexing$LAYOUT, shaderStorageImageArrayNonUniformIndexing$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * VkBool32 shaderStorageImageArrayNonUniformIndexing
     * }
     */
    public static void shaderStorageImageArrayNonUniformIndexing(MemorySegment struct, int fieldValue) {
        struct.set(shaderStorageImageArrayNonUniformIndexing$LAYOUT, shaderStorageImageArrayNonUniformIndexing$OFFSET, fieldValue);
    }

    private static final OfInt shaderInputAttachmentArrayNonUniformIndexing$LAYOUT = (OfInt)$LAYOUT.select(groupElement("shaderInputAttachmentArrayNonUniformIndexing"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * VkBool32 shaderInputAttachmentArrayNonUniformIndexing
     * }
     */
    public static final OfInt shaderInputAttachmentArrayNonUniformIndexing$layout() {
        return shaderInputAttachmentArrayNonUniformIndexing$LAYOUT;
    }

    private static final long shaderInputAttachmentArrayNonUniformIndexing$OFFSET = 44;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * VkBool32 shaderInputAttachmentArrayNonUniformIndexing
     * }
     */
    public static final long shaderInputAttachmentArrayNonUniformIndexing$offset() {
        return shaderInputAttachmentArrayNonUniformIndexing$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * VkBool32 shaderInputAttachmentArrayNonUniformIndexing
     * }
     */
    public static int shaderInputAttachmentArrayNonUniformIndexing(MemorySegment struct) {
        return struct.get(shaderInputAttachmentArrayNonUniformIndexing$LAYOUT, shaderInputAttachmentArrayNonUniformIndexing$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * VkBool32 shaderInputAttachmentArrayNonUniformIndexing
     * }
     */
    public static void shaderInputAttachmentArrayNonUniformIndexing(MemorySegment struct, int fieldValue) {
        struct.set(shaderInputAttachmentArrayNonUniformIndexing$LAYOUT, shaderInputAttachmentArrayNonUniformIndexing$OFFSET, fieldValue);
    }

    private static final OfInt shaderUniformTexelBufferArrayNonUniformIndexing$LAYOUT = (OfInt)$LAYOUT.select(groupElement("shaderUniformTexelBufferArrayNonUniformIndexing"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * VkBool32 shaderUniformTexelBufferArrayNonUniformIndexing
     * }
     */
    public static final OfInt shaderUniformTexelBufferArrayNonUniformIndexing$layout() {
        return shaderUniformTexelBufferArrayNonUniformIndexing$LAYOUT;
    }

    private static final long shaderUniformTexelBufferArrayNonUniformIndexing$OFFSET = 48;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * VkBool32 shaderUniformTexelBufferArrayNonUniformIndexing
     * }
     */
    public static final long shaderUniformTexelBufferArrayNonUniformIndexing$offset() {
        return shaderUniformTexelBufferArrayNonUniformIndexing$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * VkBool32 shaderUniformTexelBufferArrayNonUniformIndexing
     * }
     */
    public static int shaderUniformTexelBufferArrayNonUniformIndexing(MemorySegment struct) {
        return struct.get(shaderUniformTexelBufferArrayNonUniformIndexing$LAYOUT, shaderUniformTexelBufferArrayNonUniformIndexing$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * VkBool32 shaderUniformTexelBufferArrayNonUniformIndexing
     * }
     */
    public static void shaderUniformTexelBufferArrayNonUniformIndexing(MemorySegment struct, int fieldValue) {
        struct.set(shaderUniformTexelBufferArrayNonUniformIndexing$LAYOUT, shaderUniformTexelBufferArrayNonUniformIndexing$OFFSET, fieldValue);
    }

    private static final OfInt shaderStorageTexelBufferArrayNonUniformIndexing$LAYOUT = (OfInt)$LAYOUT.select(groupElement("shaderStorageTexelBufferArrayNonUniformIndexing"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * VkBool32 shaderStorageTexelBufferArrayNonUniformIndexing
     * }
     */
    public static final OfInt shaderStorageTexelBufferArrayNonUniformIndexing$layout() {
        return shaderStorageTexelBufferArrayNonUniformIndexing$LAYOUT;
    }

    private static final long shaderStorageTexelBufferArrayNonUniformIndexing$OFFSET = 52;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * VkBool32 shaderStorageTexelBufferArrayNonUniformIndexing
     * }
     */
    public static final long shaderStorageTexelBufferArrayNonUniformIndexing$offset() {
        return shaderStorageTexelBufferArrayNonUniformIndexing$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * VkBool32 shaderStorageTexelBufferArrayNonUniformIndexing
     * }
     */
    public static int shaderStorageTexelBufferArrayNonUniformIndexing(MemorySegment struct) {
        return struct.get(shaderStorageTexelBufferArrayNonUniformIndexing$LAYOUT, shaderStorageTexelBufferArrayNonUniformIndexing$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * VkBool32 shaderStorageTexelBufferArrayNonUniformIndexing
     * }
     */
    public static void shaderStorageTexelBufferArrayNonUniformIndexing(MemorySegment struct, int fieldValue) {
        struct.set(shaderStorageTexelBufferArrayNonUniformIndexing$LAYOUT, shaderStorageTexelBufferArrayNonUniformIndexing$OFFSET, fieldValue);
    }

    private static final OfInt descriptorBindingUniformBufferUpdateAfterBind$LAYOUT = (OfInt)$LAYOUT.select(groupElement("descriptorBindingUniformBufferUpdateAfterBind"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * VkBool32 descriptorBindingUniformBufferUpdateAfterBind
     * }
     */
    public static final OfInt descriptorBindingUniformBufferUpdateAfterBind$layout() {
        return descriptorBindingUniformBufferUpdateAfterBind$LAYOUT;
    }

    private static final long descriptorBindingUniformBufferUpdateAfterBind$OFFSET = 56;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * VkBool32 descriptorBindingUniformBufferUpdateAfterBind
     * }
     */
    public static final long descriptorBindingUniformBufferUpdateAfterBind$offset() {
        return descriptorBindingUniformBufferUpdateAfterBind$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * VkBool32 descriptorBindingUniformBufferUpdateAfterBind
     * }
     */
    public static int descriptorBindingUniformBufferUpdateAfterBind(MemorySegment struct) {
        return struct.get(descriptorBindingUniformBufferUpdateAfterBind$LAYOUT, descriptorBindingUniformBufferUpdateAfterBind$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * VkBool32 descriptorBindingUniformBufferUpdateAfterBind
     * }
     */
    public static void descriptorBindingUniformBufferUpdateAfterBind(MemorySegment struct, int fieldValue) {
        struct.set(descriptorBindingUniformBufferUpdateAfterBind$LAYOUT, descriptorBindingUniformBufferUpdateAfterBind$OFFSET, fieldValue);
    }

    private static final OfInt descriptorBindingSampledImageUpdateAfterBind$LAYOUT = (OfInt)$LAYOUT.select(groupElement("descriptorBindingSampledImageUpdateAfterBind"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * VkBool32 descriptorBindingSampledImageUpdateAfterBind
     * }
     */
    public static final OfInt descriptorBindingSampledImageUpdateAfterBind$layout() {
        return descriptorBindingSampledImageUpdateAfterBind$LAYOUT;
    }

    private static final long descriptorBindingSampledImageUpdateAfterBind$OFFSET = 60;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * VkBool32 descriptorBindingSampledImageUpdateAfterBind
     * }
     */
    public static final long descriptorBindingSampledImageUpdateAfterBind$offset() {
        return descriptorBindingSampledImageUpdateAfterBind$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * VkBool32 descriptorBindingSampledImageUpdateAfterBind
     * }
     */
    public static int descriptorBindingSampledImageUpdateAfterBind(MemorySegment struct) {
        return struct.get(descriptorBindingSampledImageUpdateAfterBind$LAYOUT, descriptorBindingSampledImageUpdateAfterBind$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * VkBool32 descriptorBindingSampledImageUpdateAfterBind
     * }
     */
    public static void descriptorBindingSampledImageUpdateAfterBind(MemorySegment struct, int fieldValue) {
        struct.set(descriptorBindingSampledImageUpdateAfterBind$LAYOUT, descriptorBindingSampledImageUpdateAfterBind$OFFSET, fieldValue);
    }

    private static final OfInt descriptorBindingStorageImageUpdateAfterBind$LAYOUT = (OfInt)$LAYOUT.select(groupElement("descriptorBindingStorageImageUpdateAfterBind"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * VkBool32 descriptorBindingStorageImageUpdateAfterBind
     * }
     */
    public static final OfInt descriptorBindingStorageImageUpdateAfterBind$layout() {
        return descriptorBindingStorageImageUpdateAfterBind$LAYOUT;
    }

    private static final long descriptorBindingStorageImageUpdateAfterBind$OFFSET = 64;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * VkBool32 descriptorBindingStorageImageUpdateAfterBind
     * }
     */
    public static final long descriptorBindingStorageImageUpdateAfterBind$offset() {
        return descriptorBindingStorageImageUpdateAfterBind$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * VkBool32 descriptorBindingStorageImageUpdateAfterBind
     * }
     */
    public static int descriptorBindingStorageImageUpdateAfterBind(MemorySegment struct) {
        return struct.get(descriptorBindingStorageImageUpdateAfterBind$LAYOUT, descriptorBindingStorageImageUpdateAfterBind$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * VkBool32 descriptorBindingStorageImageUpdateAfterBind
     * }
     */
    public static void descriptorBindingStorageImageUpdateAfterBind(MemorySegment struct, int fieldValue) {
        struct.set(descriptorBindingStorageImageUpdateAfterBind$LAYOUT, descriptorBindingStorageImageUpdateAfterBind$OFFSET, fieldValue);
    }

    private static final OfInt descriptorBindingStorageBufferUpdateAfterBind$LAYOUT = (OfInt)$LAYOUT.select(groupElement("descriptorBindingStorageBufferUpdateAfterBind"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * VkBool32 descriptorBindingStorageBufferUpdateAfterBind
     * }
     */
    public static final OfInt descriptorBindingStorageBufferUpdateAfterBind$layout() {
        return descriptorBindingStorageBufferUpdateAfterBind$LAYOUT;
    }

    private static final long descriptorBindingStorageBufferUpdateAfterBind$OFFSET = 68;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * VkBool32 descriptorBindingStorageBufferUpdateAfterBind
     * }
     */
    public static final long descriptorBindingStorageBufferUpdateAfterBind$offset() {
        return descriptorBindingStorageBufferUpdateAfterBind$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * VkBool32 descriptorBindingStorageBufferUpdateAfterBind
     * }
     */
    public static int descriptorBindingStorageBufferUpdateAfterBind(MemorySegment struct) {
        return struct.get(descriptorBindingStorageBufferUpdateAfterBind$LAYOUT, descriptorBindingStorageBufferUpdateAfterBind$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * VkBool32 descriptorBindingStorageBufferUpdateAfterBind
     * }
     */
    public static void descriptorBindingStorageBufferUpdateAfterBind(MemorySegment struct, int fieldValue) {
        struct.set(descriptorBindingStorageBufferUpdateAfterBind$LAYOUT, descriptorBindingStorageBufferUpdateAfterBind$OFFSET, fieldValue);
    }

    private static final OfInt descriptorBindingUniformTexelBufferUpdateAfterBind$LAYOUT = (OfInt)$LAYOUT.select(groupElement("descriptorBindingUniformTexelBufferUpdateAfterBind"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * VkBool32 descriptorBindingUniformTexelBufferUpdateAfterBind
     * }
     */
    public static final OfInt descriptorBindingUniformTexelBufferUpdateAfterBind$layout() {
        return descriptorBindingUniformTexelBufferUpdateAfterBind$LAYOUT;
    }

    private static final long descriptorBindingUniformTexelBufferUpdateAfterBind$OFFSET = 72;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * VkBool32 descriptorBindingUniformTexelBufferUpdateAfterBind
     * }
     */
    public static final long descriptorBindingUniformTexelBufferUpdateAfterBind$offset() {
        return descriptorBindingUniformTexelBufferUpdateAfterBind$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * VkBool32 descriptorBindingUniformTexelBufferUpdateAfterBind
     * }
     */
    public static int descriptorBindingUniformTexelBufferUpdateAfterBind(MemorySegment struct) {
        return struct.get(descriptorBindingUniformTexelBufferUpdateAfterBind$LAYOUT, descriptorBindingUniformTexelBufferUpdateAfterBind$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * VkBool32 descriptorBindingUniformTexelBufferUpdateAfterBind
     * }
     */
    public static void descriptorBindingUniformTexelBufferUpdateAfterBind(MemorySegment struct, int fieldValue) {
        struct.set(descriptorBindingUniformTexelBufferUpdateAfterBind$LAYOUT, descriptorBindingUniformTexelBufferUpdateAfterBind$OFFSET, fieldValue);
    }

    private static final OfInt descriptorBindingStorageTexelBufferUpdateAfterBind$LAYOUT = (OfInt)$LAYOUT.select(groupElement("descriptorBindingStorageTexelBufferUpdateAfterBind"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * VkBool32 descriptorBindingStorageTexelBufferUpdateAfterBind
     * }
     */
    public static final OfInt descriptorBindingStorageTexelBufferUpdateAfterBind$layout() {
        return descriptorBindingStorageTexelBufferUpdateAfterBind$LAYOUT;
    }

    private static final long descriptorBindingStorageTexelBufferUpdateAfterBind$OFFSET = 76;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * VkBool32 descriptorBindingStorageTexelBufferUpdateAfterBind
     * }
     */
    public static final long descriptorBindingStorageTexelBufferUpdateAfterBind$offset() {
        return descriptorBindingStorageTexelBufferUpdateAfterBind$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * VkBool32 descriptorBindingStorageTexelBufferUpdateAfterBind
     * }
     */
    public static int descriptorBindingStorageTexelBufferUpdateAfterBind(MemorySegment struct) {
        return struct.get(descriptorBindingStorageTexelBufferUpdateAfterBind$LAYOUT, descriptorBindingStorageTexelBufferUpdateAfterBind$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * VkBool32 descriptorBindingStorageTexelBufferUpdateAfterBind
     * }
     */
    public static void descriptorBindingStorageTexelBufferUpdateAfterBind(MemorySegment struct, int fieldValue) {
        struct.set(descriptorBindingStorageTexelBufferUpdateAfterBind$LAYOUT, descriptorBindingStorageTexelBufferUpdateAfterBind$OFFSET, fieldValue);
    }

    private static final OfInt descriptorBindingUpdateUnusedWhilePending$LAYOUT = (OfInt)$LAYOUT.select(groupElement("descriptorBindingUpdateUnusedWhilePending"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * VkBool32 descriptorBindingUpdateUnusedWhilePending
     * }
     */
    public static final OfInt descriptorBindingUpdateUnusedWhilePending$layout() {
        return descriptorBindingUpdateUnusedWhilePending$LAYOUT;
    }

    private static final long descriptorBindingUpdateUnusedWhilePending$OFFSET = 80;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * VkBool32 descriptorBindingUpdateUnusedWhilePending
     * }
     */
    public static final long descriptorBindingUpdateUnusedWhilePending$offset() {
        return descriptorBindingUpdateUnusedWhilePending$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * VkBool32 descriptorBindingUpdateUnusedWhilePending
     * }
     */
    public static int descriptorBindingUpdateUnusedWhilePending(MemorySegment struct) {
        return struct.get(descriptorBindingUpdateUnusedWhilePending$LAYOUT, descriptorBindingUpdateUnusedWhilePending$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * VkBool32 descriptorBindingUpdateUnusedWhilePending
     * }
     */
    public static void descriptorBindingUpdateUnusedWhilePending(MemorySegment struct, int fieldValue) {
        struct.set(descriptorBindingUpdateUnusedWhilePending$LAYOUT, descriptorBindingUpdateUnusedWhilePending$OFFSET, fieldValue);
    }

    private static final OfInt descriptorBindingPartiallyBound$LAYOUT = (OfInt)$LAYOUT.select(groupElement("descriptorBindingPartiallyBound"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * VkBool32 descriptorBindingPartiallyBound
     * }
     */
    public static final OfInt descriptorBindingPartiallyBound$layout() {
        return descriptorBindingPartiallyBound$LAYOUT;
    }

    private static final long descriptorBindingPartiallyBound$OFFSET = 84;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * VkBool32 descriptorBindingPartiallyBound
     * }
     */
    public static final long descriptorBindingPartiallyBound$offset() {
        return descriptorBindingPartiallyBound$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * VkBool32 descriptorBindingPartiallyBound
     * }
     */
    public static int descriptorBindingPartiallyBound(MemorySegment struct) {
        return struct.get(descriptorBindingPartiallyBound$LAYOUT, descriptorBindingPartiallyBound$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * VkBool32 descriptorBindingPartiallyBound
     * }
     */
    public static void descriptorBindingPartiallyBound(MemorySegment struct, int fieldValue) {
        struct.set(descriptorBindingPartiallyBound$LAYOUT, descriptorBindingPartiallyBound$OFFSET, fieldValue);
    }

    private static final OfInt descriptorBindingVariableDescriptorCount$LAYOUT = (OfInt)$LAYOUT.select(groupElement("descriptorBindingVariableDescriptorCount"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * VkBool32 descriptorBindingVariableDescriptorCount
     * }
     */
    public static final OfInt descriptorBindingVariableDescriptorCount$layout() {
        return descriptorBindingVariableDescriptorCount$LAYOUT;
    }

    private static final long descriptorBindingVariableDescriptorCount$OFFSET = 88;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * VkBool32 descriptorBindingVariableDescriptorCount
     * }
     */
    public static final long descriptorBindingVariableDescriptorCount$offset() {
        return descriptorBindingVariableDescriptorCount$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * VkBool32 descriptorBindingVariableDescriptorCount
     * }
     */
    public static int descriptorBindingVariableDescriptorCount(MemorySegment struct) {
        return struct.get(descriptorBindingVariableDescriptorCount$LAYOUT, descriptorBindingVariableDescriptorCount$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * VkBool32 descriptorBindingVariableDescriptorCount
     * }
     */
    public static void descriptorBindingVariableDescriptorCount(MemorySegment struct, int fieldValue) {
        struct.set(descriptorBindingVariableDescriptorCount$LAYOUT, descriptorBindingVariableDescriptorCount$OFFSET, fieldValue);
    }

    private static final OfInt runtimeDescriptorArray$LAYOUT = (OfInt)$LAYOUT.select(groupElement("runtimeDescriptorArray"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * VkBool32 runtimeDescriptorArray
     * }
     */
    public static final OfInt runtimeDescriptorArray$layout() {
        return runtimeDescriptorArray$LAYOUT;
    }

    private static final long runtimeDescriptorArray$OFFSET = 92;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * VkBool32 runtimeDescriptorArray
     * }
     */
    public static final long runtimeDescriptorArray$offset() {
        return runtimeDescriptorArray$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * VkBool32 runtimeDescriptorArray
     * }
     */
    public static int runtimeDescriptorArray(MemorySegment struct) {
        return struct.get(runtimeDescriptorArray$LAYOUT, runtimeDescriptorArray$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * VkBool32 runtimeDescriptorArray
     * }
     */
    public static void runtimeDescriptorArray(MemorySegment struct, int fieldValue) {
        struct.set(runtimeDescriptorArray$LAYOUT, runtimeDescriptorArray$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction) (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction) (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

