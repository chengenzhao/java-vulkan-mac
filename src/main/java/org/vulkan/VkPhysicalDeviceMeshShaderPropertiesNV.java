// Generated by jextract

package org.vulkan;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct VkPhysicalDeviceMeshShaderPropertiesNV {
 *     VkStructureType sType;
 *     void *pNext;
 *     uint32_t maxDrawMeshTasksCount;
 *     uint32_t maxTaskWorkGroupInvocations;
 *     uint32_t maxTaskWorkGroupSize[3];
 *     uint32_t maxTaskTotalMemorySize;
 *     uint32_t maxTaskOutputCount;
 *     uint32_t maxMeshWorkGroupInvocations;
 *     uint32_t maxMeshWorkGroupSize[3];
 *     uint32_t maxMeshTotalMemorySize;
 *     uint32_t maxMeshOutputVertices;
 *     uint32_t maxMeshOutputPrimitives;
 *     uint32_t maxMeshMultiviewViewCount;
 *     uint32_t meshOutputPerVertexGranularity;
 *     uint32_t meshOutputPerPrimitiveGranularity;
 * }
 * }
 */
public class VkPhysicalDeviceMeshShaderPropertiesNV {

    VkPhysicalDeviceMeshShaderPropertiesNV() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        vulkan_h.C_INT.withName("sType"),
        MemoryLayout.paddingLayout(4),
        vulkan_h.C_POINTER.withName("pNext"),
        vulkan_h.C_INT.withName("maxDrawMeshTasksCount"),
        vulkan_h.C_INT.withName("maxTaskWorkGroupInvocations"),
        MemoryLayout.sequenceLayout(3, vulkan_h.C_INT).withName("maxTaskWorkGroupSize"),
        vulkan_h.C_INT.withName("maxTaskTotalMemorySize"),
        vulkan_h.C_INT.withName("maxTaskOutputCount"),
        vulkan_h.C_INT.withName("maxMeshWorkGroupInvocations"),
        MemoryLayout.sequenceLayout(3, vulkan_h.C_INT).withName("maxMeshWorkGroupSize"),
        vulkan_h.C_INT.withName("maxMeshTotalMemorySize"),
        vulkan_h.C_INT.withName("maxMeshOutputVertices"),
        vulkan_h.C_INT.withName("maxMeshOutputPrimitives"),
        vulkan_h.C_INT.withName("maxMeshMultiviewViewCount"),
        vulkan_h.C_INT.withName("meshOutputPerVertexGranularity"),
        vulkan_h.C_INT.withName("meshOutputPerPrimitiveGranularity"),
        MemoryLayout.paddingLayout(4)
    ).withName("VkPhysicalDeviceMeshShaderPropertiesNV");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final OfInt sType$LAYOUT = (OfInt)$LAYOUT.select(groupElement("sType"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * VkStructureType sType
     * }
     */
    public static final OfInt sType$layout() {
        return sType$LAYOUT;
    }

    private static final long sType$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * VkStructureType sType
     * }
     */
    public static final long sType$offset() {
        return sType$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * VkStructureType sType
     * }
     */
    public static int sType(MemorySegment struct) {
        return struct.get(sType$LAYOUT, sType$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * VkStructureType sType
     * }
     */
    public static void sType(MemorySegment struct, int fieldValue) {
        struct.set(sType$LAYOUT, sType$OFFSET, fieldValue);
    }

    private static final AddressLayout pNext$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("pNext"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void *pNext
     * }
     */
    public static final AddressLayout pNext$layout() {
        return pNext$LAYOUT;
    }

    private static final long pNext$OFFSET = 8;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void *pNext
     * }
     */
    public static final long pNext$offset() {
        return pNext$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void *pNext
     * }
     */
    public static MemorySegment pNext(MemorySegment struct) {
        return struct.get(pNext$LAYOUT, pNext$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void *pNext
     * }
     */
    public static void pNext(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(pNext$LAYOUT, pNext$OFFSET, fieldValue);
    }

    private static final OfInt maxDrawMeshTasksCount$LAYOUT = (OfInt)$LAYOUT.select(groupElement("maxDrawMeshTasksCount"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint32_t maxDrawMeshTasksCount
     * }
     */
    public static final OfInt maxDrawMeshTasksCount$layout() {
        return maxDrawMeshTasksCount$LAYOUT;
    }

    private static final long maxDrawMeshTasksCount$OFFSET = 16;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint32_t maxDrawMeshTasksCount
     * }
     */
    public static final long maxDrawMeshTasksCount$offset() {
        return maxDrawMeshTasksCount$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint32_t maxDrawMeshTasksCount
     * }
     */
    public static int maxDrawMeshTasksCount(MemorySegment struct) {
        return struct.get(maxDrawMeshTasksCount$LAYOUT, maxDrawMeshTasksCount$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint32_t maxDrawMeshTasksCount
     * }
     */
    public static void maxDrawMeshTasksCount(MemorySegment struct, int fieldValue) {
        struct.set(maxDrawMeshTasksCount$LAYOUT, maxDrawMeshTasksCount$OFFSET, fieldValue);
    }

    private static final OfInt maxTaskWorkGroupInvocations$LAYOUT = (OfInt)$LAYOUT.select(groupElement("maxTaskWorkGroupInvocations"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint32_t maxTaskWorkGroupInvocations
     * }
     */
    public static final OfInt maxTaskWorkGroupInvocations$layout() {
        return maxTaskWorkGroupInvocations$LAYOUT;
    }

    private static final long maxTaskWorkGroupInvocations$OFFSET = 20;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint32_t maxTaskWorkGroupInvocations
     * }
     */
    public static final long maxTaskWorkGroupInvocations$offset() {
        return maxTaskWorkGroupInvocations$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint32_t maxTaskWorkGroupInvocations
     * }
     */
    public static int maxTaskWorkGroupInvocations(MemorySegment struct) {
        return struct.get(maxTaskWorkGroupInvocations$LAYOUT, maxTaskWorkGroupInvocations$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint32_t maxTaskWorkGroupInvocations
     * }
     */
    public static void maxTaskWorkGroupInvocations(MemorySegment struct, int fieldValue) {
        struct.set(maxTaskWorkGroupInvocations$LAYOUT, maxTaskWorkGroupInvocations$OFFSET, fieldValue);
    }

    private static final SequenceLayout maxTaskWorkGroupSize$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement("maxTaskWorkGroupSize"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint32_t maxTaskWorkGroupSize[3]
     * }
     */
    public static final SequenceLayout maxTaskWorkGroupSize$layout() {
        return maxTaskWorkGroupSize$LAYOUT;
    }

    private static final long maxTaskWorkGroupSize$OFFSET = 24;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint32_t maxTaskWorkGroupSize[3]
     * }
     */
    public static final long maxTaskWorkGroupSize$offset() {
        return maxTaskWorkGroupSize$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint32_t maxTaskWorkGroupSize[3]
     * }
     */
    public static MemorySegment maxTaskWorkGroupSize(MemorySegment struct) {
        return struct.asSlice(maxTaskWorkGroupSize$OFFSET, maxTaskWorkGroupSize$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint32_t maxTaskWorkGroupSize[3]
     * }
     */
    public static void maxTaskWorkGroupSize(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, maxTaskWorkGroupSize$OFFSET, maxTaskWorkGroupSize$LAYOUT.byteSize());
    }

    private static long[] maxTaskWorkGroupSize$DIMS = { 3 };

    /**
     * Dimensions for array field:
     * {@snippet lang=c :
     * uint32_t maxTaskWorkGroupSize[3]
     * }
     */
    public static long[] maxTaskWorkGroupSize$dimensions() {
        return maxTaskWorkGroupSize$DIMS;
    }
    private static final VarHandle maxTaskWorkGroupSize$ELEM_HANDLE = maxTaskWorkGroupSize$LAYOUT.varHandle(sequenceElement());

    /**
     * Indexed getter for field:
     * {@snippet lang=c :
     * uint32_t maxTaskWorkGroupSize[3]
     * }
     */
    public static int maxTaskWorkGroupSize(MemorySegment struct, long index0) {
        return (int)maxTaskWorkGroupSize$ELEM_HANDLE.get(struct, 0L, index0);
    }

    /**
     * Indexed setter for field:
     * {@snippet lang=c :
     * uint32_t maxTaskWorkGroupSize[3]
     * }
     */
    public static void maxTaskWorkGroupSize(MemorySegment struct, long index0, int fieldValue) {
        maxTaskWorkGroupSize$ELEM_HANDLE.set(struct, 0L, index0, fieldValue);
    }

    private static final OfInt maxTaskTotalMemorySize$LAYOUT = (OfInt)$LAYOUT.select(groupElement("maxTaskTotalMemorySize"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint32_t maxTaskTotalMemorySize
     * }
     */
    public static final OfInt maxTaskTotalMemorySize$layout() {
        return maxTaskTotalMemorySize$LAYOUT;
    }

    private static final long maxTaskTotalMemorySize$OFFSET = 36;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint32_t maxTaskTotalMemorySize
     * }
     */
    public static final long maxTaskTotalMemorySize$offset() {
        return maxTaskTotalMemorySize$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint32_t maxTaskTotalMemorySize
     * }
     */
    public static int maxTaskTotalMemorySize(MemorySegment struct) {
        return struct.get(maxTaskTotalMemorySize$LAYOUT, maxTaskTotalMemorySize$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint32_t maxTaskTotalMemorySize
     * }
     */
    public static void maxTaskTotalMemorySize(MemorySegment struct, int fieldValue) {
        struct.set(maxTaskTotalMemorySize$LAYOUT, maxTaskTotalMemorySize$OFFSET, fieldValue);
    }

    private static final OfInt maxTaskOutputCount$LAYOUT = (OfInt)$LAYOUT.select(groupElement("maxTaskOutputCount"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint32_t maxTaskOutputCount
     * }
     */
    public static final OfInt maxTaskOutputCount$layout() {
        return maxTaskOutputCount$LAYOUT;
    }

    private static final long maxTaskOutputCount$OFFSET = 40;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint32_t maxTaskOutputCount
     * }
     */
    public static final long maxTaskOutputCount$offset() {
        return maxTaskOutputCount$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint32_t maxTaskOutputCount
     * }
     */
    public static int maxTaskOutputCount(MemorySegment struct) {
        return struct.get(maxTaskOutputCount$LAYOUT, maxTaskOutputCount$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint32_t maxTaskOutputCount
     * }
     */
    public static void maxTaskOutputCount(MemorySegment struct, int fieldValue) {
        struct.set(maxTaskOutputCount$LAYOUT, maxTaskOutputCount$OFFSET, fieldValue);
    }

    private static final OfInt maxMeshWorkGroupInvocations$LAYOUT = (OfInt)$LAYOUT.select(groupElement("maxMeshWorkGroupInvocations"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint32_t maxMeshWorkGroupInvocations
     * }
     */
    public static final OfInt maxMeshWorkGroupInvocations$layout() {
        return maxMeshWorkGroupInvocations$LAYOUT;
    }

    private static final long maxMeshWorkGroupInvocations$OFFSET = 44;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint32_t maxMeshWorkGroupInvocations
     * }
     */
    public static final long maxMeshWorkGroupInvocations$offset() {
        return maxMeshWorkGroupInvocations$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint32_t maxMeshWorkGroupInvocations
     * }
     */
    public static int maxMeshWorkGroupInvocations(MemorySegment struct) {
        return struct.get(maxMeshWorkGroupInvocations$LAYOUT, maxMeshWorkGroupInvocations$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint32_t maxMeshWorkGroupInvocations
     * }
     */
    public static void maxMeshWorkGroupInvocations(MemorySegment struct, int fieldValue) {
        struct.set(maxMeshWorkGroupInvocations$LAYOUT, maxMeshWorkGroupInvocations$OFFSET, fieldValue);
    }

    private static final SequenceLayout maxMeshWorkGroupSize$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement("maxMeshWorkGroupSize"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint32_t maxMeshWorkGroupSize[3]
     * }
     */
    public static final SequenceLayout maxMeshWorkGroupSize$layout() {
        return maxMeshWorkGroupSize$LAYOUT;
    }

    private static final long maxMeshWorkGroupSize$OFFSET = 48;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint32_t maxMeshWorkGroupSize[3]
     * }
     */
    public static final long maxMeshWorkGroupSize$offset() {
        return maxMeshWorkGroupSize$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint32_t maxMeshWorkGroupSize[3]
     * }
     */
    public static MemorySegment maxMeshWorkGroupSize(MemorySegment struct) {
        return struct.asSlice(maxMeshWorkGroupSize$OFFSET, maxMeshWorkGroupSize$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint32_t maxMeshWorkGroupSize[3]
     * }
     */
    public static void maxMeshWorkGroupSize(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, maxMeshWorkGroupSize$OFFSET, maxMeshWorkGroupSize$LAYOUT.byteSize());
    }

    private static long[] maxMeshWorkGroupSize$DIMS = { 3 };

    /**
     * Dimensions for array field:
     * {@snippet lang=c :
     * uint32_t maxMeshWorkGroupSize[3]
     * }
     */
    public static long[] maxMeshWorkGroupSize$dimensions() {
        return maxMeshWorkGroupSize$DIMS;
    }
    private static final VarHandle maxMeshWorkGroupSize$ELEM_HANDLE = maxMeshWorkGroupSize$LAYOUT.varHandle(sequenceElement());

    /**
     * Indexed getter for field:
     * {@snippet lang=c :
     * uint32_t maxMeshWorkGroupSize[3]
     * }
     */
    public static int maxMeshWorkGroupSize(MemorySegment struct, long index0) {
        return (int)maxMeshWorkGroupSize$ELEM_HANDLE.get(struct, 0L, index0);
    }

    /**
     * Indexed setter for field:
     * {@snippet lang=c :
     * uint32_t maxMeshWorkGroupSize[3]
     * }
     */
    public static void maxMeshWorkGroupSize(MemorySegment struct, long index0, int fieldValue) {
        maxMeshWorkGroupSize$ELEM_HANDLE.set(struct, 0L, index0, fieldValue);
    }

    private static final OfInt maxMeshTotalMemorySize$LAYOUT = (OfInt)$LAYOUT.select(groupElement("maxMeshTotalMemorySize"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint32_t maxMeshTotalMemorySize
     * }
     */
    public static final OfInt maxMeshTotalMemorySize$layout() {
        return maxMeshTotalMemorySize$LAYOUT;
    }

    private static final long maxMeshTotalMemorySize$OFFSET = 60;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint32_t maxMeshTotalMemorySize
     * }
     */
    public static final long maxMeshTotalMemorySize$offset() {
        return maxMeshTotalMemorySize$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint32_t maxMeshTotalMemorySize
     * }
     */
    public static int maxMeshTotalMemorySize(MemorySegment struct) {
        return struct.get(maxMeshTotalMemorySize$LAYOUT, maxMeshTotalMemorySize$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint32_t maxMeshTotalMemorySize
     * }
     */
    public static void maxMeshTotalMemorySize(MemorySegment struct, int fieldValue) {
        struct.set(maxMeshTotalMemorySize$LAYOUT, maxMeshTotalMemorySize$OFFSET, fieldValue);
    }

    private static final OfInt maxMeshOutputVertices$LAYOUT = (OfInt)$LAYOUT.select(groupElement("maxMeshOutputVertices"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint32_t maxMeshOutputVertices
     * }
     */
    public static final OfInt maxMeshOutputVertices$layout() {
        return maxMeshOutputVertices$LAYOUT;
    }

    private static final long maxMeshOutputVertices$OFFSET = 64;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint32_t maxMeshOutputVertices
     * }
     */
    public static final long maxMeshOutputVertices$offset() {
        return maxMeshOutputVertices$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint32_t maxMeshOutputVertices
     * }
     */
    public static int maxMeshOutputVertices(MemorySegment struct) {
        return struct.get(maxMeshOutputVertices$LAYOUT, maxMeshOutputVertices$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint32_t maxMeshOutputVertices
     * }
     */
    public static void maxMeshOutputVertices(MemorySegment struct, int fieldValue) {
        struct.set(maxMeshOutputVertices$LAYOUT, maxMeshOutputVertices$OFFSET, fieldValue);
    }

    private static final OfInt maxMeshOutputPrimitives$LAYOUT = (OfInt)$LAYOUT.select(groupElement("maxMeshOutputPrimitives"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint32_t maxMeshOutputPrimitives
     * }
     */
    public static final OfInt maxMeshOutputPrimitives$layout() {
        return maxMeshOutputPrimitives$LAYOUT;
    }

    private static final long maxMeshOutputPrimitives$OFFSET = 68;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint32_t maxMeshOutputPrimitives
     * }
     */
    public static final long maxMeshOutputPrimitives$offset() {
        return maxMeshOutputPrimitives$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint32_t maxMeshOutputPrimitives
     * }
     */
    public static int maxMeshOutputPrimitives(MemorySegment struct) {
        return struct.get(maxMeshOutputPrimitives$LAYOUT, maxMeshOutputPrimitives$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint32_t maxMeshOutputPrimitives
     * }
     */
    public static void maxMeshOutputPrimitives(MemorySegment struct, int fieldValue) {
        struct.set(maxMeshOutputPrimitives$LAYOUT, maxMeshOutputPrimitives$OFFSET, fieldValue);
    }

    private static final OfInt maxMeshMultiviewViewCount$LAYOUT = (OfInt)$LAYOUT.select(groupElement("maxMeshMultiviewViewCount"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint32_t maxMeshMultiviewViewCount
     * }
     */
    public static final OfInt maxMeshMultiviewViewCount$layout() {
        return maxMeshMultiviewViewCount$LAYOUT;
    }

    private static final long maxMeshMultiviewViewCount$OFFSET = 72;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint32_t maxMeshMultiviewViewCount
     * }
     */
    public static final long maxMeshMultiviewViewCount$offset() {
        return maxMeshMultiviewViewCount$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint32_t maxMeshMultiviewViewCount
     * }
     */
    public static int maxMeshMultiviewViewCount(MemorySegment struct) {
        return struct.get(maxMeshMultiviewViewCount$LAYOUT, maxMeshMultiviewViewCount$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint32_t maxMeshMultiviewViewCount
     * }
     */
    public static void maxMeshMultiviewViewCount(MemorySegment struct, int fieldValue) {
        struct.set(maxMeshMultiviewViewCount$LAYOUT, maxMeshMultiviewViewCount$OFFSET, fieldValue);
    }

    private static final OfInt meshOutputPerVertexGranularity$LAYOUT = (OfInt)$LAYOUT.select(groupElement("meshOutputPerVertexGranularity"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint32_t meshOutputPerVertexGranularity
     * }
     */
    public static final OfInt meshOutputPerVertexGranularity$layout() {
        return meshOutputPerVertexGranularity$LAYOUT;
    }

    private static final long meshOutputPerVertexGranularity$OFFSET = 76;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint32_t meshOutputPerVertexGranularity
     * }
     */
    public static final long meshOutputPerVertexGranularity$offset() {
        return meshOutputPerVertexGranularity$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint32_t meshOutputPerVertexGranularity
     * }
     */
    public static int meshOutputPerVertexGranularity(MemorySegment struct) {
        return struct.get(meshOutputPerVertexGranularity$LAYOUT, meshOutputPerVertexGranularity$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint32_t meshOutputPerVertexGranularity
     * }
     */
    public static void meshOutputPerVertexGranularity(MemorySegment struct, int fieldValue) {
        struct.set(meshOutputPerVertexGranularity$LAYOUT, meshOutputPerVertexGranularity$OFFSET, fieldValue);
    }

    private static final OfInt meshOutputPerPrimitiveGranularity$LAYOUT = (OfInt)$LAYOUT.select(groupElement("meshOutputPerPrimitiveGranularity"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint32_t meshOutputPerPrimitiveGranularity
     * }
     */
    public static final OfInt meshOutputPerPrimitiveGranularity$layout() {
        return meshOutputPerPrimitiveGranularity$LAYOUT;
    }

    private static final long meshOutputPerPrimitiveGranularity$OFFSET = 80;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint32_t meshOutputPerPrimitiveGranularity
     * }
     */
    public static final long meshOutputPerPrimitiveGranularity$offset() {
        return meshOutputPerPrimitiveGranularity$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint32_t meshOutputPerPrimitiveGranularity
     * }
     */
    public static int meshOutputPerPrimitiveGranularity(MemorySegment struct) {
        return struct.get(meshOutputPerPrimitiveGranularity$LAYOUT, meshOutputPerPrimitiveGranularity$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint32_t meshOutputPerPrimitiveGranularity
     * }
     */
    public static void meshOutputPerPrimitiveGranularity(MemorySegment struct, int fieldValue) {
        struct.set(meshOutputPerPrimitiveGranularity$LAYOUT, meshOutputPerPrimitiveGranularity$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction) (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction) (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

