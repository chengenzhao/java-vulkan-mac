// Generated by jextract

package org.vulkan;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct VkSubpassDependency {
 *     uint32_t srcSubpass;
 *     uint32_t dstSubpass;
 *     VkPipelineStageFlags srcStageMask;
 *     VkPipelineStageFlags dstStageMask;
 *     VkAccessFlags srcAccessMask;
 *     VkAccessFlags dstAccessMask;
 *     VkDependencyFlags dependencyFlags;
 * }
 * }
 */
public class VkSubpassDependency {

    VkSubpassDependency() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        vulkan_h.C_INT.withName("srcSubpass"),
        vulkan_h.C_INT.withName("dstSubpass"),
        vulkan_h.C_INT.withName("srcStageMask"),
        vulkan_h.C_INT.withName("dstStageMask"),
        vulkan_h.C_INT.withName("srcAccessMask"),
        vulkan_h.C_INT.withName("dstAccessMask"),
        vulkan_h.C_INT.withName("dependencyFlags")
    ).withName("VkSubpassDependency");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final OfInt srcSubpass$LAYOUT = (OfInt)$LAYOUT.select(groupElement("srcSubpass"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint32_t srcSubpass
     * }
     */
    public static final OfInt srcSubpass$layout() {
        return srcSubpass$LAYOUT;
    }

    private static final long srcSubpass$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint32_t srcSubpass
     * }
     */
    public static final long srcSubpass$offset() {
        return srcSubpass$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint32_t srcSubpass
     * }
     */
    public static int srcSubpass(MemorySegment struct) {
        return struct.get(srcSubpass$LAYOUT, srcSubpass$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint32_t srcSubpass
     * }
     */
    public static void srcSubpass(MemorySegment struct, int fieldValue) {
        struct.set(srcSubpass$LAYOUT, srcSubpass$OFFSET, fieldValue);
    }

    private static final OfInt dstSubpass$LAYOUT = (OfInt)$LAYOUT.select(groupElement("dstSubpass"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint32_t dstSubpass
     * }
     */
    public static final OfInt dstSubpass$layout() {
        return dstSubpass$LAYOUT;
    }

    private static final long dstSubpass$OFFSET = 4;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint32_t dstSubpass
     * }
     */
    public static final long dstSubpass$offset() {
        return dstSubpass$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint32_t dstSubpass
     * }
     */
    public static int dstSubpass(MemorySegment struct) {
        return struct.get(dstSubpass$LAYOUT, dstSubpass$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint32_t dstSubpass
     * }
     */
    public static void dstSubpass(MemorySegment struct, int fieldValue) {
        struct.set(dstSubpass$LAYOUT, dstSubpass$OFFSET, fieldValue);
    }

    private static final OfInt srcStageMask$LAYOUT = (OfInt)$LAYOUT.select(groupElement("srcStageMask"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * VkPipelineStageFlags srcStageMask
     * }
     */
    public static final OfInt srcStageMask$layout() {
        return srcStageMask$LAYOUT;
    }

    private static final long srcStageMask$OFFSET = 8;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * VkPipelineStageFlags srcStageMask
     * }
     */
    public static final long srcStageMask$offset() {
        return srcStageMask$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * VkPipelineStageFlags srcStageMask
     * }
     */
    public static int srcStageMask(MemorySegment struct) {
        return struct.get(srcStageMask$LAYOUT, srcStageMask$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * VkPipelineStageFlags srcStageMask
     * }
     */
    public static void srcStageMask(MemorySegment struct, int fieldValue) {
        struct.set(srcStageMask$LAYOUT, srcStageMask$OFFSET, fieldValue);
    }

    private static final OfInt dstStageMask$LAYOUT = (OfInt)$LAYOUT.select(groupElement("dstStageMask"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * VkPipelineStageFlags dstStageMask
     * }
     */
    public static final OfInt dstStageMask$layout() {
        return dstStageMask$LAYOUT;
    }

    private static final long dstStageMask$OFFSET = 12;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * VkPipelineStageFlags dstStageMask
     * }
     */
    public static final long dstStageMask$offset() {
        return dstStageMask$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * VkPipelineStageFlags dstStageMask
     * }
     */
    public static int dstStageMask(MemorySegment struct) {
        return struct.get(dstStageMask$LAYOUT, dstStageMask$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * VkPipelineStageFlags dstStageMask
     * }
     */
    public static void dstStageMask(MemorySegment struct, int fieldValue) {
        struct.set(dstStageMask$LAYOUT, dstStageMask$OFFSET, fieldValue);
    }

    private static final OfInt srcAccessMask$LAYOUT = (OfInt)$LAYOUT.select(groupElement("srcAccessMask"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * VkAccessFlags srcAccessMask
     * }
     */
    public static final OfInt srcAccessMask$layout() {
        return srcAccessMask$LAYOUT;
    }

    private static final long srcAccessMask$OFFSET = 16;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * VkAccessFlags srcAccessMask
     * }
     */
    public static final long srcAccessMask$offset() {
        return srcAccessMask$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * VkAccessFlags srcAccessMask
     * }
     */
    public static int srcAccessMask(MemorySegment struct) {
        return struct.get(srcAccessMask$LAYOUT, srcAccessMask$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * VkAccessFlags srcAccessMask
     * }
     */
    public static void srcAccessMask(MemorySegment struct, int fieldValue) {
        struct.set(srcAccessMask$LAYOUT, srcAccessMask$OFFSET, fieldValue);
    }

    private static final OfInt dstAccessMask$LAYOUT = (OfInt)$LAYOUT.select(groupElement("dstAccessMask"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * VkAccessFlags dstAccessMask
     * }
     */
    public static final OfInt dstAccessMask$layout() {
        return dstAccessMask$LAYOUT;
    }

    private static final long dstAccessMask$OFFSET = 20;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * VkAccessFlags dstAccessMask
     * }
     */
    public static final long dstAccessMask$offset() {
        return dstAccessMask$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * VkAccessFlags dstAccessMask
     * }
     */
    public static int dstAccessMask(MemorySegment struct) {
        return struct.get(dstAccessMask$LAYOUT, dstAccessMask$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * VkAccessFlags dstAccessMask
     * }
     */
    public static void dstAccessMask(MemorySegment struct, int fieldValue) {
        struct.set(dstAccessMask$LAYOUT, dstAccessMask$OFFSET, fieldValue);
    }

    private static final OfInt dependencyFlags$LAYOUT = (OfInt)$LAYOUT.select(groupElement("dependencyFlags"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * VkDependencyFlags dependencyFlags
     * }
     */
    public static final OfInt dependencyFlags$layout() {
        return dependencyFlags$LAYOUT;
    }

    private static final long dependencyFlags$OFFSET = 24;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * VkDependencyFlags dependencyFlags
     * }
     */
    public static final long dependencyFlags$offset() {
        return dependencyFlags$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * VkDependencyFlags dependencyFlags
     * }
     */
    public static int dependencyFlags(MemorySegment struct) {
        return struct.get(dependencyFlags$LAYOUT, dependencyFlags$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * VkDependencyFlags dependencyFlags
     * }
     */
    public static void dependencyFlags(MemorySegment struct, int fieldValue) {
        struct.set(dependencyFlags$LAYOUT, dependencyFlags$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction) (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction) (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

