// Generated by jextract

package org.vulkan;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct VkSubpassDescription {
 *     VkSubpassDescriptionFlags flags;
 *     VkPipelineBindPoint pipelineBindPoint;
 *     uint32_t inputAttachmentCount;
 *     const VkAttachmentReference *pInputAttachments;
 *     uint32_t colorAttachmentCount;
 *     const VkAttachmentReference *pColorAttachments;
 *     const VkAttachmentReference *pResolveAttachments;
 *     const VkAttachmentReference *pDepthStencilAttachment;
 *     uint32_t preserveAttachmentCount;
 *     const uint32_t *pPreserveAttachments;
 * }
 * }
 */
public class VkSubpassDescription {

    VkSubpassDescription() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        vulkan_h.C_INT.withName("flags"),
        vulkan_h.C_INT.withName("pipelineBindPoint"),
        vulkan_h.C_INT.withName("inputAttachmentCount"),
        MemoryLayout.paddingLayout(4),
        vulkan_h.C_POINTER.withName("pInputAttachments"),
        vulkan_h.C_INT.withName("colorAttachmentCount"),
        MemoryLayout.paddingLayout(4),
        vulkan_h.C_POINTER.withName("pColorAttachments"),
        vulkan_h.C_POINTER.withName("pResolveAttachments"),
        vulkan_h.C_POINTER.withName("pDepthStencilAttachment"),
        vulkan_h.C_INT.withName("preserveAttachmentCount"),
        MemoryLayout.paddingLayout(4),
        vulkan_h.C_POINTER.withName("pPreserveAttachments")
    ).withName("VkSubpassDescription");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final OfInt flags$LAYOUT = (OfInt)$LAYOUT.select(groupElement("flags"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * VkSubpassDescriptionFlags flags
     * }
     */
    public static final OfInt flags$layout() {
        return flags$LAYOUT;
    }

    private static final long flags$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * VkSubpassDescriptionFlags flags
     * }
     */
    public static final long flags$offset() {
        return flags$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * VkSubpassDescriptionFlags flags
     * }
     */
    public static int flags(MemorySegment struct) {
        return struct.get(flags$LAYOUT, flags$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * VkSubpassDescriptionFlags flags
     * }
     */
    public static void flags(MemorySegment struct, int fieldValue) {
        struct.set(flags$LAYOUT, flags$OFFSET, fieldValue);
    }

    private static final OfInt pipelineBindPoint$LAYOUT = (OfInt)$LAYOUT.select(groupElement("pipelineBindPoint"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * VkPipelineBindPoint pipelineBindPoint
     * }
     */
    public static final OfInt pipelineBindPoint$layout() {
        return pipelineBindPoint$LAYOUT;
    }

    private static final long pipelineBindPoint$OFFSET = 4;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * VkPipelineBindPoint pipelineBindPoint
     * }
     */
    public static final long pipelineBindPoint$offset() {
        return pipelineBindPoint$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * VkPipelineBindPoint pipelineBindPoint
     * }
     */
    public static int pipelineBindPoint(MemorySegment struct) {
        return struct.get(pipelineBindPoint$LAYOUT, pipelineBindPoint$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * VkPipelineBindPoint pipelineBindPoint
     * }
     */
    public static void pipelineBindPoint(MemorySegment struct, int fieldValue) {
        struct.set(pipelineBindPoint$LAYOUT, pipelineBindPoint$OFFSET, fieldValue);
    }

    private static final OfInt inputAttachmentCount$LAYOUT = (OfInt)$LAYOUT.select(groupElement("inputAttachmentCount"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint32_t inputAttachmentCount
     * }
     */
    public static final OfInt inputAttachmentCount$layout() {
        return inputAttachmentCount$LAYOUT;
    }

    private static final long inputAttachmentCount$OFFSET = 8;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint32_t inputAttachmentCount
     * }
     */
    public static final long inputAttachmentCount$offset() {
        return inputAttachmentCount$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint32_t inputAttachmentCount
     * }
     */
    public static int inputAttachmentCount(MemorySegment struct) {
        return struct.get(inputAttachmentCount$LAYOUT, inputAttachmentCount$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint32_t inputAttachmentCount
     * }
     */
    public static void inputAttachmentCount(MemorySegment struct, int fieldValue) {
        struct.set(inputAttachmentCount$LAYOUT, inputAttachmentCount$OFFSET, fieldValue);
    }

    private static final AddressLayout pInputAttachments$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("pInputAttachments"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const VkAttachmentReference *pInputAttachments
     * }
     */
    public static final AddressLayout pInputAttachments$layout() {
        return pInputAttachments$LAYOUT;
    }

    private static final long pInputAttachments$OFFSET = 16;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const VkAttachmentReference *pInputAttachments
     * }
     */
    public static final long pInputAttachments$offset() {
        return pInputAttachments$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const VkAttachmentReference *pInputAttachments
     * }
     */
    public static MemorySegment pInputAttachments(MemorySegment struct) {
        return struct.get(pInputAttachments$LAYOUT, pInputAttachments$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const VkAttachmentReference *pInputAttachments
     * }
     */
    public static void pInputAttachments(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(pInputAttachments$LAYOUT, pInputAttachments$OFFSET, fieldValue);
    }

    private static final OfInt colorAttachmentCount$LAYOUT = (OfInt)$LAYOUT.select(groupElement("colorAttachmentCount"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint32_t colorAttachmentCount
     * }
     */
    public static final OfInt colorAttachmentCount$layout() {
        return colorAttachmentCount$LAYOUT;
    }

    private static final long colorAttachmentCount$OFFSET = 24;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint32_t colorAttachmentCount
     * }
     */
    public static final long colorAttachmentCount$offset() {
        return colorAttachmentCount$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint32_t colorAttachmentCount
     * }
     */
    public static int colorAttachmentCount(MemorySegment struct) {
        return struct.get(colorAttachmentCount$LAYOUT, colorAttachmentCount$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint32_t colorAttachmentCount
     * }
     */
    public static void colorAttachmentCount(MemorySegment struct, int fieldValue) {
        struct.set(colorAttachmentCount$LAYOUT, colorAttachmentCount$OFFSET, fieldValue);
    }

    private static final AddressLayout pColorAttachments$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("pColorAttachments"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const VkAttachmentReference *pColorAttachments
     * }
     */
    public static final AddressLayout pColorAttachments$layout() {
        return pColorAttachments$LAYOUT;
    }

    private static final long pColorAttachments$OFFSET = 32;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const VkAttachmentReference *pColorAttachments
     * }
     */
    public static final long pColorAttachments$offset() {
        return pColorAttachments$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const VkAttachmentReference *pColorAttachments
     * }
     */
    public static MemorySegment pColorAttachments(MemorySegment struct) {
        return struct.get(pColorAttachments$LAYOUT, pColorAttachments$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const VkAttachmentReference *pColorAttachments
     * }
     */
    public static void pColorAttachments(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(pColorAttachments$LAYOUT, pColorAttachments$OFFSET, fieldValue);
    }

    private static final AddressLayout pResolveAttachments$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("pResolveAttachments"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const VkAttachmentReference *pResolveAttachments
     * }
     */
    public static final AddressLayout pResolveAttachments$layout() {
        return pResolveAttachments$LAYOUT;
    }

    private static final long pResolveAttachments$OFFSET = 40;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const VkAttachmentReference *pResolveAttachments
     * }
     */
    public static final long pResolveAttachments$offset() {
        return pResolveAttachments$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const VkAttachmentReference *pResolveAttachments
     * }
     */
    public static MemorySegment pResolveAttachments(MemorySegment struct) {
        return struct.get(pResolveAttachments$LAYOUT, pResolveAttachments$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const VkAttachmentReference *pResolveAttachments
     * }
     */
    public static void pResolveAttachments(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(pResolveAttachments$LAYOUT, pResolveAttachments$OFFSET, fieldValue);
    }

    private static final AddressLayout pDepthStencilAttachment$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("pDepthStencilAttachment"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const VkAttachmentReference *pDepthStencilAttachment
     * }
     */
    public static final AddressLayout pDepthStencilAttachment$layout() {
        return pDepthStencilAttachment$LAYOUT;
    }

    private static final long pDepthStencilAttachment$OFFSET = 48;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const VkAttachmentReference *pDepthStencilAttachment
     * }
     */
    public static final long pDepthStencilAttachment$offset() {
        return pDepthStencilAttachment$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const VkAttachmentReference *pDepthStencilAttachment
     * }
     */
    public static MemorySegment pDepthStencilAttachment(MemorySegment struct) {
        return struct.get(pDepthStencilAttachment$LAYOUT, pDepthStencilAttachment$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const VkAttachmentReference *pDepthStencilAttachment
     * }
     */
    public static void pDepthStencilAttachment(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(pDepthStencilAttachment$LAYOUT, pDepthStencilAttachment$OFFSET, fieldValue);
    }

    private static final OfInt preserveAttachmentCount$LAYOUT = (OfInt)$LAYOUT.select(groupElement("preserveAttachmentCount"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint32_t preserveAttachmentCount
     * }
     */
    public static final OfInt preserveAttachmentCount$layout() {
        return preserveAttachmentCount$LAYOUT;
    }

    private static final long preserveAttachmentCount$OFFSET = 56;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint32_t preserveAttachmentCount
     * }
     */
    public static final long preserveAttachmentCount$offset() {
        return preserveAttachmentCount$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint32_t preserveAttachmentCount
     * }
     */
    public static int preserveAttachmentCount(MemorySegment struct) {
        return struct.get(preserveAttachmentCount$LAYOUT, preserveAttachmentCount$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint32_t preserveAttachmentCount
     * }
     */
    public static void preserveAttachmentCount(MemorySegment struct, int fieldValue) {
        struct.set(preserveAttachmentCount$LAYOUT, preserveAttachmentCount$OFFSET, fieldValue);
    }

    private static final AddressLayout pPreserveAttachments$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("pPreserveAttachments"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const uint32_t *pPreserveAttachments
     * }
     */
    public static final AddressLayout pPreserveAttachments$layout() {
        return pPreserveAttachments$LAYOUT;
    }

    private static final long pPreserveAttachments$OFFSET = 64;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const uint32_t *pPreserveAttachments
     * }
     */
    public static final long pPreserveAttachments$offset() {
        return pPreserveAttachments$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const uint32_t *pPreserveAttachments
     * }
     */
    public static MemorySegment pPreserveAttachments(MemorySegment struct) {
        return struct.get(pPreserveAttachments$LAYOUT, pPreserveAttachments$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const uint32_t *pPreserveAttachments
     * }
     */
    public static void pPreserveAttachments(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(pPreserveAttachments$LAYOUT, pPreserveAttachments$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction) (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction) (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

