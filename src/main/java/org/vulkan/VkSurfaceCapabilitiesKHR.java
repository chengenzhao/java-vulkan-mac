// Generated by jextract

package org.vulkan;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct VkSurfaceCapabilitiesKHR {
 *     uint32_t minImageCount;
 *     uint32_t maxImageCount;
 *     VkExtent2D currentExtent;
 *     VkExtent2D minImageExtent;
 *     VkExtent2D maxImageExtent;
 *     uint32_t maxImageArrayLayers;
 *     VkSurfaceTransformFlagsKHR supportedTransforms;
 *     VkSurfaceTransformFlagBitsKHR currentTransform;
 *     VkCompositeAlphaFlagsKHR supportedCompositeAlpha;
 *     VkImageUsageFlags supportedUsageFlags;
 * }
 * }
 */
public class VkSurfaceCapabilitiesKHR {

    VkSurfaceCapabilitiesKHR() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        vulkan_h.C_INT.withName("minImageCount"),
        vulkan_h.C_INT.withName("maxImageCount"),
        VkExtent2D.layout().withName("currentExtent"),
        VkExtent2D.layout().withName("minImageExtent"),
        VkExtent2D.layout().withName("maxImageExtent"),
        vulkan_h.C_INT.withName("maxImageArrayLayers"),
        vulkan_h.C_INT.withName("supportedTransforms"),
        vulkan_h.C_INT.withName("currentTransform"),
        vulkan_h.C_INT.withName("supportedCompositeAlpha"),
        vulkan_h.C_INT.withName("supportedUsageFlags")
    ).withName("VkSurfaceCapabilitiesKHR");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final OfInt minImageCount$LAYOUT = (OfInt)$LAYOUT.select(groupElement("minImageCount"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint32_t minImageCount
     * }
     */
    public static final OfInt minImageCount$layout() {
        return minImageCount$LAYOUT;
    }

    private static final long minImageCount$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint32_t minImageCount
     * }
     */
    public static final long minImageCount$offset() {
        return minImageCount$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint32_t minImageCount
     * }
     */
    public static int minImageCount(MemorySegment struct) {
        return struct.get(minImageCount$LAYOUT, minImageCount$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint32_t minImageCount
     * }
     */
    public static void minImageCount(MemorySegment struct, int fieldValue) {
        struct.set(minImageCount$LAYOUT, minImageCount$OFFSET, fieldValue);
    }

    private static final OfInt maxImageCount$LAYOUT = (OfInt)$LAYOUT.select(groupElement("maxImageCount"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint32_t maxImageCount
     * }
     */
    public static final OfInt maxImageCount$layout() {
        return maxImageCount$LAYOUT;
    }

    private static final long maxImageCount$OFFSET = 4;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint32_t maxImageCount
     * }
     */
    public static final long maxImageCount$offset() {
        return maxImageCount$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint32_t maxImageCount
     * }
     */
    public static int maxImageCount(MemorySegment struct) {
        return struct.get(maxImageCount$LAYOUT, maxImageCount$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint32_t maxImageCount
     * }
     */
    public static void maxImageCount(MemorySegment struct, int fieldValue) {
        struct.set(maxImageCount$LAYOUT, maxImageCount$OFFSET, fieldValue);
    }

    private static final GroupLayout currentExtent$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("currentExtent"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * VkExtent2D currentExtent
     * }
     */
    public static final GroupLayout currentExtent$layout() {
        return currentExtent$LAYOUT;
    }

    private static final long currentExtent$OFFSET = 8;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * VkExtent2D currentExtent
     * }
     */
    public static final long currentExtent$offset() {
        return currentExtent$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * VkExtent2D currentExtent
     * }
     */
    public static MemorySegment currentExtent(MemorySegment struct) {
        return struct.asSlice(currentExtent$OFFSET, currentExtent$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * VkExtent2D currentExtent
     * }
     */
    public static void currentExtent(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, currentExtent$OFFSET, currentExtent$LAYOUT.byteSize());
    }

    private static final GroupLayout minImageExtent$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("minImageExtent"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * VkExtent2D minImageExtent
     * }
     */
    public static final GroupLayout minImageExtent$layout() {
        return minImageExtent$LAYOUT;
    }

    private static final long minImageExtent$OFFSET = 16;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * VkExtent2D minImageExtent
     * }
     */
    public static final long minImageExtent$offset() {
        return minImageExtent$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * VkExtent2D minImageExtent
     * }
     */
    public static MemorySegment minImageExtent(MemorySegment struct) {
        return struct.asSlice(minImageExtent$OFFSET, minImageExtent$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * VkExtent2D minImageExtent
     * }
     */
    public static void minImageExtent(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, minImageExtent$OFFSET, minImageExtent$LAYOUT.byteSize());
    }

    private static final GroupLayout maxImageExtent$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("maxImageExtent"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * VkExtent2D maxImageExtent
     * }
     */
    public static final GroupLayout maxImageExtent$layout() {
        return maxImageExtent$LAYOUT;
    }

    private static final long maxImageExtent$OFFSET = 24;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * VkExtent2D maxImageExtent
     * }
     */
    public static final long maxImageExtent$offset() {
        return maxImageExtent$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * VkExtent2D maxImageExtent
     * }
     */
    public static MemorySegment maxImageExtent(MemorySegment struct) {
        return struct.asSlice(maxImageExtent$OFFSET, maxImageExtent$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * VkExtent2D maxImageExtent
     * }
     */
    public static void maxImageExtent(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, maxImageExtent$OFFSET, maxImageExtent$LAYOUT.byteSize());
    }

    private static final OfInt maxImageArrayLayers$LAYOUT = (OfInt)$LAYOUT.select(groupElement("maxImageArrayLayers"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint32_t maxImageArrayLayers
     * }
     */
    public static final OfInt maxImageArrayLayers$layout() {
        return maxImageArrayLayers$LAYOUT;
    }

    private static final long maxImageArrayLayers$OFFSET = 32;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint32_t maxImageArrayLayers
     * }
     */
    public static final long maxImageArrayLayers$offset() {
        return maxImageArrayLayers$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint32_t maxImageArrayLayers
     * }
     */
    public static int maxImageArrayLayers(MemorySegment struct) {
        return struct.get(maxImageArrayLayers$LAYOUT, maxImageArrayLayers$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint32_t maxImageArrayLayers
     * }
     */
    public static void maxImageArrayLayers(MemorySegment struct, int fieldValue) {
        struct.set(maxImageArrayLayers$LAYOUT, maxImageArrayLayers$OFFSET, fieldValue);
    }

    private static final OfInt supportedTransforms$LAYOUT = (OfInt)$LAYOUT.select(groupElement("supportedTransforms"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * VkSurfaceTransformFlagsKHR supportedTransforms
     * }
     */
    public static final OfInt supportedTransforms$layout() {
        return supportedTransforms$LAYOUT;
    }

    private static final long supportedTransforms$OFFSET = 36;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * VkSurfaceTransformFlagsKHR supportedTransforms
     * }
     */
    public static final long supportedTransforms$offset() {
        return supportedTransforms$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * VkSurfaceTransformFlagsKHR supportedTransforms
     * }
     */
    public static int supportedTransforms(MemorySegment struct) {
        return struct.get(supportedTransforms$LAYOUT, supportedTransforms$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * VkSurfaceTransformFlagsKHR supportedTransforms
     * }
     */
    public static void supportedTransforms(MemorySegment struct, int fieldValue) {
        struct.set(supportedTransforms$LAYOUT, supportedTransforms$OFFSET, fieldValue);
    }

    private static final OfInt currentTransform$LAYOUT = (OfInt)$LAYOUT.select(groupElement("currentTransform"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * VkSurfaceTransformFlagBitsKHR currentTransform
     * }
     */
    public static final OfInt currentTransform$layout() {
        return currentTransform$LAYOUT;
    }

    private static final long currentTransform$OFFSET = 40;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * VkSurfaceTransformFlagBitsKHR currentTransform
     * }
     */
    public static final long currentTransform$offset() {
        return currentTransform$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * VkSurfaceTransformFlagBitsKHR currentTransform
     * }
     */
    public static int currentTransform(MemorySegment struct) {
        return struct.get(currentTransform$LAYOUT, currentTransform$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * VkSurfaceTransformFlagBitsKHR currentTransform
     * }
     */
    public static void currentTransform(MemorySegment struct, int fieldValue) {
        struct.set(currentTransform$LAYOUT, currentTransform$OFFSET, fieldValue);
    }

    private static final OfInt supportedCompositeAlpha$LAYOUT = (OfInt)$LAYOUT.select(groupElement("supportedCompositeAlpha"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * VkCompositeAlphaFlagsKHR supportedCompositeAlpha
     * }
     */
    public static final OfInt supportedCompositeAlpha$layout() {
        return supportedCompositeAlpha$LAYOUT;
    }

    private static final long supportedCompositeAlpha$OFFSET = 44;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * VkCompositeAlphaFlagsKHR supportedCompositeAlpha
     * }
     */
    public static final long supportedCompositeAlpha$offset() {
        return supportedCompositeAlpha$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * VkCompositeAlphaFlagsKHR supportedCompositeAlpha
     * }
     */
    public static int supportedCompositeAlpha(MemorySegment struct) {
        return struct.get(supportedCompositeAlpha$LAYOUT, supportedCompositeAlpha$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * VkCompositeAlphaFlagsKHR supportedCompositeAlpha
     * }
     */
    public static void supportedCompositeAlpha(MemorySegment struct, int fieldValue) {
        struct.set(supportedCompositeAlpha$LAYOUT, supportedCompositeAlpha$OFFSET, fieldValue);
    }

    private static final OfInt supportedUsageFlags$LAYOUT = (OfInt)$LAYOUT.select(groupElement("supportedUsageFlags"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * VkImageUsageFlags supportedUsageFlags
     * }
     */
    public static final OfInt supportedUsageFlags$layout() {
        return supportedUsageFlags$LAYOUT;
    }

    private static final long supportedUsageFlags$OFFSET = 48;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * VkImageUsageFlags supportedUsageFlags
     * }
     */
    public static final long supportedUsageFlags$offset() {
        return supportedUsageFlags$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * VkImageUsageFlags supportedUsageFlags
     * }
     */
    public static int supportedUsageFlags(MemorySegment struct) {
        return struct.get(supportedUsageFlags$LAYOUT, supportedUsageFlags$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * VkImageUsageFlags supportedUsageFlags
     * }
     */
    public static void supportedUsageFlags(MemorySegment struct, int fieldValue) {
        struct.set(supportedUsageFlags$LAYOUT, supportedUsageFlags$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction) (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction) (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

