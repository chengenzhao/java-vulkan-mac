// Generated by jextract

package org.vulkan;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class vulkan_h extends vulkan_h_1 {

    vulkan_h() {
        // Should not be called directly
    }
    private static final int VK_VALIDATION_FEATURE_ENABLE_SYNCHRONIZATION_VALIDATION_EXT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkValidationFeatureEnableEXT.VK_VALIDATION_FEATURE_ENABLE_SYNCHRONIZATION_VALIDATION_EXT = 4
     * }
     */
    public static int VK_VALIDATION_FEATURE_ENABLE_SYNCHRONIZATION_VALIDATION_EXT() {
        return VK_VALIDATION_FEATURE_ENABLE_SYNCHRONIZATION_VALIDATION_EXT;
    }
    private static final int VK_VALIDATION_FEATURE_ENABLE_MAX_ENUM_EXT = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkValidationFeatureEnableEXT.VK_VALIDATION_FEATURE_ENABLE_MAX_ENUM_EXT = 2147483647
     * }
     */
    public static int VK_VALIDATION_FEATURE_ENABLE_MAX_ENUM_EXT() {
        return VK_VALIDATION_FEATURE_ENABLE_MAX_ENUM_EXT;
    }
    private static final int VK_VALIDATION_FEATURE_DISABLE_ALL_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkValidationFeatureDisableEXT.VK_VALIDATION_FEATURE_DISABLE_ALL_EXT = 0
     * }
     */
    public static int VK_VALIDATION_FEATURE_DISABLE_ALL_EXT() {
        return VK_VALIDATION_FEATURE_DISABLE_ALL_EXT;
    }
    private static final int VK_VALIDATION_FEATURE_DISABLE_SHADERS_EXT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkValidationFeatureDisableEXT.VK_VALIDATION_FEATURE_DISABLE_SHADERS_EXT = 1
     * }
     */
    public static int VK_VALIDATION_FEATURE_DISABLE_SHADERS_EXT() {
        return VK_VALIDATION_FEATURE_DISABLE_SHADERS_EXT;
    }
    private static final int VK_VALIDATION_FEATURE_DISABLE_THREAD_SAFETY_EXT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkValidationFeatureDisableEXT.VK_VALIDATION_FEATURE_DISABLE_THREAD_SAFETY_EXT = 2
     * }
     */
    public static int VK_VALIDATION_FEATURE_DISABLE_THREAD_SAFETY_EXT() {
        return VK_VALIDATION_FEATURE_DISABLE_THREAD_SAFETY_EXT;
    }
    private static final int VK_VALIDATION_FEATURE_DISABLE_API_PARAMETERS_EXT = (int)3L;
    /**
     * {@snippet lang=c :
     * enum VkValidationFeatureDisableEXT.VK_VALIDATION_FEATURE_DISABLE_API_PARAMETERS_EXT = 3
     * }
     */
    public static int VK_VALIDATION_FEATURE_DISABLE_API_PARAMETERS_EXT() {
        return VK_VALIDATION_FEATURE_DISABLE_API_PARAMETERS_EXT;
    }
    private static final int VK_VALIDATION_FEATURE_DISABLE_OBJECT_LIFETIMES_EXT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkValidationFeatureDisableEXT.VK_VALIDATION_FEATURE_DISABLE_OBJECT_LIFETIMES_EXT = 4
     * }
     */
    public static int VK_VALIDATION_FEATURE_DISABLE_OBJECT_LIFETIMES_EXT() {
        return VK_VALIDATION_FEATURE_DISABLE_OBJECT_LIFETIMES_EXT;
    }
    private static final int VK_VALIDATION_FEATURE_DISABLE_CORE_CHECKS_EXT = (int)5L;
    /**
     * {@snippet lang=c :
     * enum VkValidationFeatureDisableEXT.VK_VALIDATION_FEATURE_DISABLE_CORE_CHECKS_EXT = 5
     * }
     */
    public static int VK_VALIDATION_FEATURE_DISABLE_CORE_CHECKS_EXT() {
        return VK_VALIDATION_FEATURE_DISABLE_CORE_CHECKS_EXT;
    }
    private static final int VK_VALIDATION_FEATURE_DISABLE_UNIQUE_HANDLES_EXT = (int)6L;
    /**
     * {@snippet lang=c :
     * enum VkValidationFeatureDisableEXT.VK_VALIDATION_FEATURE_DISABLE_UNIQUE_HANDLES_EXT = 6
     * }
     */
    public static int VK_VALIDATION_FEATURE_DISABLE_UNIQUE_HANDLES_EXT() {
        return VK_VALIDATION_FEATURE_DISABLE_UNIQUE_HANDLES_EXT;
    }
    private static final int VK_VALIDATION_FEATURE_DISABLE_SHADER_VALIDATION_CACHE_EXT = (int)7L;
    /**
     * {@snippet lang=c :
     * enum VkValidationFeatureDisableEXT.VK_VALIDATION_FEATURE_DISABLE_SHADER_VALIDATION_CACHE_EXT = 7
     * }
     */
    public static int VK_VALIDATION_FEATURE_DISABLE_SHADER_VALIDATION_CACHE_EXT() {
        return VK_VALIDATION_FEATURE_DISABLE_SHADER_VALIDATION_CACHE_EXT;
    }
    private static final int VK_VALIDATION_FEATURE_DISABLE_MAX_ENUM_EXT = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkValidationFeatureDisableEXT.VK_VALIDATION_FEATURE_DISABLE_MAX_ENUM_EXT = 2147483647
     * }
     */
    public static int VK_VALIDATION_FEATURE_DISABLE_MAX_ENUM_EXT() {
        return VK_VALIDATION_FEATURE_DISABLE_MAX_ENUM_EXT;
    }

    private static class vkGetPhysicalDeviceCooperativeMatrixPropertiesNV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkGetPhysicalDeviceCooperativeMatrixPropertiesNV"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceCooperativeMatrixPropertiesNV(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkCooperativeMatrixPropertiesNV *pProperties)
     * }
     */
    public static FunctionDescriptor vkGetPhysicalDeviceCooperativeMatrixPropertiesNV$descriptor() {
        return vkGetPhysicalDeviceCooperativeMatrixPropertiesNV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceCooperativeMatrixPropertiesNV(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkCooperativeMatrixPropertiesNV *pProperties)
     * }
     */
    public static MethodHandle vkGetPhysicalDeviceCooperativeMatrixPropertiesNV$handle() {
        return vkGetPhysicalDeviceCooperativeMatrixPropertiesNV.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceCooperativeMatrixPropertiesNV(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkCooperativeMatrixPropertiesNV *pProperties)
     * }
     */
    public static int vkGetPhysicalDeviceCooperativeMatrixPropertiesNV(MemorySegment physicalDevice, MemorySegment pPropertyCount, MemorySegment pProperties) {
        var mh$ = vkGetPhysicalDeviceCooperativeMatrixPropertiesNV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetPhysicalDeviceCooperativeMatrixPropertiesNV", physicalDevice, pPropertyCount, pProperties);
            }
            return (int)mh$.invokeExact(physicalDevice, pPropertyCount, pProperties);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int VK_COVERAGE_REDUCTION_MODE_MERGE_NV = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkCoverageReductionModeNV.VK_COVERAGE_REDUCTION_MODE_MERGE_NV = 0
     * }
     */
    public static int VK_COVERAGE_REDUCTION_MODE_MERGE_NV() {
        return VK_COVERAGE_REDUCTION_MODE_MERGE_NV;
    }
    private static final int VK_COVERAGE_REDUCTION_MODE_TRUNCATE_NV = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkCoverageReductionModeNV.VK_COVERAGE_REDUCTION_MODE_TRUNCATE_NV = 1
     * }
     */
    public static int VK_COVERAGE_REDUCTION_MODE_TRUNCATE_NV() {
        return VK_COVERAGE_REDUCTION_MODE_TRUNCATE_NV;
    }
    private static final int VK_COVERAGE_REDUCTION_MODE_MAX_ENUM_NV = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkCoverageReductionModeNV.VK_COVERAGE_REDUCTION_MODE_MAX_ENUM_NV = 2147483647
     * }
     */
    public static int VK_COVERAGE_REDUCTION_MODE_MAX_ENUM_NV() {
        return VK_COVERAGE_REDUCTION_MODE_MAX_ENUM_NV;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkPipelineCoverageReductionStateCreateFlagsNV
     * }
     */
    public static final OfInt VkPipelineCoverageReductionStateCreateFlagsNV = vulkan_h.C_INT;

    private static class vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(VkPhysicalDevice physicalDevice, uint32_t *pCombinationCount, VkFramebufferMixedSamplesCombinationNV *pCombinations)
     * }
     */
    public static FunctionDescriptor vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV$descriptor() {
        return vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(VkPhysicalDevice physicalDevice, uint32_t *pCombinationCount, VkFramebufferMixedSamplesCombinationNV *pCombinations)
     * }
     */
    public static MethodHandle vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV$handle() {
        return vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(VkPhysicalDevice physicalDevice, uint32_t *pCombinationCount, VkFramebufferMixedSamplesCombinationNV *pCombinations)
     * }
     */
    public static int vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(MemorySegment physicalDevice, MemorySegment pCombinationCount, MemorySegment pCombinations) {
        var mh$ = vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV", physicalDevice, pCombinationCount, pCombinations);
            }
            return (int)mh$.invokeExact(physicalDevice, pCombinationCount, pCombinations);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int VK_PROVOKING_VERTEX_MODE_FIRST_VERTEX_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkProvokingVertexModeEXT.VK_PROVOKING_VERTEX_MODE_FIRST_VERTEX_EXT = 0
     * }
     */
    public static int VK_PROVOKING_VERTEX_MODE_FIRST_VERTEX_EXT() {
        return VK_PROVOKING_VERTEX_MODE_FIRST_VERTEX_EXT;
    }
    private static final int VK_PROVOKING_VERTEX_MODE_LAST_VERTEX_EXT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkProvokingVertexModeEXT.VK_PROVOKING_VERTEX_MODE_LAST_VERTEX_EXT = 1
     * }
     */
    public static int VK_PROVOKING_VERTEX_MODE_LAST_VERTEX_EXT() {
        return VK_PROVOKING_VERTEX_MODE_LAST_VERTEX_EXT;
    }
    private static final int VK_PROVOKING_VERTEX_MODE_MAX_ENUM_EXT = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkProvokingVertexModeEXT.VK_PROVOKING_VERTEX_MODE_MAX_ENUM_EXT = 2147483647
     * }
     */
    public static int VK_PROVOKING_VERTEX_MODE_MAX_ENUM_EXT() {
        return VK_PROVOKING_VERTEX_MODE_MAX_ENUM_EXT;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkHeadlessSurfaceCreateFlagsEXT
     * }
     */
    public static final OfInt VkHeadlessSurfaceCreateFlagsEXT = vulkan_h.C_INT;

    private static class vkCreateHeadlessSurfaceEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCreateHeadlessSurfaceEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkCreateHeadlessSurfaceEXT(VkInstance instance, const VkHeadlessSurfaceCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface)
     * }
     */
    public static FunctionDescriptor vkCreateHeadlessSurfaceEXT$descriptor() {
        return vkCreateHeadlessSurfaceEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkCreateHeadlessSurfaceEXT(VkInstance instance, const VkHeadlessSurfaceCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface)
     * }
     */
    public static MethodHandle vkCreateHeadlessSurfaceEXT$handle() {
        return vkCreateHeadlessSurfaceEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * VkResult vkCreateHeadlessSurfaceEXT(VkInstance instance, const VkHeadlessSurfaceCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface)
     * }
     */
    public static int vkCreateHeadlessSurfaceEXT(MemorySegment instance, MemorySegment pCreateInfo, MemorySegment pAllocator, MemorySegment pSurface) {
        var mh$ = vkCreateHeadlessSurfaceEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCreateHeadlessSurfaceEXT", instance, pCreateInfo, pAllocator, pSurface);
            }
            return (int)mh$.invokeExact(instance, pCreateInfo, pAllocator, pSurface);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdSetLineStippleEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_SHORT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdSetLineStippleEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdSetLineStippleEXT(VkCommandBuffer commandBuffer, uint32_t lineStippleFactor, uint16_t lineStipplePattern)
     * }
     */
    public static FunctionDescriptor vkCmdSetLineStippleEXT$descriptor() {
        return vkCmdSetLineStippleEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdSetLineStippleEXT(VkCommandBuffer commandBuffer, uint32_t lineStippleFactor, uint16_t lineStipplePattern)
     * }
     */
    public static MethodHandle vkCmdSetLineStippleEXT$handle() {
        return vkCmdSetLineStippleEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdSetLineStippleEXT(VkCommandBuffer commandBuffer, uint32_t lineStippleFactor, uint16_t lineStipplePattern)
     * }
     */
    public static void vkCmdSetLineStippleEXT(MemorySegment commandBuffer, int lineStippleFactor, short lineStipplePattern) {
        var mh$ = vkCmdSetLineStippleEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetLineStippleEXT", commandBuffer, lineStippleFactor, lineStipplePattern);
            }
            mh$.invokeExact(commandBuffer, lineStippleFactor, lineStipplePattern);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkResetQueryPoolEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkResetQueryPoolEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkResetQueryPoolEXT(VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount)
     * }
     */
    public static FunctionDescriptor vkResetQueryPoolEXT$descriptor() {
        return vkResetQueryPoolEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkResetQueryPoolEXT(VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount)
     * }
     */
    public static MethodHandle vkResetQueryPoolEXT$handle() {
        return vkResetQueryPoolEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkResetQueryPoolEXT(VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount)
     * }
     */
    public static void vkResetQueryPoolEXT(MemorySegment device, MemorySegment queryPool, int firstQuery, int queryCount) {
        var mh$ = vkResetQueryPoolEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkResetQueryPoolEXT", device, queryPool, firstQuery, queryCount);
            }
            mh$.invokeExact(device, queryPool, firstQuery, queryCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdSetCullModeEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdSetCullModeEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdSetCullModeEXT(VkCommandBuffer commandBuffer, VkCullModeFlags cullMode)
     * }
     */
    public static FunctionDescriptor vkCmdSetCullModeEXT$descriptor() {
        return vkCmdSetCullModeEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdSetCullModeEXT(VkCommandBuffer commandBuffer, VkCullModeFlags cullMode)
     * }
     */
    public static MethodHandle vkCmdSetCullModeEXT$handle() {
        return vkCmdSetCullModeEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdSetCullModeEXT(VkCommandBuffer commandBuffer, VkCullModeFlags cullMode)
     * }
     */
    public static void vkCmdSetCullModeEXT(MemorySegment commandBuffer, int cullMode) {
        var mh$ = vkCmdSetCullModeEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetCullModeEXT", commandBuffer, cullMode);
            }
            mh$.invokeExact(commandBuffer, cullMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdSetFrontFaceEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdSetFrontFaceEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdSetFrontFaceEXT(VkCommandBuffer commandBuffer, VkFrontFace frontFace)
     * }
     */
    public static FunctionDescriptor vkCmdSetFrontFaceEXT$descriptor() {
        return vkCmdSetFrontFaceEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdSetFrontFaceEXT(VkCommandBuffer commandBuffer, VkFrontFace frontFace)
     * }
     */
    public static MethodHandle vkCmdSetFrontFaceEXT$handle() {
        return vkCmdSetFrontFaceEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdSetFrontFaceEXT(VkCommandBuffer commandBuffer, VkFrontFace frontFace)
     * }
     */
    public static void vkCmdSetFrontFaceEXT(MemorySegment commandBuffer, int frontFace) {
        var mh$ = vkCmdSetFrontFaceEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetFrontFaceEXT", commandBuffer, frontFace);
            }
            mh$.invokeExact(commandBuffer, frontFace);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdSetPrimitiveTopologyEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdSetPrimitiveTopologyEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdSetPrimitiveTopologyEXT(VkCommandBuffer commandBuffer, VkPrimitiveTopology primitiveTopology)
     * }
     */
    public static FunctionDescriptor vkCmdSetPrimitiveTopologyEXT$descriptor() {
        return vkCmdSetPrimitiveTopologyEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdSetPrimitiveTopologyEXT(VkCommandBuffer commandBuffer, VkPrimitiveTopology primitiveTopology)
     * }
     */
    public static MethodHandle vkCmdSetPrimitiveTopologyEXT$handle() {
        return vkCmdSetPrimitiveTopologyEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdSetPrimitiveTopologyEXT(VkCommandBuffer commandBuffer, VkPrimitiveTopology primitiveTopology)
     * }
     */
    public static void vkCmdSetPrimitiveTopologyEXT(MemorySegment commandBuffer, int primitiveTopology) {
        var mh$ = vkCmdSetPrimitiveTopologyEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetPrimitiveTopologyEXT", commandBuffer, primitiveTopology);
            }
            mh$.invokeExact(commandBuffer, primitiveTopology);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdSetViewportWithCountEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdSetViewportWithCountEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdSetViewportWithCountEXT(VkCommandBuffer commandBuffer, uint32_t viewportCount, const VkViewport *pViewports)
     * }
     */
    public static FunctionDescriptor vkCmdSetViewportWithCountEXT$descriptor() {
        return vkCmdSetViewportWithCountEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdSetViewportWithCountEXT(VkCommandBuffer commandBuffer, uint32_t viewportCount, const VkViewport *pViewports)
     * }
     */
    public static MethodHandle vkCmdSetViewportWithCountEXT$handle() {
        return vkCmdSetViewportWithCountEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdSetViewportWithCountEXT(VkCommandBuffer commandBuffer, uint32_t viewportCount, const VkViewport *pViewports)
     * }
     */
    public static void vkCmdSetViewportWithCountEXT(MemorySegment commandBuffer, int viewportCount, MemorySegment pViewports) {
        var mh$ = vkCmdSetViewportWithCountEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetViewportWithCountEXT", commandBuffer, viewportCount, pViewports);
            }
            mh$.invokeExact(commandBuffer, viewportCount, pViewports);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdSetScissorWithCountEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdSetScissorWithCountEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdSetScissorWithCountEXT(VkCommandBuffer commandBuffer, uint32_t scissorCount, const VkRect2D *pScissors)
     * }
     */
    public static FunctionDescriptor vkCmdSetScissorWithCountEXT$descriptor() {
        return vkCmdSetScissorWithCountEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdSetScissorWithCountEXT(VkCommandBuffer commandBuffer, uint32_t scissorCount, const VkRect2D *pScissors)
     * }
     */
    public static MethodHandle vkCmdSetScissorWithCountEXT$handle() {
        return vkCmdSetScissorWithCountEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdSetScissorWithCountEXT(VkCommandBuffer commandBuffer, uint32_t scissorCount, const VkRect2D *pScissors)
     * }
     */
    public static void vkCmdSetScissorWithCountEXT(MemorySegment commandBuffer, int scissorCount, MemorySegment pScissors) {
        var mh$ = vkCmdSetScissorWithCountEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetScissorWithCountEXT", commandBuffer, scissorCount, pScissors);
            }
            mh$.invokeExact(commandBuffer, scissorCount, pScissors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdBindVertexBuffers2EXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdBindVertexBuffers2EXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdBindVertexBuffers2EXT(VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer *pBuffers, const VkDeviceSize *pOffsets, const VkDeviceSize *pSizes, const VkDeviceSize *pStrides)
     * }
     */
    public static FunctionDescriptor vkCmdBindVertexBuffers2EXT$descriptor() {
        return vkCmdBindVertexBuffers2EXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdBindVertexBuffers2EXT(VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer *pBuffers, const VkDeviceSize *pOffsets, const VkDeviceSize *pSizes, const VkDeviceSize *pStrides)
     * }
     */
    public static MethodHandle vkCmdBindVertexBuffers2EXT$handle() {
        return vkCmdBindVertexBuffers2EXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdBindVertexBuffers2EXT(VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer *pBuffers, const VkDeviceSize *pOffsets, const VkDeviceSize *pSizes, const VkDeviceSize *pStrides)
     * }
     */
    public static void vkCmdBindVertexBuffers2EXT(MemorySegment commandBuffer, int firstBinding, int bindingCount, MemorySegment pBuffers, MemorySegment pOffsets, MemorySegment pSizes, MemorySegment pStrides) {
        var mh$ = vkCmdBindVertexBuffers2EXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdBindVertexBuffers2EXT", commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes, pStrides);
            }
            mh$.invokeExact(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes, pStrides);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdSetDepthTestEnableEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdSetDepthTestEnableEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdSetDepthTestEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthTestEnable)
     * }
     */
    public static FunctionDescriptor vkCmdSetDepthTestEnableEXT$descriptor() {
        return vkCmdSetDepthTestEnableEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdSetDepthTestEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthTestEnable)
     * }
     */
    public static MethodHandle vkCmdSetDepthTestEnableEXT$handle() {
        return vkCmdSetDepthTestEnableEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdSetDepthTestEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthTestEnable)
     * }
     */
    public static void vkCmdSetDepthTestEnableEXT(MemorySegment commandBuffer, int depthTestEnable) {
        var mh$ = vkCmdSetDepthTestEnableEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetDepthTestEnableEXT", commandBuffer, depthTestEnable);
            }
            mh$.invokeExact(commandBuffer, depthTestEnable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdSetDepthWriteEnableEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdSetDepthWriteEnableEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdSetDepthWriteEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthWriteEnable)
     * }
     */
    public static FunctionDescriptor vkCmdSetDepthWriteEnableEXT$descriptor() {
        return vkCmdSetDepthWriteEnableEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdSetDepthWriteEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthWriteEnable)
     * }
     */
    public static MethodHandle vkCmdSetDepthWriteEnableEXT$handle() {
        return vkCmdSetDepthWriteEnableEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdSetDepthWriteEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthWriteEnable)
     * }
     */
    public static void vkCmdSetDepthWriteEnableEXT(MemorySegment commandBuffer, int depthWriteEnable) {
        var mh$ = vkCmdSetDepthWriteEnableEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetDepthWriteEnableEXT", commandBuffer, depthWriteEnable);
            }
            mh$.invokeExact(commandBuffer, depthWriteEnable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdSetDepthCompareOpEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdSetDepthCompareOpEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdSetDepthCompareOpEXT(VkCommandBuffer commandBuffer, VkCompareOp depthCompareOp)
     * }
     */
    public static FunctionDescriptor vkCmdSetDepthCompareOpEXT$descriptor() {
        return vkCmdSetDepthCompareOpEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdSetDepthCompareOpEXT(VkCommandBuffer commandBuffer, VkCompareOp depthCompareOp)
     * }
     */
    public static MethodHandle vkCmdSetDepthCompareOpEXT$handle() {
        return vkCmdSetDepthCompareOpEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdSetDepthCompareOpEXT(VkCommandBuffer commandBuffer, VkCompareOp depthCompareOp)
     * }
     */
    public static void vkCmdSetDepthCompareOpEXT(MemorySegment commandBuffer, int depthCompareOp) {
        var mh$ = vkCmdSetDepthCompareOpEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetDepthCompareOpEXT", commandBuffer, depthCompareOp);
            }
            mh$.invokeExact(commandBuffer, depthCompareOp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdSetDepthBoundsTestEnableEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdSetDepthBoundsTestEnableEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdSetDepthBoundsTestEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthBoundsTestEnable)
     * }
     */
    public static FunctionDescriptor vkCmdSetDepthBoundsTestEnableEXT$descriptor() {
        return vkCmdSetDepthBoundsTestEnableEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdSetDepthBoundsTestEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthBoundsTestEnable)
     * }
     */
    public static MethodHandle vkCmdSetDepthBoundsTestEnableEXT$handle() {
        return vkCmdSetDepthBoundsTestEnableEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdSetDepthBoundsTestEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthBoundsTestEnable)
     * }
     */
    public static void vkCmdSetDepthBoundsTestEnableEXT(MemorySegment commandBuffer, int depthBoundsTestEnable) {
        var mh$ = vkCmdSetDepthBoundsTestEnableEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetDepthBoundsTestEnableEXT", commandBuffer, depthBoundsTestEnable);
            }
            mh$.invokeExact(commandBuffer, depthBoundsTestEnable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdSetStencilTestEnableEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdSetStencilTestEnableEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdSetStencilTestEnableEXT(VkCommandBuffer commandBuffer, VkBool32 stencilTestEnable)
     * }
     */
    public static FunctionDescriptor vkCmdSetStencilTestEnableEXT$descriptor() {
        return vkCmdSetStencilTestEnableEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdSetStencilTestEnableEXT(VkCommandBuffer commandBuffer, VkBool32 stencilTestEnable)
     * }
     */
    public static MethodHandle vkCmdSetStencilTestEnableEXT$handle() {
        return vkCmdSetStencilTestEnableEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdSetStencilTestEnableEXT(VkCommandBuffer commandBuffer, VkBool32 stencilTestEnable)
     * }
     */
    public static void vkCmdSetStencilTestEnableEXT(MemorySegment commandBuffer, int stencilTestEnable) {
        var mh$ = vkCmdSetStencilTestEnableEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetStencilTestEnableEXT", commandBuffer, stencilTestEnable);
            }
            mh$.invokeExact(commandBuffer, stencilTestEnable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdSetStencilOpEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdSetStencilOpEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdSetStencilOpEXT(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, VkStencilOp failOp, VkStencilOp passOp, VkStencilOp depthFailOp, VkCompareOp compareOp)
     * }
     */
    public static FunctionDescriptor vkCmdSetStencilOpEXT$descriptor() {
        return vkCmdSetStencilOpEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdSetStencilOpEXT(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, VkStencilOp failOp, VkStencilOp passOp, VkStencilOp depthFailOp, VkCompareOp compareOp)
     * }
     */
    public static MethodHandle vkCmdSetStencilOpEXT$handle() {
        return vkCmdSetStencilOpEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdSetStencilOpEXT(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, VkStencilOp failOp, VkStencilOp passOp, VkStencilOp depthFailOp, VkCompareOp compareOp)
     * }
     */
    public static void vkCmdSetStencilOpEXT(MemorySegment commandBuffer, int faceMask, int failOp, int passOp, int depthFailOp, int compareOp) {
        var mh$ = vkCmdSetStencilOpEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetStencilOpEXT", commandBuffer, faceMask, failOp, passOp, depthFailOp, compareOp);
            }
            mh$.invokeExact(commandBuffer, faceMask, failOp, passOp, depthFailOp, compareOp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int VK_HOST_IMAGE_COPY_MEMCPY_EXT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkHostImageCopyFlagBitsEXT.VK_HOST_IMAGE_COPY_MEMCPY_EXT = 1
     * }
     */
    public static int VK_HOST_IMAGE_COPY_MEMCPY_EXT() {
        return VK_HOST_IMAGE_COPY_MEMCPY_EXT;
    }
    private static final int VK_HOST_IMAGE_COPY_FLAG_BITS_MAX_ENUM_EXT = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkHostImageCopyFlagBitsEXT.VK_HOST_IMAGE_COPY_FLAG_BITS_MAX_ENUM_EXT = 2147483647
     * }
     */
    public static int VK_HOST_IMAGE_COPY_FLAG_BITS_MAX_ENUM_EXT() {
        return VK_HOST_IMAGE_COPY_FLAG_BITS_MAX_ENUM_EXT;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkHostImageCopyFlagsEXT
     * }
     */
    public static final OfInt VkHostImageCopyFlagsEXT = vulkan_h.C_INT;

    private static class vkCopyMemoryToImageEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCopyMemoryToImageEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkCopyMemoryToImageEXT(VkDevice device, const VkCopyMemoryToImageInfoEXT *pCopyMemoryToImageInfo)
     * }
     */
    public static FunctionDescriptor vkCopyMemoryToImageEXT$descriptor() {
        return vkCopyMemoryToImageEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkCopyMemoryToImageEXT(VkDevice device, const VkCopyMemoryToImageInfoEXT *pCopyMemoryToImageInfo)
     * }
     */
    public static MethodHandle vkCopyMemoryToImageEXT$handle() {
        return vkCopyMemoryToImageEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * VkResult vkCopyMemoryToImageEXT(VkDevice device, const VkCopyMemoryToImageInfoEXT *pCopyMemoryToImageInfo)
     * }
     */
    public static int vkCopyMemoryToImageEXT(MemorySegment device, MemorySegment pCopyMemoryToImageInfo) {
        var mh$ = vkCopyMemoryToImageEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCopyMemoryToImageEXT", device, pCopyMemoryToImageInfo);
            }
            return (int)mh$.invokeExact(device, pCopyMemoryToImageInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCopyImageToMemoryEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCopyImageToMemoryEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkCopyImageToMemoryEXT(VkDevice device, const VkCopyImageToMemoryInfoEXT *pCopyImageToMemoryInfo)
     * }
     */
    public static FunctionDescriptor vkCopyImageToMemoryEXT$descriptor() {
        return vkCopyImageToMemoryEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkCopyImageToMemoryEXT(VkDevice device, const VkCopyImageToMemoryInfoEXT *pCopyImageToMemoryInfo)
     * }
     */
    public static MethodHandle vkCopyImageToMemoryEXT$handle() {
        return vkCopyImageToMemoryEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * VkResult vkCopyImageToMemoryEXT(VkDevice device, const VkCopyImageToMemoryInfoEXT *pCopyImageToMemoryInfo)
     * }
     */
    public static int vkCopyImageToMemoryEXT(MemorySegment device, MemorySegment pCopyImageToMemoryInfo) {
        var mh$ = vkCopyImageToMemoryEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCopyImageToMemoryEXT", device, pCopyImageToMemoryInfo);
            }
            return (int)mh$.invokeExact(device, pCopyImageToMemoryInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCopyImageToImageEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCopyImageToImageEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkCopyImageToImageEXT(VkDevice device, const VkCopyImageToImageInfoEXT *pCopyImageToImageInfo)
     * }
     */
    public static FunctionDescriptor vkCopyImageToImageEXT$descriptor() {
        return vkCopyImageToImageEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkCopyImageToImageEXT(VkDevice device, const VkCopyImageToImageInfoEXT *pCopyImageToImageInfo)
     * }
     */
    public static MethodHandle vkCopyImageToImageEXT$handle() {
        return vkCopyImageToImageEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * VkResult vkCopyImageToImageEXT(VkDevice device, const VkCopyImageToImageInfoEXT *pCopyImageToImageInfo)
     * }
     */
    public static int vkCopyImageToImageEXT(MemorySegment device, MemorySegment pCopyImageToImageInfo) {
        var mh$ = vkCopyImageToImageEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCopyImageToImageEXT", device, pCopyImageToImageInfo);
            }
            return (int)mh$.invokeExact(device, pCopyImageToImageInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkTransitionImageLayoutEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkTransitionImageLayoutEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkTransitionImageLayoutEXT(VkDevice device, uint32_t transitionCount, const VkHostImageLayoutTransitionInfoEXT *pTransitions)
     * }
     */
    public static FunctionDescriptor vkTransitionImageLayoutEXT$descriptor() {
        return vkTransitionImageLayoutEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkTransitionImageLayoutEXT(VkDevice device, uint32_t transitionCount, const VkHostImageLayoutTransitionInfoEXT *pTransitions)
     * }
     */
    public static MethodHandle vkTransitionImageLayoutEXT$handle() {
        return vkTransitionImageLayoutEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * VkResult vkTransitionImageLayoutEXT(VkDevice device, uint32_t transitionCount, const VkHostImageLayoutTransitionInfoEXT *pTransitions)
     * }
     */
    public static int vkTransitionImageLayoutEXT(MemorySegment device, int transitionCount, MemorySegment pTransitions) {
        var mh$ = vkTransitionImageLayoutEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkTransitionImageLayoutEXT", device, transitionCount, pTransitions);
            }
            return (int)mh$.invokeExact(device, transitionCount, pTransitions);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetImageSubresourceLayout2EXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkGetImageSubresourceLayout2EXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkGetImageSubresourceLayout2EXT(VkDevice device, VkImage image, const VkImageSubresource2KHR *pSubresource, VkSubresourceLayout2KHR *pLayout)
     * }
     */
    public static FunctionDescriptor vkGetImageSubresourceLayout2EXT$descriptor() {
        return vkGetImageSubresourceLayout2EXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkGetImageSubresourceLayout2EXT(VkDevice device, VkImage image, const VkImageSubresource2KHR *pSubresource, VkSubresourceLayout2KHR *pLayout)
     * }
     */
    public static MethodHandle vkGetImageSubresourceLayout2EXT$handle() {
        return vkGetImageSubresourceLayout2EXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkGetImageSubresourceLayout2EXT(VkDevice device, VkImage image, const VkImageSubresource2KHR *pSubresource, VkSubresourceLayout2KHR *pLayout)
     * }
     */
    public static void vkGetImageSubresourceLayout2EXT(MemorySegment device, MemorySegment image, MemorySegment pSubresource, MemorySegment pLayout) {
        var mh$ = vkGetImageSubresourceLayout2EXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetImageSubresourceLayout2EXT", device, image, pSubresource, pLayout);
            }
            mh$.invokeExact(device, image, pSubresource, pLayout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int VK_PRESENT_SCALING_ONE_TO_ONE_BIT_EXT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkPresentScalingFlagBitsEXT.VK_PRESENT_SCALING_ONE_TO_ONE_BIT_EXT = 1
     * }
     */
    public static int VK_PRESENT_SCALING_ONE_TO_ONE_BIT_EXT() {
        return VK_PRESENT_SCALING_ONE_TO_ONE_BIT_EXT;
    }
    private static final int VK_PRESENT_SCALING_ASPECT_RATIO_STRETCH_BIT_EXT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkPresentScalingFlagBitsEXT.VK_PRESENT_SCALING_ASPECT_RATIO_STRETCH_BIT_EXT = 2
     * }
     */
    public static int VK_PRESENT_SCALING_ASPECT_RATIO_STRETCH_BIT_EXT() {
        return VK_PRESENT_SCALING_ASPECT_RATIO_STRETCH_BIT_EXT;
    }
    private static final int VK_PRESENT_SCALING_STRETCH_BIT_EXT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkPresentScalingFlagBitsEXT.VK_PRESENT_SCALING_STRETCH_BIT_EXT = 4
     * }
     */
    public static int VK_PRESENT_SCALING_STRETCH_BIT_EXT() {
        return VK_PRESENT_SCALING_STRETCH_BIT_EXT;
    }
    private static final int VK_PRESENT_SCALING_FLAG_BITS_MAX_ENUM_EXT = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkPresentScalingFlagBitsEXT.VK_PRESENT_SCALING_FLAG_BITS_MAX_ENUM_EXT = 2147483647
     * }
     */
    public static int VK_PRESENT_SCALING_FLAG_BITS_MAX_ENUM_EXT() {
        return VK_PRESENT_SCALING_FLAG_BITS_MAX_ENUM_EXT;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkPresentScalingFlagsEXT
     * }
     */
    public static final OfInt VkPresentScalingFlagsEXT = vulkan_h.C_INT;
    private static final int VK_PRESENT_GRAVITY_MIN_BIT_EXT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkPresentGravityFlagBitsEXT.VK_PRESENT_GRAVITY_MIN_BIT_EXT = 1
     * }
     */
    public static int VK_PRESENT_GRAVITY_MIN_BIT_EXT() {
        return VK_PRESENT_GRAVITY_MIN_BIT_EXT;
    }
    private static final int VK_PRESENT_GRAVITY_MAX_BIT_EXT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkPresentGravityFlagBitsEXT.VK_PRESENT_GRAVITY_MAX_BIT_EXT = 2
     * }
     */
    public static int VK_PRESENT_GRAVITY_MAX_BIT_EXT() {
        return VK_PRESENT_GRAVITY_MAX_BIT_EXT;
    }
    private static final int VK_PRESENT_GRAVITY_CENTERED_BIT_EXT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkPresentGravityFlagBitsEXT.VK_PRESENT_GRAVITY_CENTERED_BIT_EXT = 4
     * }
     */
    public static int VK_PRESENT_GRAVITY_CENTERED_BIT_EXT() {
        return VK_PRESENT_GRAVITY_CENTERED_BIT_EXT;
    }
    private static final int VK_PRESENT_GRAVITY_FLAG_BITS_MAX_ENUM_EXT = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkPresentGravityFlagBitsEXT.VK_PRESENT_GRAVITY_FLAG_BITS_MAX_ENUM_EXT = 2147483647
     * }
     */
    public static int VK_PRESENT_GRAVITY_FLAG_BITS_MAX_ENUM_EXT() {
        return VK_PRESENT_GRAVITY_FLAG_BITS_MAX_ENUM_EXT;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkPresentGravityFlagsEXT
     * }
     */
    public static final OfInt VkPresentGravityFlagsEXT = vulkan_h.C_INT;

    private static class vkReleaseSwapchainImagesEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkReleaseSwapchainImagesEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkReleaseSwapchainImagesEXT(VkDevice device, const VkReleaseSwapchainImagesInfoEXT *pReleaseInfo)
     * }
     */
    public static FunctionDescriptor vkReleaseSwapchainImagesEXT$descriptor() {
        return vkReleaseSwapchainImagesEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkReleaseSwapchainImagesEXT(VkDevice device, const VkReleaseSwapchainImagesInfoEXT *pReleaseInfo)
     * }
     */
    public static MethodHandle vkReleaseSwapchainImagesEXT$handle() {
        return vkReleaseSwapchainImagesEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * VkResult vkReleaseSwapchainImagesEXT(VkDevice device, const VkReleaseSwapchainImagesInfoEXT *pReleaseInfo)
     * }
     */
    public static int vkReleaseSwapchainImagesEXT(MemorySegment device, MemorySegment pReleaseInfo) {
        var mh$ = vkReleaseSwapchainImagesEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkReleaseSwapchainImagesEXT", device, pReleaseInfo);
            }
            return (int)mh$.invokeExact(device, pReleaseInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct VkIndirectCommandsLayoutNV_T *VkIndirectCommandsLayoutNV
     * }
     */
    public static final AddressLayout VkIndirectCommandsLayoutNV = vulkan_h.C_POINTER;
    private static final int VK_INDIRECT_COMMANDS_TOKEN_TYPE_SHADER_GROUP_NV = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkIndirectCommandsTokenTypeNV.VK_INDIRECT_COMMANDS_TOKEN_TYPE_SHADER_GROUP_NV = 0
     * }
     */
    public static int VK_INDIRECT_COMMANDS_TOKEN_TYPE_SHADER_GROUP_NV() {
        return VK_INDIRECT_COMMANDS_TOKEN_TYPE_SHADER_GROUP_NV;
    }
    private static final int VK_INDIRECT_COMMANDS_TOKEN_TYPE_STATE_FLAGS_NV = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkIndirectCommandsTokenTypeNV.VK_INDIRECT_COMMANDS_TOKEN_TYPE_STATE_FLAGS_NV = 1
     * }
     */
    public static int VK_INDIRECT_COMMANDS_TOKEN_TYPE_STATE_FLAGS_NV() {
        return VK_INDIRECT_COMMANDS_TOKEN_TYPE_STATE_FLAGS_NV;
    }
    private static final int VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NV = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkIndirectCommandsTokenTypeNV.VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NV = 2
     * }
     */
    public static int VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NV() {
        return VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NV;
    }
    private static final int VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NV = (int)3L;
    /**
     * {@snippet lang=c :
     * enum VkIndirectCommandsTokenTypeNV.VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NV = 3
     * }
     */
    public static int VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NV() {
        return VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NV;
    }
    private static final int VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkIndirectCommandsTokenTypeNV.VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV = 4
     * }
     */
    public static int VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV() {
        return VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV;
    }
    private static final int VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NV = (int)5L;
    /**
     * {@snippet lang=c :
     * enum VkIndirectCommandsTokenTypeNV.VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NV = 5
     * }
     */
    public static int VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NV() {
        return VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NV;
    }
    private static final int VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NV = (int)6L;
    /**
     * {@snippet lang=c :
     * enum VkIndirectCommandsTokenTypeNV.VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NV = 6
     * }
     */
    public static int VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NV() {
        return VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NV;
    }
    private static final int VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_TASKS_NV = (int)7L;
    /**
     * {@snippet lang=c :
     * enum VkIndirectCommandsTokenTypeNV.VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_TASKS_NV = 7
     * }
     */
    public static int VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_TASKS_NV() {
        return VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_TASKS_NV;
    }
    private static final int VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_NV = (int)1000328000L;
    /**
     * {@snippet lang=c :
     * enum VkIndirectCommandsTokenTypeNV.VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_NV = 1000328000
     * }
     */
    public static int VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_NV() {
        return VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_NV;
    }
    private static final int VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NV = (int)1000428003L;
    /**
     * {@snippet lang=c :
     * enum VkIndirectCommandsTokenTypeNV.VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NV = 1000428003
     * }
     */
    public static int VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NV() {
        return VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NV;
    }
    private static final int VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NV = (int)1000428004L;
    /**
     * {@snippet lang=c :
     * enum VkIndirectCommandsTokenTypeNV.VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NV = 1000428004
     * }
     */
    public static int VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NV() {
        return VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NV;
    }
    private static final int VK_INDIRECT_COMMANDS_TOKEN_TYPE_MAX_ENUM_NV = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkIndirectCommandsTokenTypeNV.VK_INDIRECT_COMMANDS_TOKEN_TYPE_MAX_ENUM_NV = 2147483647
     * }
     */
    public static int VK_INDIRECT_COMMANDS_TOKEN_TYPE_MAX_ENUM_NV() {
        return VK_INDIRECT_COMMANDS_TOKEN_TYPE_MAX_ENUM_NV;
    }
    private static final int VK_INDIRECT_STATE_FLAG_FRONTFACE_BIT_NV = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkIndirectStateFlagBitsNV.VK_INDIRECT_STATE_FLAG_FRONTFACE_BIT_NV = 1
     * }
     */
    public static int VK_INDIRECT_STATE_FLAG_FRONTFACE_BIT_NV() {
        return VK_INDIRECT_STATE_FLAG_FRONTFACE_BIT_NV;
    }
    private static final int VK_INDIRECT_STATE_FLAG_BITS_MAX_ENUM_NV = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkIndirectStateFlagBitsNV.VK_INDIRECT_STATE_FLAG_BITS_MAX_ENUM_NV = 2147483647
     * }
     */
    public static int VK_INDIRECT_STATE_FLAG_BITS_MAX_ENUM_NV() {
        return VK_INDIRECT_STATE_FLAG_BITS_MAX_ENUM_NV;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkIndirectStateFlagsNV
     * }
     */
    public static final OfInt VkIndirectStateFlagsNV = vulkan_h.C_INT;
    private static final int VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_NV = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkIndirectCommandsLayoutUsageFlagBitsNV.VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_NV = 1
     * }
     */
    public static int VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_NV() {
        return VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_NV;
    }
    private static final int VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NV = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkIndirectCommandsLayoutUsageFlagBitsNV.VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NV = 2
     * }
     */
    public static int VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NV() {
        return VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NV;
    }
    private static final int VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NV = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkIndirectCommandsLayoutUsageFlagBitsNV.VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NV = 4
     * }
     */
    public static int VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NV() {
        return VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NV;
    }
    private static final int VK_INDIRECT_COMMANDS_LAYOUT_USAGE_FLAG_BITS_MAX_ENUM_NV = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkIndirectCommandsLayoutUsageFlagBitsNV.VK_INDIRECT_COMMANDS_LAYOUT_USAGE_FLAG_BITS_MAX_ENUM_NV = 2147483647
     * }
     */
    public static int VK_INDIRECT_COMMANDS_LAYOUT_USAGE_FLAG_BITS_MAX_ENUM_NV() {
        return VK_INDIRECT_COMMANDS_LAYOUT_USAGE_FLAG_BITS_MAX_ENUM_NV;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkIndirectCommandsLayoutUsageFlagsNV
     * }
     */
    public static final OfInt VkIndirectCommandsLayoutUsageFlagsNV = vulkan_h.C_INT;

    private static class vkGetGeneratedCommandsMemoryRequirementsNV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkGetGeneratedCommandsMemoryRequirementsNV"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkGetGeneratedCommandsMemoryRequirementsNV(VkDevice device, const VkGeneratedCommandsMemoryRequirementsInfoNV *pInfo, VkMemoryRequirements2 *pMemoryRequirements)
     * }
     */
    public static FunctionDescriptor vkGetGeneratedCommandsMemoryRequirementsNV$descriptor() {
        return vkGetGeneratedCommandsMemoryRequirementsNV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkGetGeneratedCommandsMemoryRequirementsNV(VkDevice device, const VkGeneratedCommandsMemoryRequirementsInfoNV *pInfo, VkMemoryRequirements2 *pMemoryRequirements)
     * }
     */
    public static MethodHandle vkGetGeneratedCommandsMemoryRequirementsNV$handle() {
        return vkGetGeneratedCommandsMemoryRequirementsNV.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkGetGeneratedCommandsMemoryRequirementsNV(VkDevice device, const VkGeneratedCommandsMemoryRequirementsInfoNV *pInfo, VkMemoryRequirements2 *pMemoryRequirements)
     * }
     */
    public static void vkGetGeneratedCommandsMemoryRequirementsNV(MemorySegment device, MemorySegment pInfo, MemorySegment pMemoryRequirements) {
        var mh$ = vkGetGeneratedCommandsMemoryRequirementsNV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetGeneratedCommandsMemoryRequirementsNV", device, pInfo, pMemoryRequirements);
            }
            mh$.invokeExact(device, pInfo, pMemoryRequirements);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdPreprocessGeneratedCommandsNV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdPreprocessGeneratedCommandsNV"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdPreprocessGeneratedCommandsNV(VkCommandBuffer commandBuffer, const VkGeneratedCommandsInfoNV *pGeneratedCommandsInfo)
     * }
     */
    public static FunctionDescriptor vkCmdPreprocessGeneratedCommandsNV$descriptor() {
        return vkCmdPreprocessGeneratedCommandsNV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdPreprocessGeneratedCommandsNV(VkCommandBuffer commandBuffer, const VkGeneratedCommandsInfoNV *pGeneratedCommandsInfo)
     * }
     */
    public static MethodHandle vkCmdPreprocessGeneratedCommandsNV$handle() {
        return vkCmdPreprocessGeneratedCommandsNV.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdPreprocessGeneratedCommandsNV(VkCommandBuffer commandBuffer, const VkGeneratedCommandsInfoNV *pGeneratedCommandsInfo)
     * }
     */
    public static void vkCmdPreprocessGeneratedCommandsNV(MemorySegment commandBuffer, MemorySegment pGeneratedCommandsInfo) {
        var mh$ = vkCmdPreprocessGeneratedCommandsNV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdPreprocessGeneratedCommandsNV", commandBuffer, pGeneratedCommandsInfo);
            }
            mh$.invokeExact(commandBuffer, pGeneratedCommandsInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdExecuteGeneratedCommandsNV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdExecuteGeneratedCommandsNV"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdExecuteGeneratedCommandsNV(VkCommandBuffer commandBuffer, VkBool32 isPreprocessed, const VkGeneratedCommandsInfoNV *pGeneratedCommandsInfo)
     * }
     */
    public static FunctionDescriptor vkCmdExecuteGeneratedCommandsNV$descriptor() {
        return vkCmdExecuteGeneratedCommandsNV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdExecuteGeneratedCommandsNV(VkCommandBuffer commandBuffer, VkBool32 isPreprocessed, const VkGeneratedCommandsInfoNV *pGeneratedCommandsInfo)
     * }
     */
    public static MethodHandle vkCmdExecuteGeneratedCommandsNV$handle() {
        return vkCmdExecuteGeneratedCommandsNV.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdExecuteGeneratedCommandsNV(VkCommandBuffer commandBuffer, VkBool32 isPreprocessed, const VkGeneratedCommandsInfoNV *pGeneratedCommandsInfo)
     * }
     */
    public static void vkCmdExecuteGeneratedCommandsNV(MemorySegment commandBuffer, int isPreprocessed, MemorySegment pGeneratedCommandsInfo) {
        var mh$ = vkCmdExecuteGeneratedCommandsNV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdExecuteGeneratedCommandsNV", commandBuffer, isPreprocessed, pGeneratedCommandsInfo);
            }
            mh$.invokeExact(commandBuffer, isPreprocessed, pGeneratedCommandsInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdBindPipelineShaderGroupNV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdBindPipelineShaderGroupNV"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdBindPipelineShaderGroupNV(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline, uint32_t groupIndex)
     * }
     */
    public static FunctionDescriptor vkCmdBindPipelineShaderGroupNV$descriptor() {
        return vkCmdBindPipelineShaderGroupNV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdBindPipelineShaderGroupNV(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline, uint32_t groupIndex)
     * }
     */
    public static MethodHandle vkCmdBindPipelineShaderGroupNV$handle() {
        return vkCmdBindPipelineShaderGroupNV.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdBindPipelineShaderGroupNV(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline, uint32_t groupIndex)
     * }
     */
    public static void vkCmdBindPipelineShaderGroupNV(MemorySegment commandBuffer, int pipelineBindPoint, MemorySegment pipeline, int groupIndex) {
        var mh$ = vkCmdBindPipelineShaderGroupNV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdBindPipelineShaderGroupNV", commandBuffer, pipelineBindPoint, pipeline, groupIndex);
            }
            mh$.invokeExact(commandBuffer, pipelineBindPoint, pipeline, groupIndex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCreateIndirectCommandsLayoutNV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCreateIndirectCommandsLayoutNV"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkCreateIndirectCommandsLayoutNV(VkDevice device, const VkIndirectCommandsLayoutCreateInfoNV *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkIndirectCommandsLayoutNV *pIndirectCommandsLayout)
     * }
     */
    public static FunctionDescriptor vkCreateIndirectCommandsLayoutNV$descriptor() {
        return vkCreateIndirectCommandsLayoutNV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkCreateIndirectCommandsLayoutNV(VkDevice device, const VkIndirectCommandsLayoutCreateInfoNV *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkIndirectCommandsLayoutNV *pIndirectCommandsLayout)
     * }
     */
    public static MethodHandle vkCreateIndirectCommandsLayoutNV$handle() {
        return vkCreateIndirectCommandsLayoutNV.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * VkResult vkCreateIndirectCommandsLayoutNV(VkDevice device, const VkIndirectCommandsLayoutCreateInfoNV *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkIndirectCommandsLayoutNV *pIndirectCommandsLayout)
     * }
     */
    public static int vkCreateIndirectCommandsLayoutNV(MemorySegment device, MemorySegment pCreateInfo, MemorySegment pAllocator, MemorySegment pIndirectCommandsLayout) {
        var mh$ = vkCreateIndirectCommandsLayoutNV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCreateIndirectCommandsLayoutNV", device, pCreateInfo, pAllocator, pIndirectCommandsLayout);
            }
            return (int)mh$.invokeExact(device, pCreateInfo, pAllocator, pIndirectCommandsLayout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkDestroyIndirectCommandsLayoutNV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkDestroyIndirectCommandsLayoutNV"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkDestroyIndirectCommandsLayoutNV(VkDevice device, VkIndirectCommandsLayoutNV indirectCommandsLayout, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static FunctionDescriptor vkDestroyIndirectCommandsLayoutNV$descriptor() {
        return vkDestroyIndirectCommandsLayoutNV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkDestroyIndirectCommandsLayoutNV(VkDevice device, VkIndirectCommandsLayoutNV indirectCommandsLayout, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static MethodHandle vkDestroyIndirectCommandsLayoutNV$handle() {
        return vkDestroyIndirectCommandsLayoutNV.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkDestroyIndirectCommandsLayoutNV(VkDevice device, VkIndirectCommandsLayoutNV indirectCommandsLayout, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static void vkDestroyIndirectCommandsLayoutNV(MemorySegment device, MemorySegment indirectCommandsLayout, MemorySegment pAllocator) {
        var mh$ = vkDestroyIndirectCommandsLayoutNV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkDestroyIndirectCommandsLayoutNV", device, indirectCommandsLayout, pAllocator);
            }
            mh$.invokeExact(device, indirectCommandsLayout, pAllocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int VK_DEPTH_BIAS_REPRESENTATION_LEAST_REPRESENTABLE_VALUE_FORMAT_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkDepthBiasRepresentationEXT.VK_DEPTH_BIAS_REPRESENTATION_LEAST_REPRESENTABLE_VALUE_FORMAT_EXT = 0
     * }
     */
    public static int VK_DEPTH_BIAS_REPRESENTATION_LEAST_REPRESENTABLE_VALUE_FORMAT_EXT() {
        return VK_DEPTH_BIAS_REPRESENTATION_LEAST_REPRESENTABLE_VALUE_FORMAT_EXT;
    }
    private static final int VK_DEPTH_BIAS_REPRESENTATION_LEAST_REPRESENTABLE_VALUE_FORCE_UNORM_EXT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkDepthBiasRepresentationEXT.VK_DEPTH_BIAS_REPRESENTATION_LEAST_REPRESENTABLE_VALUE_FORCE_UNORM_EXT = 1
     * }
     */
    public static int VK_DEPTH_BIAS_REPRESENTATION_LEAST_REPRESENTABLE_VALUE_FORCE_UNORM_EXT() {
        return VK_DEPTH_BIAS_REPRESENTATION_LEAST_REPRESENTABLE_VALUE_FORCE_UNORM_EXT;
    }
    private static final int VK_DEPTH_BIAS_REPRESENTATION_FLOAT_EXT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkDepthBiasRepresentationEXT.VK_DEPTH_BIAS_REPRESENTATION_FLOAT_EXT = 2
     * }
     */
    public static int VK_DEPTH_BIAS_REPRESENTATION_FLOAT_EXT() {
        return VK_DEPTH_BIAS_REPRESENTATION_FLOAT_EXT;
    }
    private static final int VK_DEPTH_BIAS_REPRESENTATION_MAX_ENUM_EXT = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkDepthBiasRepresentationEXT.VK_DEPTH_BIAS_REPRESENTATION_MAX_ENUM_EXT = 2147483647
     * }
     */
    public static int VK_DEPTH_BIAS_REPRESENTATION_MAX_ENUM_EXT() {
        return VK_DEPTH_BIAS_REPRESENTATION_MAX_ENUM_EXT;
    }

    private static class vkCmdSetDepthBias2EXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdSetDepthBias2EXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdSetDepthBias2EXT(VkCommandBuffer commandBuffer, const VkDepthBiasInfoEXT *pDepthBiasInfo)
     * }
     */
    public static FunctionDescriptor vkCmdSetDepthBias2EXT$descriptor() {
        return vkCmdSetDepthBias2EXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdSetDepthBias2EXT(VkCommandBuffer commandBuffer, const VkDepthBiasInfoEXT *pDepthBiasInfo)
     * }
     */
    public static MethodHandle vkCmdSetDepthBias2EXT$handle() {
        return vkCmdSetDepthBias2EXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdSetDepthBias2EXT(VkCommandBuffer commandBuffer, const VkDepthBiasInfoEXT *pDepthBiasInfo)
     * }
     */
    public static void vkCmdSetDepthBias2EXT(MemorySegment commandBuffer, MemorySegment pDepthBiasInfo) {
        var mh$ = vkCmdSetDepthBias2EXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetDepthBias2EXT", commandBuffer, pDepthBiasInfo);
            }
            mh$.invokeExact(commandBuffer, pDepthBiasInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATE_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkDeviceMemoryReportEventTypeEXT.VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATE_EXT = 0
     * }
     */
    public static int VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATE_EXT() {
        return VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATE_EXT;
    }
    private static final int VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_FREE_EXT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkDeviceMemoryReportEventTypeEXT.VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_FREE_EXT = 1
     * }
     */
    public static int VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_FREE_EXT() {
        return VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_FREE_EXT;
    }
    private static final int VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_IMPORT_EXT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkDeviceMemoryReportEventTypeEXT.VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_IMPORT_EXT = 2
     * }
     */
    public static int VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_IMPORT_EXT() {
        return VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_IMPORT_EXT;
    }
    private static final int VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_UNIMPORT_EXT = (int)3L;
    /**
     * {@snippet lang=c :
     * enum VkDeviceMemoryReportEventTypeEXT.VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_UNIMPORT_EXT = 3
     * }
     */
    public static int VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_UNIMPORT_EXT() {
        return VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_UNIMPORT_EXT;
    }
    private static final int VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATION_FAILED_EXT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkDeviceMemoryReportEventTypeEXT.VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATION_FAILED_EXT = 4
     * }
     */
    public static int VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATION_FAILED_EXT() {
        return VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATION_FAILED_EXT;
    }
    private static final int VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_MAX_ENUM_EXT = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkDeviceMemoryReportEventTypeEXT.VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_MAX_ENUM_EXT = 2147483647
     * }
     */
    public static int VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_MAX_ENUM_EXT() {
        return VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_MAX_ENUM_EXT;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkDeviceMemoryReportFlagsEXT
     * }
     */
    public static final OfInt VkDeviceMemoryReportFlagsEXT = vulkan_h.C_INT;

    private static class vkAcquireDrmDisplayEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkAcquireDrmDisplayEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkAcquireDrmDisplayEXT(VkPhysicalDevice physicalDevice, int32_t drmFd, VkDisplayKHR display)
     * }
     */
    public static FunctionDescriptor vkAcquireDrmDisplayEXT$descriptor() {
        return vkAcquireDrmDisplayEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkAcquireDrmDisplayEXT(VkPhysicalDevice physicalDevice, int32_t drmFd, VkDisplayKHR display)
     * }
     */
    public static MethodHandle vkAcquireDrmDisplayEXT$handle() {
        return vkAcquireDrmDisplayEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * VkResult vkAcquireDrmDisplayEXT(VkPhysicalDevice physicalDevice, int32_t drmFd, VkDisplayKHR display)
     * }
     */
    public static int vkAcquireDrmDisplayEXT(MemorySegment physicalDevice, int drmFd, MemorySegment display) {
        var mh$ = vkAcquireDrmDisplayEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkAcquireDrmDisplayEXT", physicalDevice, drmFd, display);
            }
            return (int)mh$.invokeExact(physicalDevice, drmFd, display);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetDrmDisplayEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkGetDrmDisplayEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkGetDrmDisplayEXT(VkPhysicalDevice physicalDevice, int32_t drmFd, uint32_t connectorId, VkDisplayKHR *display)
     * }
     */
    public static FunctionDescriptor vkGetDrmDisplayEXT$descriptor() {
        return vkGetDrmDisplayEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkGetDrmDisplayEXT(VkPhysicalDevice physicalDevice, int32_t drmFd, uint32_t connectorId, VkDisplayKHR *display)
     * }
     */
    public static MethodHandle vkGetDrmDisplayEXT$handle() {
        return vkGetDrmDisplayEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * VkResult vkGetDrmDisplayEXT(VkPhysicalDevice physicalDevice, int32_t drmFd, uint32_t connectorId, VkDisplayKHR *display)
     * }
     */
    public static int vkGetDrmDisplayEXT(MemorySegment physicalDevice, int drmFd, int connectorId, MemorySegment display) {
        var mh$ = vkGetDrmDisplayEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetDrmDisplayEXT", physicalDevice, drmFd, connectorId, display);
            }
            return (int)mh$.invokeExact(physicalDevice, drmFd, connectorId, display);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef VkPrivateDataSlot VkPrivateDataSlotEXT
     * }
     */
    public static final AddressLayout VkPrivateDataSlotEXT = vulkan_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef VkPrivateDataSlotCreateFlags VkPrivateDataSlotCreateFlagsEXT
     * }
     */
    public static final OfInt VkPrivateDataSlotCreateFlagsEXT = vulkan_h.C_INT;

    private static class vkCreatePrivateDataSlotEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCreatePrivateDataSlotEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkCreatePrivateDataSlotEXT(VkDevice device, const VkPrivateDataSlotCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkPrivateDataSlot *pPrivateDataSlot)
     * }
     */
    public static FunctionDescriptor vkCreatePrivateDataSlotEXT$descriptor() {
        return vkCreatePrivateDataSlotEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkCreatePrivateDataSlotEXT(VkDevice device, const VkPrivateDataSlotCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkPrivateDataSlot *pPrivateDataSlot)
     * }
     */
    public static MethodHandle vkCreatePrivateDataSlotEXT$handle() {
        return vkCreatePrivateDataSlotEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * VkResult vkCreatePrivateDataSlotEXT(VkDevice device, const VkPrivateDataSlotCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkPrivateDataSlot *pPrivateDataSlot)
     * }
     */
    public static int vkCreatePrivateDataSlotEXT(MemorySegment device, MemorySegment pCreateInfo, MemorySegment pAllocator, MemorySegment pPrivateDataSlot) {
        var mh$ = vkCreatePrivateDataSlotEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCreatePrivateDataSlotEXT", device, pCreateInfo, pAllocator, pPrivateDataSlot);
            }
            return (int)mh$.invokeExact(device, pCreateInfo, pAllocator, pPrivateDataSlot);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkDestroyPrivateDataSlotEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkDestroyPrivateDataSlotEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkDestroyPrivateDataSlotEXT(VkDevice device, VkPrivateDataSlot privateDataSlot, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static FunctionDescriptor vkDestroyPrivateDataSlotEXT$descriptor() {
        return vkDestroyPrivateDataSlotEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkDestroyPrivateDataSlotEXT(VkDevice device, VkPrivateDataSlot privateDataSlot, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static MethodHandle vkDestroyPrivateDataSlotEXT$handle() {
        return vkDestroyPrivateDataSlotEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkDestroyPrivateDataSlotEXT(VkDevice device, VkPrivateDataSlot privateDataSlot, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static void vkDestroyPrivateDataSlotEXT(MemorySegment device, MemorySegment privateDataSlot, MemorySegment pAllocator) {
        var mh$ = vkDestroyPrivateDataSlotEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkDestroyPrivateDataSlotEXT", device, privateDataSlot, pAllocator);
            }
            mh$.invokeExact(device, privateDataSlot, pAllocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkSetPrivateDataEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_LONG_LONG,
            vulkan_h.C_POINTER,
            vulkan_h.C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkSetPrivateDataEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkSetPrivateDataEXT(VkDevice device, VkObjectType objectType, uint64_t objectHandle, VkPrivateDataSlot privateDataSlot, uint64_t data)
     * }
     */
    public static FunctionDescriptor vkSetPrivateDataEXT$descriptor() {
        return vkSetPrivateDataEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkSetPrivateDataEXT(VkDevice device, VkObjectType objectType, uint64_t objectHandle, VkPrivateDataSlot privateDataSlot, uint64_t data)
     * }
     */
    public static MethodHandle vkSetPrivateDataEXT$handle() {
        return vkSetPrivateDataEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * VkResult vkSetPrivateDataEXT(VkDevice device, VkObjectType objectType, uint64_t objectHandle, VkPrivateDataSlot privateDataSlot, uint64_t data)
     * }
     */
    public static int vkSetPrivateDataEXT(MemorySegment device, int objectType, long objectHandle, MemorySegment privateDataSlot, long data) {
        var mh$ = vkSetPrivateDataEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkSetPrivateDataEXT", device, objectType, objectHandle, privateDataSlot, data);
            }
            return (int)mh$.invokeExact(device, objectType, objectHandle, privateDataSlot, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetPrivateDataEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_LONG_LONG,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkGetPrivateDataEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkGetPrivateDataEXT(VkDevice device, VkObjectType objectType, uint64_t objectHandle, VkPrivateDataSlot privateDataSlot, uint64_t *pData)
     * }
     */
    public static FunctionDescriptor vkGetPrivateDataEXT$descriptor() {
        return vkGetPrivateDataEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkGetPrivateDataEXT(VkDevice device, VkObjectType objectType, uint64_t objectHandle, VkPrivateDataSlot privateDataSlot, uint64_t *pData)
     * }
     */
    public static MethodHandle vkGetPrivateDataEXT$handle() {
        return vkGetPrivateDataEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkGetPrivateDataEXT(VkDevice device, VkObjectType objectType, uint64_t objectHandle, VkPrivateDataSlot privateDataSlot, uint64_t *pData)
     * }
     */
    public static void vkGetPrivateDataEXT(MemorySegment device, int objectType, long objectHandle, MemorySegment privateDataSlot, MemorySegment pData) {
        var mh$ = vkGetPrivateDataEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetPrivateDataEXT", device, objectType, objectHandle, privateDataSlot, pData);
            }
            mh$.invokeExact(device, objectType, objectHandle, privateDataSlot, pData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_DEBUG_INFO_BIT_NV = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkDeviceDiagnosticsConfigFlagBitsNV.VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_DEBUG_INFO_BIT_NV = 1
     * }
     */
    public static int VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_DEBUG_INFO_BIT_NV() {
        return VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_DEBUG_INFO_BIT_NV;
    }
    private static final int VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_RESOURCE_TRACKING_BIT_NV = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkDeviceDiagnosticsConfigFlagBitsNV.VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_RESOURCE_TRACKING_BIT_NV = 2
     * }
     */
    public static int VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_RESOURCE_TRACKING_BIT_NV() {
        return VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_RESOURCE_TRACKING_BIT_NV;
    }
    private static final int VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_AUTOMATIC_CHECKPOINTS_BIT_NV = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkDeviceDiagnosticsConfigFlagBitsNV.VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_AUTOMATIC_CHECKPOINTS_BIT_NV = 4
     * }
     */
    public static int VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_AUTOMATIC_CHECKPOINTS_BIT_NV() {
        return VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_AUTOMATIC_CHECKPOINTS_BIT_NV;
    }
    private static final int VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_ERROR_REPORTING_BIT_NV = (int)8L;
    /**
     * {@snippet lang=c :
     * enum VkDeviceDiagnosticsConfigFlagBitsNV.VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_ERROR_REPORTING_BIT_NV = 8
     * }
     */
    public static int VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_ERROR_REPORTING_BIT_NV() {
        return VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_ERROR_REPORTING_BIT_NV;
    }
    private static final int VK_DEVICE_DIAGNOSTICS_CONFIG_FLAG_BITS_MAX_ENUM_NV = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkDeviceDiagnosticsConfigFlagBitsNV.VK_DEVICE_DIAGNOSTICS_CONFIG_FLAG_BITS_MAX_ENUM_NV = 2147483647
     * }
     */
    public static int VK_DEVICE_DIAGNOSTICS_CONFIG_FLAG_BITS_MAX_ENUM_NV() {
        return VK_DEVICE_DIAGNOSTICS_CONFIG_FLAG_BITS_MAX_ENUM_NV;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkDeviceDiagnosticsConfigFlagsNV
     * }
     */
    public static final OfInt VkDeviceDiagnosticsConfigFlagsNV = vulkan_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef struct VkCudaModuleNV_T *VkCudaModuleNV
     * }
     */
    public static final AddressLayout VkCudaModuleNV = vulkan_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct VkCudaFunctionNV_T *VkCudaFunctionNV
     * }
     */
    public static final AddressLayout VkCudaFunctionNV = vulkan_h.C_POINTER;

    private static class vkCreateCudaModuleNV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCreateCudaModuleNV"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkCreateCudaModuleNV(VkDevice device, const VkCudaModuleCreateInfoNV *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkCudaModuleNV *pModule)
     * }
     */
    public static FunctionDescriptor vkCreateCudaModuleNV$descriptor() {
        return vkCreateCudaModuleNV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkCreateCudaModuleNV(VkDevice device, const VkCudaModuleCreateInfoNV *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkCudaModuleNV *pModule)
     * }
     */
    public static MethodHandle vkCreateCudaModuleNV$handle() {
        return vkCreateCudaModuleNV.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * VkResult vkCreateCudaModuleNV(VkDevice device, const VkCudaModuleCreateInfoNV *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkCudaModuleNV *pModule)
     * }
     */
    public static int vkCreateCudaModuleNV(MemorySegment device, MemorySegment pCreateInfo, MemorySegment pAllocator, MemorySegment pModule) {
        var mh$ = vkCreateCudaModuleNV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCreateCudaModuleNV", device, pCreateInfo, pAllocator, pModule);
            }
            return (int)mh$.invokeExact(device, pCreateInfo, pAllocator, pModule);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetCudaModuleCacheNV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkGetCudaModuleCacheNV"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkGetCudaModuleCacheNV(VkDevice device, VkCudaModuleNV module, size_t *pCacheSize, void *pCacheData)
     * }
     */
    public static FunctionDescriptor vkGetCudaModuleCacheNV$descriptor() {
        return vkGetCudaModuleCacheNV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkGetCudaModuleCacheNV(VkDevice device, VkCudaModuleNV module, size_t *pCacheSize, void *pCacheData)
     * }
     */
    public static MethodHandle vkGetCudaModuleCacheNV$handle() {
        return vkGetCudaModuleCacheNV.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * VkResult vkGetCudaModuleCacheNV(VkDevice device, VkCudaModuleNV module, size_t *pCacheSize, void *pCacheData)
     * }
     */
    public static int vkGetCudaModuleCacheNV(MemorySegment device, MemorySegment module, MemorySegment pCacheSize, MemorySegment pCacheData) {
        var mh$ = vkGetCudaModuleCacheNV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetCudaModuleCacheNV", device, module, pCacheSize, pCacheData);
            }
            return (int)mh$.invokeExact(device, module, pCacheSize, pCacheData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCreateCudaFunctionNV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCreateCudaFunctionNV"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkCreateCudaFunctionNV(VkDevice device, const VkCudaFunctionCreateInfoNV *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkCudaFunctionNV *pFunction)
     * }
     */
    public static FunctionDescriptor vkCreateCudaFunctionNV$descriptor() {
        return vkCreateCudaFunctionNV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkCreateCudaFunctionNV(VkDevice device, const VkCudaFunctionCreateInfoNV *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkCudaFunctionNV *pFunction)
     * }
     */
    public static MethodHandle vkCreateCudaFunctionNV$handle() {
        return vkCreateCudaFunctionNV.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * VkResult vkCreateCudaFunctionNV(VkDevice device, const VkCudaFunctionCreateInfoNV *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkCudaFunctionNV *pFunction)
     * }
     */
    public static int vkCreateCudaFunctionNV(MemorySegment device, MemorySegment pCreateInfo, MemorySegment pAllocator, MemorySegment pFunction) {
        var mh$ = vkCreateCudaFunctionNV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCreateCudaFunctionNV", device, pCreateInfo, pAllocator, pFunction);
            }
            return (int)mh$.invokeExact(device, pCreateInfo, pAllocator, pFunction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkDestroyCudaModuleNV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkDestroyCudaModuleNV"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkDestroyCudaModuleNV(VkDevice device, VkCudaModuleNV module, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static FunctionDescriptor vkDestroyCudaModuleNV$descriptor() {
        return vkDestroyCudaModuleNV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkDestroyCudaModuleNV(VkDevice device, VkCudaModuleNV module, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static MethodHandle vkDestroyCudaModuleNV$handle() {
        return vkDestroyCudaModuleNV.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkDestroyCudaModuleNV(VkDevice device, VkCudaModuleNV module, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static void vkDestroyCudaModuleNV(MemorySegment device, MemorySegment module, MemorySegment pAllocator) {
        var mh$ = vkDestroyCudaModuleNV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkDestroyCudaModuleNV", device, module, pAllocator);
            }
            mh$.invokeExact(device, module, pAllocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkDestroyCudaFunctionNV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkDestroyCudaFunctionNV"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkDestroyCudaFunctionNV(VkDevice device, VkCudaFunctionNV function, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static FunctionDescriptor vkDestroyCudaFunctionNV$descriptor() {
        return vkDestroyCudaFunctionNV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkDestroyCudaFunctionNV(VkDevice device, VkCudaFunctionNV function, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static MethodHandle vkDestroyCudaFunctionNV$handle() {
        return vkDestroyCudaFunctionNV.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkDestroyCudaFunctionNV(VkDevice device, VkCudaFunctionNV function, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static void vkDestroyCudaFunctionNV(MemorySegment device, MemorySegment function, MemorySegment pAllocator) {
        var mh$ = vkDestroyCudaFunctionNV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkDestroyCudaFunctionNV", device, function, pAllocator);
            }
            mh$.invokeExact(device, function, pAllocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdCudaLaunchKernelNV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdCudaLaunchKernelNV"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdCudaLaunchKernelNV(VkCommandBuffer commandBuffer, const VkCudaLaunchInfoNV *pLaunchInfo)
     * }
     */
    public static FunctionDescriptor vkCmdCudaLaunchKernelNV$descriptor() {
        return vkCmdCudaLaunchKernelNV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdCudaLaunchKernelNV(VkCommandBuffer commandBuffer, const VkCudaLaunchInfoNV *pLaunchInfo)
     * }
     */
    public static MethodHandle vkCmdCudaLaunchKernelNV$handle() {
        return vkCmdCudaLaunchKernelNV.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdCudaLaunchKernelNV(VkCommandBuffer commandBuffer, const VkCudaLaunchInfoNV *pLaunchInfo)
     * }
     */
    public static void vkCmdCudaLaunchKernelNV(MemorySegment commandBuffer, MemorySegment pLaunchInfo) {
        var mh$ = vkCmdCudaLaunchKernelNV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdCudaLaunchKernelNV", commandBuffer, pLaunchInfo);
            }
            mh$.invokeExact(commandBuffer, pLaunchInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct VkAccelerationStructureKHR_T *VkAccelerationStructureKHR
     * }
     */
    public static final AddressLayout VkAccelerationStructureKHR = vulkan_h.C_POINTER;

    private static class vkGetDescriptorSetLayoutSizeEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkGetDescriptorSetLayoutSizeEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkGetDescriptorSetLayoutSizeEXT(VkDevice device, VkDescriptorSetLayout layout, VkDeviceSize *pLayoutSizeInBytes)
     * }
     */
    public static FunctionDescriptor vkGetDescriptorSetLayoutSizeEXT$descriptor() {
        return vkGetDescriptorSetLayoutSizeEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkGetDescriptorSetLayoutSizeEXT(VkDevice device, VkDescriptorSetLayout layout, VkDeviceSize *pLayoutSizeInBytes)
     * }
     */
    public static MethodHandle vkGetDescriptorSetLayoutSizeEXT$handle() {
        return vkGetDescriptorSetLayoutSizeEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkGetDescriptorSetLayoutSizeEXT(VkDevice device, VkDescriptorSetLayout layout, VkDeviceSize *pLayoutSizeInBytes)
     * }
     */
    public static void vkGetDescriptorSetLayoutSizeEXT(MemorySegment device, MemorySegment layout, MemorySegment pLayoutSizeInBytes) {
        var mh$ = vkGetDescriptorSetLayoutSizeEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetDescriptorSetLayoutSizeEXT", device, layout, pLayoutSizeInBytes);
            }
            mh$.invokeExact(device, layout, pLayoutSizeInBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetDescriptorSetLayoutBindingOffsetEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkGetDescriptorSetLayoutBindingOffsetEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkGetDescriptorSetLayoutBindingOffsetEXT(VkDevice device, VkDescriptorSetLayout layout, uint32_t binding, VkDeviceSize *pOffset)
     * }
     */
    public static FunctionDescriptor vkGetDescriptorSetLayoutBindingOffsetEXT$descriptor() {
        return vkGetDescriptorSetLayoutBindingOffsetEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkGetDescriptorSetLayoutBindingOffsetEXT(VkDevice device, VkDescriptorSetLayout layout, uint32_t binding, VkDeviceSize *pOffset)
     * }
     */
    public static MethodHandle vkGetDescriptorSetLayoutBindingOffsetEXT$handle() {
        return vkGetDescriptorSetLayoutBindingOffsetEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkGetDescriptorSetLayoutBindingOffsetEXT(VkDevice device, VkDescriptorSetLayout layout, uint32_t binding, VkDeviceSize *pOffset)
     * }
     */
    public static void vkGetDescriptorSetLayoutBindingOffsetEXT(MemorySegment device, MemorySegment layout, int binding, MemorySegment pOffset) {
        var mh$ = vkGetDescriptorSetLayoutBindingOffsetEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetDescriptorSetLayoutBindingOffsetEXT", device, layout, binding, pOffset);
            }
            mh$.invokeExact(device, layout, binding, pOffset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetDescriptorEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_LONG,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkGetDescriptorEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkGetDescriptorEXT(VkDevice device, const VkDescriptorGetInfoEXT *pDescriptorInfo, size_t dataSize, void *pDescriptor)
     * }
     */
    public static FunctionDescriptor vkGetDescriptorEXT$descriptor() {
        return vkGetDescriptorEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkGetDescriptorEXT(VkDevice device, const VkDescriptorGetInfoEXT *pDescriptorInfo, size_t dataSize, void *pDescriptor)
     * }
     */
    public static MethodHandle vkGetDescriptorEXT$handle() {
        return vkGetDescriptorEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkGetDescriptorEXT(VkDevice device, const VkDescriptorGetInfoEXT *pDescriptorInfo, size_t dataSize, void *pDescriptor)
     * }
     */
    public static void vkGetDescriptorEXT(MemorySegment device, MemorySegment pDescriptorInfo, long dataSize, MemorySegment pDescriptor) {
        var mh$ = vkGetDescriptorEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetDescriptorEXT", device, pDescriptorInfo, dataSize, pDescriptor);
            }
            mh$.invokeExact(device, pDescriptorInfo, dataSize, pDescriptor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdBindDescriptorBuffersEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdBindDescriptorBuffersEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdBindDescriptorBuffersEXT(VkCommandBuffer commandBuffer, uint32_t bufferCount, const VkDescriptorBufferBindingInfoEXT *pBindingInfos)
     * }
     */
    public static FunctionDescriptor vkCmdBindDescriptorBuffersEXT$descriptor() {
        return vkCmdBindDescriptorBuffersEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdBindDescriptorBuffersEXT(VkCommandBuffer commandBuffer, uint32_t bufferCount, const VkDescriptorBufferBindingInfoEXT *pBindingInfos)
     * }
     */
    public static MethodHandle vkCmdBindDescriptorBuffersEXT$handle() {
        return vkCmdBindDescriptorBuffersEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdBindDescriptorBuffersEXT(VkCommandBuffer commandBuffer, uint32_t bufferCount, const VkDescriptorBufferBindingInfoEXT *pBindingInfos)
     * }
     */
    public static void vkCmdBindDescriptorBuffersEXT(MemorySegment commandBuffer, int bufferCount, MemorySegment pBindingInfos) {
        var mh$ = vkCmdBindDescriptorBuffersEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdBindDescriptorBuffersEXT", commandBuffer, bufferCount, pBindingInfos);
            }
            mh$.invokeExact(commandBuffer, bufferCount, pBindingInfos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdSetDescriptorBufferOffsetsEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdSetDescriptorBufferOffsetsEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdSetDescriptorBufferOffsetsEXT(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t firstSet, uint32_t setCount, const uint32_t *pBufferIndices, const VkDeviceSize *pOffsets)
     * }
     */
    public static FunctionDescriptor vkCmdSetDescriptorBufferOffsetsEXT$descriptor() {
        return vkCmdSetDescriptorBufferOffsetsEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdSetDescriptorBufferOffsetsEXT(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t firstSet, uint32_t setCount, const uint32_t *pBufferIndices, const VkDeviceSize *pOffsets)
     * }
     */
    public static MethodHandle vkCmdSetDescriptorBufferOffsetsEXT$handle() {
        return vkCmdSetDescriptorBufferOffsetsEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdSetDescriptorBufferOffsetsEXT(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t firstSet, uint32_t setCount, const uint32_t *pBufferIndices, const VkDeviceSize *pOffsets)
     * }
     */
    public static void vkCmdSetDescriptorBufferOffsetsEXT(MemorySegment commandBuffer, int pipelineBindPoint, MemorySegment layout, int firstSet, int setCount, MemorySegment pBufferIndices, MemorySegment pOffsets) {
        var mh$ = vkCmdSetDescriptorBufferOffsetsEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetDescriptorBufferOffsetsEXT", commandBuffer, pipelineBindPoint, layout, firstSet, setCount, pBufferIndices, pOffsets);
            }
            mh$.invokeExact(commandBuffer, pipelineBindPoint, layout, firstSet, setCount, pBufferIndices, pOffsets);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdBindDescriptorBufferEmbeddedSamplersEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdBindDescriptorBufferEmbeddedSamplersEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdBindDescriptorBufferEmbeddedSamplersEXT(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t set)
     * }
     */
    public static FunctionDescriptor vkCmdBindDescriptorBufferEmbeddedSamplersEXT$descriptor() {
        return vkCmdBindDescriptorBufferEmbeddedSamplersEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdBindDescriptorBufferEmbeddedSamplersEXT(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t set)
     * }
     */
    public static MethodHandle vkCmdBindDescriptorBufferEmbeddedSamplersEXT$handle() {
        return vkCmdBindDescriptorBufferEmbeddedSamplersEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdBindDescriptorBufferEmbeddedSamplersEXT(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t set)
     * }
     */
    public static void vkCmdBindDescriptorBufferEmbeddedSamplersEXT(MemorySegment commandBuffer, int pipelineBindPoint, MemorySegment layout, int set) {
        var mh$ = vkCmdBindDescriptorBufferEmbeddedSamplersEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdBindDescriptorBufferEmbeddedSamplersEXT", commandBuffer, pipelineBindPoint, layout, set);
            }
            mh$.invokeExact(commandBuffer, pipelineBindPoint, layout, set);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetBufferOpaqueCaptureDescriptorDataEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkGetBufferOpaqueCaptureDescriptorDataEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkGetBufferOpaqueCaptureDescriptorDataEXT(VkDevice device, const VkBufferCaptureDescriptorDataInfoEXT *pInfo, void *pData)
     * }
     */
    public static FunctionDescriptor vkGetBufferOpaqueCaptureDescriptorDataEXT$descriptor() {
        return vkGetBufferOpaqueCaptureDescriptorDataEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkGetBufferOpaqueCaptureDescriptorDataEXT(VkDevice device, const VkBufferCaptureDescriptorDataInfoEXT *pInfo, void *pData)
     * }
     */
    public static MethodHandle vkGetBufferOpaqueCaptureDescriptorDataEXT$handle() {
        return vkGetBufferOpaqueCaptureDescriptorDataEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * VkResult vkGetBufferOpaqueCaptureDescriptorDataEXT(VkDevice device, const VkBufferCaptureDescriptorDataInfoEXT *pInfo, void *pData)
     * }
     */
    public static int vkGetBufferOpaqueCaptureDescriptorDataEXT(MemorySegment device, MemorySegment pInfo, MemorySegment pData) {
        var mh$ = vkGetBufferOpaqueCaptureDescriptorDataEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetBufferOpaqueCaptureDescriptorDataEXT", device, pInfo, pData);
            }
            return (int)mh$.invokeExact(device, pInfo, pData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetImageOpaqueCaptureDescriptorDataEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkGetImageOpaqueCaptureDescriptorDataEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkGetImageOpaqueCaptureDescriptorDataEXT(VkDevice device, const VkImageCaptureDescriptorDataInfoEXT *pInfo, void *pData)
     * }
     */
    public static FunctionDescriptor vkGetImageOpaqueCaptureDescriptorDataEXT$descriptor() {
        return vkGetImageOpaqueCaptureDescriptorDataEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkGetImageOpaqueCaptureDescriptorDataEXT(VkDevice device, const VkImageCaptureDescriptorDataInfoEXT *pInfo, void *pData)
     * }
     */
    public static MethodHandle vkGetImageOpaqueCaptureDescriptorDataEXT$handle() {
        return vkGetImageOpaqueCaptureDescriptorDataEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * VkResult vkGetImageOpaqueCaptureDescriptorDataEXT(VkDevice device, const VkImageCaptureDescriptorDataInfoEXT *pInfo, void *pData)
     * }
     */
    public static int vkGetImageOpaqueCaptureDescriptorDataEXT(MemorySegment device, MemorySegment pInfo, MemorySegment pData) {
        var mh$ = vkGetImageOpaqueCaptureDescriptorDataEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetImageOpaqueCaptureDescriptorDataEXT", device, pInfo, pData);
            }
            return (int)mh$.invokeExact(device, pInfo, pData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetImageViewOpaqueCaptureDescriptorDataEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkGetImageViewOpaqueCaptureDescriptorDataEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkGetImageViewOpaqueCaptureDescriptorDataEXT(VkDevice device, const VkImageViewCaptureDescriptorDataInfoEXT *pInfo, void *pData)
     * }
     */
    public static FunctionDescriptor vkGetImageViewOpaqueCaptureDescriptorDataEXT$descriptor() {
        return vkGetImageViewOpaqueCaptureDescriptorDataEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkGetImageViewOpaqueCaptureDescriptorDataEXT(VkDevice device, const VkImageViewCaptureDescriptorDataInfoEXT *pInfo, void *pData)
     * }
     */
    public static MethodHandle vkGetImageViewOpaqueCaptureDescriptorDataEXT$handle() {
        return vkGetImageViewOpaqueCaptureDescriptorDataEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * VkResult vkGetImageViewOpaqueCaptureDescriptorDataEXT(VkDevice device, const VkImageViewCaptureDescriptorDataInfoEXT *pInfo, void *pData)
     * }
     */
    public static int vkGetImageViewOpaqueCaptureDescriptorDataEXT(MemorySegment device, MemorySegment pInfo, MemorySegment pData) {
        var mh$ = vkGetImageViewOpaqueCaptureDescriptorDataEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetImageViewOpaqueCaptureDescriptorDataEXT", device, pInfo, pData);
            }
            return (int)mh$.invokeExact(device, pInfo, pData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetSamplerOpaqueCaptureDescriptorDataEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkGetSamplerOpaqueCaptureDescriptorDataEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkGetSamplerOpaqueCaptureDescriptorDataEXT(VkDevice device, const VkSamplerCaptureDescriptorDataInfoEXT *pInfo, void *pData)
     * }
     */
    public static FunctionDescriptor vkGetSamplerOpaqueCaptureDescriptorDataEXT$descriptor() {
        return vkGetSamplerOpaqueCaptureDescriptorDataEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkGetSamplerOpaqueCaptureDescriptorDataEXT(VkDevice device, const VkSamplerCaptureDescriptorDataInfoEXT *pInfo, void *pData)
     * }
     */
    public static MethodHandle vkGetSamplerOpaqueCaptureDescriptorDataEXT$handle() {
        return vkGetSamplerOpaqueCaptureDescriptorDataEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * VkResult vkGetSamplerOpaqueCaptureDescriptorDataEXT(VkDevice device, const VkSamplerCaptureDescriptorDataInfoEXT *pInfo, void *pData)
     * }
     */
    public static int vkGetSamplerOpaqueCaptureDescriptorDataEXT(MemorySegment device, MemorySegment pInfo, MemorySegment pData) {
        var mh$ = vkGetSamplerOpaqueCaptureDescriptorDataEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetSamplerOpaqueCaptureDescriptorDataEXT", device, pInfo, pData);
            }
            return (int)mh$.invokeExact(device, pInfo, pData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT(VkDevice device, const VkAccelerationStructureCaptureDescriptorDataInfoEXT *pInfo, void *pData)
     * }
     */
    public static FunctionDescriptor vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT$descriptor() {
        return vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT(VkDevice device, const VkAccelerationStructureCaptureDescriptorDataInfoEXT *pInfo, void *pData)
     * }
     */
    public static MethodHandle vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT$handle() {
        return vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * VkResult vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT(VkDevice device, const VkAccelerationStructureCaptureDescriptorDataInfoEXT *pInfo, void *pData)
     * }
     */
    public static int vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT(MemorySegment device, MemorySegment pInfo, MemorySegment pData) {
        var mh$ = vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT", device, pInfo, pData);
            }
            return (int)mh$.invokeExact(device, pInfo, pData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int VK_GRAPHICS_PIPELINE_LIBRARY_VERTEX_INPUT_INTERFACE_BIT_EXT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkGraphicsPipelineLibraryFlagBitsEXT.VK_GRAPHICS_PIPELINE_LIBRARY_VERTEX_INPUT_INTERFACE_BIT_EXT = 1
     * }
     */
    public static int VK_GRAPHICS_PIPELINE_LIBRARY_VERTEX_INPUT_INTERFACE_BIT_EXT() {
        return VK_GRAPHICS_PIPELINE_LIBRARY_VERTEX_INPUT_INTERFACE_BIT_EXT;
    }
    private static final int VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkGraphicsPipelineLibraryFlagBitsEXT.VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT = 2
     * }
     */
    public static int VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT() {
        return VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT;
    }
    private static final int VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkGraphicsPipelineLibraryFlagBitsEXT.VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT = 4
     * }
     */
    public static int VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT() {
        return VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT;
    }
    private static final int VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT = (int)8L;
    /**
     * {@snippet lang=c :
     * enum VkGraphicsPipelineLibraryFlagBitsEXT.VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT = 8
     * }
     */
    public static int VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT() {
        return VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT;
    }
    private static final int VK_GRAPHICS_PIPELINE_LIBRARY_FLAG_BITS_MAX_ENUM_EXT = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkGraphicsPipelineLibraryFlagBitsEXT.VK_GRAPHICS_PIPELINE_LIBRARY_FLAG_BITS_MAX_ENUM_EXT = 2147483647
     * }
     */
    public static int VK_GRAPHICS_PIPELINE_LIBRARY_FLAG_BITS_MAX_ENUM_EXT() {
        return VK_GRAPHICS_PIPELINE_LIBRARY_FLAG_BITS_MAX_ENUM_EXT;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkGraphicsPipelineLibraryFlagsEXT
     * }
     */
    public static final OfInt VkGraphicsPipelineLibraryFlagsEXT = vulkan_h.C_INT;
    private static final int VK_FRAGMENT_SHADING_RATE_TYPE_FRAGMENT_SIZE_NV = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkFragmentShadingRateTypeNV.VK_FRAGMENT_SHADING_RATE_TYPE_FRAGMENT_SIZE_NV = 0
     * }
     */
    public static int VK_FRAGMENT_SHADING_RATE_TYPE_FRAGMENT_SIZE_NV() {
        return VK_FRAGMENT_SHADING_RATE_TYPE_FRAGMENT_SIZE_NV;
    }
    private static final int VK_FRAGMENT_SHADING_RATE_TYPE_ENUMS_NV = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkFragmentShadingRateTypeNV.VK_FRAGMENT_SHADING_RATE_TYPE_ENUMS_NV = 1
     * }
     */
    public static int VK_FRAGMENT_SHADING_RATE_TYPE_ENUMS_NV() {
        return VK_FRAGMENT_SHADING_RATE_TYPE_ENUMS_NV;
    }
    private static final int VK_FRAGMENT_SHADING_RATE_TYPE_MAX_ENUM_NV = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkFragmentShadingRateTypeNV.VK_FRAGMENT_SHADING_RATE_TYPE_MAX_ENUM_NV = 2147483647
     * }
     */
    public static int VK_FRAGMENT_SHADING_RATE_TYPE_MAX_ENUM_NV() {
        return VK_FRAGMENT_SHADING_RATE_TYPE_MAX_ENUM_NV;
    }
    private static final int VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_PIXEL_NV = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkFragmentShadingRateNV.VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_PIXEL_NV = 0
     * }
     */
    public static int VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_PIXEL_NV() {
        return VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_PIXEL_NV;
    }
    private static final int VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_1X2_PIXELS_NV = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkFragmentShadingRateNV.VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_1X2_PIXELS_NV = 1
     * }
     */
    public static int VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_1X2_PIXELS_NV() {
        return VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_1X2_PIXELS_NV;
    }
    private static final int VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X1_PIXELS_NV = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkFragmentShadingRateNV.VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X1_PIXELS_NV = 4
     * }
     */
    public static int VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X1_PIXELS_NV() {
        return VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X1_PIXELS_NV;
    }
    private static final int VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X2_PIXELS_NV = (int)5L;
    /**
     * {@snippet lang=c :
     * enum VkFragmentShadingRateNV.VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X2_PIXELS_NV = 5
     * }
     */
    public static int VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X2_PIXELS_NV() {
        return VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X2_PIXELS_NV;
    }
    private static final int VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X4_PIXELS_NV = (int)6L;
    /**
     * {@snippet lang=c :
     * enum VkFragmentShadingRateNV.VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X4_PIXELS_NV = 6
     * }
     */
    public static int VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X4_PIXELS_NV() {
        return VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X4_PIXELS_NV;
    }
    private static final int VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X2_PIXELS_NV = (int)9L;
    /**
     * {@snippet lang=c :
     * enum VkFragmentShadingRateNV.VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X2_PIXELS_NV = 9
     * }
     */
    public static int VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X2_PIXELS_NV() {
        return VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X2_PIXELS_NV;
    }
    private static final int VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X4_PIXELS_NV = (int)10L;
    /**
     * {@snippet lang=c :
     * enum VkFragmentShadingRateNV.VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X4_PIXELS_NV = 10
     * }
     */
    public static int VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X4_PIXELS_NV() {
        return VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X4_PIXELS_NV;
    }
    private static final int VK_FRAGMENT_SHADING_RATE_2_INVOCATIONS_PER_PIXEL_NV = (int)11L;
    /**
     * {@snippet lang=c :
     * enum VkFragmentShadingRateNV.VK_FRAGMENT_SHADING_RATE_2_INVOCATIONS_PER_PIXEL_NV = 11
     * }
     */
    public static int VK_FRAGMENT_SHADING_RATE_2_INVOCATIONS_PER_PIXEL_NV() {
        return VK_FRAGMENT_SHADING_RATE_2_INVOCATIONS_PER_PIXEL_NV;
    }
    private static final int VK_FRAGMENT_SHADING_RATE_4_INVOCATIONS_PER_PIXEL_NV = (int)12L;
    /**
     * {@snippet lang=c :
     * enum VkFragmentShadingRateNV.VK_FRAGMENT_SHADING_RATE_4_INVOCATIONS_PER_PIXEL_NV = 12
     * }
     */
    public static int VK_FRAGMENT_SHADING_RATE_4_INVOCATIONS_PER_PIXEL_NV() {
        return VK_FRAGMENT_SHADING_RATE_4_INVOCATIONS_PER_PIXEL_NV;
    }
    private static final int VK_FRAGMENT_SHADING_RATE_8_INVOCATIONS_PER_PIXEL_NV = (int)13L;
    /**
     * {@snippet lang=c :
     * enum VkFragmentShadingRateNV.VK_FRAGMENT_SHADING_RATE_8_INVOCATIONS_PER_PIXEL_NV = 13
     * }
     */
    public static int VK_FRAGMENT_SHADING_RATE_8_INVOCATIONS_PER_PIXEL_NV() {
        return VK_FRAGMENT_SHADING_RATE_8_INVOCATIONS_PER_PIXEL_NV;
    }
    private static final int VK_FRAGMENT_SHADING_RATE_16_INVOCATIONS_PER_PIXEL_NV = (int)14L;
    /**
     * {@snippet lang=c :
     * enum VkFragmentShadingRateNV.VK_FRAGMENT_SHADING_RATE_16_INVOCATIONS_PER_PIXEL_NV = 14
     * }
     */
    public static int VK_FRAGMENT_SHADING_RATE_16_INVOCATIONS_PER_PIXEL_NV() {
        return VK_FRAGMENT_SHADING_RATE_16_INVOCATIONS_PER_PIXEL_NV;
    }
    private static final int VK_FRAGMENT_SHADING_RATE_NO_INVOCATIONS_NV = (int)15L;
    /**
     * {@snippet lang=c :
     * enum VkFragmentShadingRateNV.VK_FRAGMENT_SHADING_RATE_NO_INVOCATIONS_NV = 15
     * }
     */
    public static int VK_FRAGMENT_SHADING_RATE_NO_INVOCATIONS_NV() {
        return VK_FRAGMENT_SHADING_RATE_NO_INVOCATIONS_NV;
    }
    private static final int VK_FRAGMENT_SHADING_RATE_MAX_ENUM_NV = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkFragmentShadingRateNV.VK_FRAGMENT_SHADING_RATE_MAX_ENUM_NV = 2147483647
     * }
     */
    public static int VK_FRAGMENT_SHADING_RATE_MAX_ENUM_NV() {
        return VK_FRAGMENT_SHADING_RATE_MAX_ENUM_NV;
    }

    private static class vkCmdSetFragmentShadingRateEnumNV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdSetFragmentShadingRateEnumNV"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdSetFragmentShadingRateEnumNV(VkCommandBuffer commandBuffer, VkFragmentShadingRateNV shadingRate, const VkFragmentShadingRateCombinerOpKHR combinerOps[2])
     * }
     */
    public static FunctionDescriptor vkCmdSetFragmentShadingRateEnumNV$descriptor() {
        return vkCmdSetFragmentShadingRateEnumNV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdSetFragmentShadingRateEnumNV(VkCommandBuffer commandBuffer, VkFragmentShadingRateNV shadingRate, const VkFragmentShadingRateCombinerOpKHR combinerOps[2])
     * }
     */
    public static MethodHandle vkCmdSetFragmentShadingRateEnumNV$handle() {
        return vkCmdSetFragmentShadingRateEnumNV.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdSetFragmentShadingRateEnumNV(VkCommandBuffer commandBuffer, VkFragmentShadingRateNV shadingRate, const VkFragmentShadingRateCombinerOpKHR combinerOps[2])
     * }
     */
    public static void vkCmdSetFragmentShadingRateEnumNV(MemorySegment commandBuffer, int shadingRate, MemorySegment combinerOps) {
        var mh$ = vkCmdSetFragmentShadingRateEnumNV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetFragmentShadingRateEnumNV", commandBuffer, shadingRate, combinerOps);
            }
            mh$.invokeExact(commandBuffer, shadingRate, combinerOps);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_STATIC_NV = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkAccelerationStructureMotionInstanceTypeNV.VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_STATIC_NV = 0
     * }
     */
    public static int VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_STATIC_NV() {
        return VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_STATIC_NV;
    }
    private static final int VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_MATRIX_MOTION_NV = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkAccelerationStructureMotionInstanceTypeNV.VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_MATRIX_MOTION_NV = 1
     * }
     */
    public static int VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_MATRIX_MOTION_NV() {
        return VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_MATRIX_MOTION_NV;
    }
    private static final int VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_SRT_MOTION_NV = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkAccelerationStructureMotionInstanceTypeNV.VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_SRT_MOTION_NV = 2
     * }
     */
    public static int VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_SRT_MOTION_NV() {
        return VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_SRT_MOTION_NV;
    }
    private static final int VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_MAX_ENUM_NV = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkAccelerationStructureMotionInstanceTypeNV.VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_MAX_ENUM_NV = 2147483647
     * }
     */
    public static int VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_MAX_ENUM_NV() {
        return VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_MAX_ENUM_NV;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkAccelerationStructureMotionInfoFlagsNV
     * }
     */
    public static final OfInt VkAccelerationStructureMotionInfoFlagsNV = vulkan_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkAccelerationStructureMotionInstanceFlagsNV
     * }
     */
    public static final OfInt VkAccelerationStructureMotionInstanceFlagsNV = vulkan_h.C_INT;
    private static final int VK_IMAGE_COMPRESSION_DEFAULT_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkImageCompressionFlagBitsEXT.VK_IMAGE_COMPRESSION_DEFAULT_EXT = 0
     * }
     */
    public static int VK_IMAGE_COMPRESSION_DEFAULT_EXT() {
        return VK_IMAGE_COMPRESSION_DEFAULT_EXT;
    }
    private static final int VK_IMAGE_COMPRESSION_FIXED_RATE_DEFAULT_EXT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkImageCompressionFlagBitsEXT.VK_IMAGE_COMPRESSION_FIXED_RATE_DEFAULT_EXT = 1
     * }
     */
    public static int VK_IMAGE_COMPRESSION_FIXED_RATE_DEFAULT_EXT() {
        return VK_IMAGE_COMPRESSION_FIXED_RATE_DEFAULT_EXT;
    }
    private static final int VK_IMAGE_COMPRESSION_FIXED_RATE_EXPLICIT_EXT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkImageCompressionFlagBitsEXT.VK_IMAGE_COMPRESSION_FIXED_RATE_EXPLICIT_EXT = 2
     * }
     */
    public static int VK_IMAGE_COMPRESSION_FIXED_RATE_EXPLICIT_EXT() {
        return VK_IMAGE_COMPRESSION_FIXED_RATE_EXPLICIT_EXT;
    }
    private static final int VK_IMAGE_COMPRESSION_DISABLED_EXT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkImageCompressionFlagBitsEXT.VK_IMAGE_COMPRESSION_DISABLED_EXT = 4
     * }
     */
    public static int VK_IMAGE_COMPRESSION_DISABLED_EXT() {
        return VK_IMAGE_COMPRESSION_DISABLED_EXT;
    }
    private static final int VK_IMAGE_COMPRESSION_FLAG_BITS_MAX_ENUM_EXT = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkImageCompressionFlagBitsEXT.VK_IMAGE_COMPRESSION_FLAG_BITS_MAX_ENUM_EXT = 2147483647
     * }
     */
    public static int VK_IMAGE_COMPRESSION_FLAG_BITS_MAX_ENUM_EXT() {
        return VK_IMAGE_COMPRESSION_FLAG_BITS_MAX_ENUM_EXT;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkImageCompressionFlagsEXT
     * }
     */
    public static final OfInt VkImageCompressionFlagsEXT = vulkan_h.C_INT;
    private static final int VK_IMAGE_COMPRESSION_FIXED_RATE_NONE_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkImageCompressionFixedRateFlagBitsEXT.VK_IMAGE_COMPRESSION_FIXED_RATE_NONE_EXT = 0
     * }
     */
    public static int VK_IMAGE_COMPRESSION_FIXED_RATE_NONE_EXT() {
        return VK_IMAGE_COMPRESSION_FIXED_RATE_NONE_EXT;
    }
    private static final int VK_IMAGE_COMPRESSION_FIXED_RATE_1BPC_BIT_EXT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkImageCompressionFixedRateFlagBitsEXT.VK_IMAGE_COMPRESSION_FIXED_RATE_1BPC_BIT_EXT = 1
     * }
     */
    public static int VK_IMAGE_COMPRESSION_FIXED_RATE_1BPC_BIT_EXT() {
        return VK_IMAGE_COMPRESSION_FIXED_RATE_1BPC_BIT_EXT;
    }
    private static final int VK_IMAGE_COMPRESSION_FIXED_RATE_2BPC_BIT_EXT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkImageCompressionFixedRateFlagBitsEXT.VK_IMAGE_COMPRESSION_FIXED_RATE_2BPC_BIT_EXT = 2
     * }
     */
    public static int VK_IMAGE_COMPRESSION_FIXED_RATE_2BPC_BIT_EXT() {
        return VK_IMAGE_COMPRESSION_FIXED_RATE_2BPC_BIT_EXT;
    }
    private static final int VK_IMAGE_COMPRESSION_FIXED_RATE_3BPC_BIT_EXT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkImageCompressionFixedRateFlagBitsEXT.VK_IMAGE_COMPRESSION_FIXED_RATE_3BPC_BIT_EXT = 4
     * }
     */
    public static int VK_IMAGE_COMPRESSION_FIXED_RATE_3BPC_BIT_EXT() {
        return VK_IMAGE_COMPRESSION_FIXED_RATE_3BPC_BIT_EXT;
    }
    private static final int VK_IMAGE_COMPRESSION_FIXED_RATE_4BPC_BIT_EXT = (int)8L;
    /**
     * {@snippet lang=c :
     * enum VkImageCompressionFixedRateFlagBitsEXT.VK_IMAGE_COMPRESSION_FIXED_RATE_4BPC_BIT_EXT = 8
     * }
     */
    public static int VK_IMAGE_COMPRESSION_FIXED_RATE_4BPC_BIT_EXT() {
        return VK_IMAGE_COMPRESSION_FIXED_RATE_4BPC_BIT_EXT;
    }
    private static final int VK_IMAGE_COMPRESSION_FIXED_RATE_5BPC_BIT_EXT = (int)16L;
    /**
     * {@snippet lang=c :
     * enum VkImageCompressionFixedRateFlagBitsEXT.VK_IMAGE_COMPRESSION_FIXED_RATE_5BPC_BIT_EXT = 16
     * }
     */
    public static int VK_IMAGE_COMPRESSION_FIXED_RATE_5BPC_BIT_EXT() {
        return VK_IMAGE_COMPRESSION_FIXED_RATE_5BPC_BIT_EXT;
    }
    private static final int VK_IMAGE_COMPRESSION_FIXED_RATE_6BPC_BIT_EXT = (int)32L;
    /**
     * {@snippet lang=c :
     * enum VkImageCompressionFixedRateFlagBitsEXT.VK_IMAGE_COMPRESSION_FIXED_RATE_6BPC_BIT_EXT = 32
     * }
     */
    public static int VK_IMAGE_COMPRESSION_FIXED_RATE_6BPC_BIT_EXT() {
        return VK_IMAGE_COMPRESSION_FIXED_RATE_6BPC_BIT_EXT;
    }
    private static final int VK_IMAGE_COMPRESSION_FIXED_RATE_7BPC_BIT_EXT = (int)64L;
    /**
     * {@snippet lang=c :
     * enum VkImageCompressionFixedRateFlagBitsEXT.VK_IMAGE_COMPRESSION_FIXED_RATE_7BPC_BIT_EXT = 64
     * }
     */
    public static int VK_IMAGE_COMPRESSION_FIXED_RATE_7BPC_BIT_EXT() {
        return VK_IMAGE_COMPRESSION_FIXED_RATE_7BPC_BIT_EXT;
    }
    private static final int VK_IMAGE_COMPRESSION_FIXED_RATE_8BPC_BIT_EXT = (int)128L;
    /**
     * {@snippet lang=c :
     * enum VkImageCompressionFixedRateFlagBitsEXT.VK_IMAGE_COMPRESSION_FIXED_RATE_8BPC_BIT_EXT = 128
     * }
     */
    public static int VK_IMAGE_COMPRESSION_FIXED_RATE_8BPC_BIT_EXT() {
        return VK_IMAGE_COMPRESSION_FIXED_RATE_8BPC_BIT_EXT;
    }
    private static final int VK_IMAGE_COMPRESSION_FIXED_RATE_9BPC_BIT_EXT = (int)256L;
    /**
     * {@snippet lang=c :
     * enum VkImageCompressionFixedRateFlagBitsEXT.VK_IMAGE_COMPRESSION_FIXED_RATE_9BPC_BIT_EXT = 256
     * }
     */
    public static int VK_IMAGE_COMPRESSION_FIXED_RATE_9BPC_BIT_EXT() {
        return VK_IMAGE_COMPRESSION_FIXED_RATE_9BPC_BIT_EXT;
    }
    private static final int VK_IMAGE_COMPRESSION_FIXED_RATE_10BPC_BIT_EXT = (int)512L;
    /**
     * {@snippet lang=c :
     * enum VkImageCompressionFixedRateFlagBitsEXT.VK_IMAGE_COMPRESSION_FIXED_RATE_10BPC_BIT_EXT = 512
     * }
     */
    public static int VK_IMAGE_COMPRESSION_FIXED_RATE_10BPC_BIT_EXT() {
        return VK_IMAGE_COMPRESSION_FIXED_RATE_10BPC_BIT_EXT;
    }
    private static final int VK_IMAGE_COMPRESSION_FIXED_RATE_11BPC_BIT_EXT = (int)1024L;
    /**
     * {@snippet lang=c :
     * enum VkImageCompressionFixedRateFlagBitsEXT.VK_IMAGE_COMPRESSION_FIXED_RATE_11BPC_BIT_EXT = 1024
     * }
     */
    public static int VK_IMAGE_COMPRESSION_FIXED_RATE_11BPC_BIT_EXT() {
        return VK_IMAGE_COMPRESSION_FIXED_RATE_11BPC_BIT_EXT;
    }
    private static final int VK_IMAGE_COMPRESSION_FIXED_RATE_12BPC_BIT_EXT = (int)2048L;
    /**
     * {@snippet lang=c :
     * enum VkImageCompressionFixedRateFlagBitsEXT.VK_IMAGE_COMPRESSION_FIXED_RATE_12BPC_BIT_EXT = 2048
     * }
     */
    public static int VK_IMAGE_COMPRESSION_FIXED_RATE_12BPC_BIT_EXT() {
        return VK_IMAGE_COMPRESSION_FIXED_RATE_12BPC_BIT_EXT;
    }
    private static final int VK_IMAGE_COMPRESSION_FIXED_RATE_13BPC_BIT_EXT = (int)4096L;
    /**
     * {@snippet lang=c :
     * enum VkImageCompressionFixedRateFlagBitsEXT.VK_IMAGE_COMPRESSION_FIXED_RATE_13BPC_BIT_EXT = 4096
     * }
     */
    public static int VK_IMAGE_COMPRESSION_FIXED_RATE_13BPC_BIT_EXT() {
        return VK_IMAGE_COMPRESSION_FIXED_RATE_13BPC_BIT_EXT;
    }
    private static final int VK_IMAGE_COMPRESSION_FIXED_RATE_14BPC_BIT_EXT = (int)8192L;
    /**
     * {@snippet lang=c :
     * enum VkImageCompressionFixedRateFlagBitsEXT.VK_IMAGE_COMPRESSION_FIXED_RATE_14BPC_BIT_EXT = 8192
     * }
     */
    public static int VK_IMAGE_COMPRESSION_FIXED_RATE_14BPC_BIT_EXT() {
        return VK_IMAGE_COMPRESSION_FIXED_RATE_14BPC_BIT_EXT;
    }
    private static final int VK_IMAGE_COMPRESSION_FIXED_RATE_15BPC_BIT_EXT = (int)16384L;
    /**
     * {@snippet lang=c :
     * enum VkImageCompressionFixedRateFlagBitsEXT.VK_IMAGE_COMPRESSION_FIXED_RATE_15BPC_BIT_EXT = 16384
     * }
     */
    public static int VK_IMAGE_COMPRESSION_FIXED_RATE_15BPC_BIT_EXT() {
        return VK_IMAGE_COMPRESSION_FIXED_RATE_15BPC_BIT_EXT;
    }
    private static final int VK_IMAGE_COMPRESSION_FIXED_RATE_16BPC_BIT_EXT = (int)32768L;
    /**
     * {@snippet lang=c :
     * enum VkImageCompressionFixedRateFlagBitsEXT.VK_IMAGE_COMPRESSION_FIXED_RATE_16BPC_BIT_EXT = 32768
     * }
     */
    public static int VK_IMAGE_COMPRESSION_FIXED_RATE_16BPC_BIT_EXT() {
        return VK_IMAGE_COMPRESSION_FIXED_RATE_16BPC_BIT_EXT;
    }
    private static final int VK_IMAGE_COMPRESSION_FIXED_RATE_17BPC_BIT_EXT = (int)65536L;
    /**
     * {@snippet lang=c :
     * enum VkImageCompressionFixedRateFlagBitsEXT.VK_IMAGE_COMPRESSION_FIXED_RATE_17BPC_BIT_EXT = 65536
     * }
     */
    public static int VK_IMAGE_COMPRESSION_FIXED_RATE_17BPC_BIT_EXT() {
        return VK_IMAGE_COMPRESSION_FIXED_RATE_17BPC_BIT_EXT;
    }
    private static final int VK_IMAGE_COMPRESSION_FIXED_RATE_18BPC_BIT_EXT = (int)131072L;
    /**
     * {@snippet lang=c :
     * enum VkImageCompressionFixedRateFlagBitsEXT.VK_IMAGE_COMPRESSION_FIXED_RATE_18BPC_BIT_EXT = 131072
     * }
     */
    public static int VK_IMAGE_COMPRESSION_FIXED_RATE_18BPC_BIT_EXT() {
        return VK_IMAGE_COMPRESSION_FIXED_RATE_18BPC_BIT_EXT;
    }
    private static final int VK_IMAGE_COMPRESSION_FIXED_RATE_19BPC_BIT_EXT = (int)262144L;
    /**
     * {@snippet lang=c :
     * enum VkImageCompressionFixedRateFlagBitsEXT.VK_IMAGE_COMPRESSION_FIXED_RATE_19BPC_BIT_EXT = 262144
     * }
     */
    public static int VK_IMAGE_COMPRESSION_FIXED_RATE_19BPC_BIT_EXT() {
        return VK_IMAGE_COMPRESSION_FIXED_RATE_19BPC_BIT_EXT;
    }
    private static final int VK_IMAGE_COMPRESSION_FIXED_RATE_20BPC_BIT_EXT = (int)524288L;
    /**
     * {@snippet lang=c :
     * enum VkImageCompressionFixedRateFlagBitsEXT.VK_IMAGE_COMPRESSION_FIXED_RATE_20BPC_BIT_EXT = 524288
     * }
     */
    public static int VK_IMAGE_COMPRESSION_FIXED_RATE_20BPC_BIT_EXT() {
        return VK_IMAGE_COMPRESSION_FIXED_RATE_20BPC_BIT_EXT;
    }
    private static final int VK_IMAGE_COMPRESSION_FIXED_RATE_21BPC_BIT_EXT = (int)1048576L;
    /**
     * {@snippet lang=c :
     * enum VkImageCompressionFixedRateFlagBitsEXT.VK_IMAGE_COMPRESSION_FIXED_RATE_21BPC_BIT_EXT = 1048576
     * }
     */
    public static int VK_IMAGE_COMPRESSION_FIXED_RATE_21BPC_BIT_EXT() {
        return VK_IMAGE_COMPRESSION_FIXED_RATE_21BPC_BIT_EXT;
    }
    private static final int VK_IMAGE_COMPRESSION_FIXED_RATE_22BPC_BIT_EXT = (int)2097152L;
    /**
     * {@snippet lang=c :
     * enum VkImageCompressionFixedRateFlagBitsEXT.VK_IMAGE_COMPRESSION_FIXED_RATE_22BPC_BIT_EXT = 2097152
     * }
     */
    public static int VK_IMAGE_COMPRESSION_FIXED_RATE_22BPC_BIT_EXT() {
        return VK_IMAGE_COMPRESSION_FIXED_RATE_22BPC_BIT_EXT;
    }
    private static final int VK_IMAGE_COMPRESSION_FIXED_RATE_23BPC_BIT_EXT = (int)4194304L;
    /**
     * {@snippet lang=c :
     * enum VkImageCompressionFixedRateFlagBitsEXT.VK_IMAGE_COMPRESSION_FIXED_RATE_23BPC_BIT_EXT = 4194304
     * }
     */
    public static int VK_IMAGE_COMPRESSION_FIXED_RATE_23BPC_BIT_EXT() {
        return VK_IMAGE_COMPRESSION_FIXED_RATE_23BPC_BIT_EXT;
    }
    private static final int VK_IMAGE_COMPRESSION_FIXED_RATE_24BPC_BIT_EXT = (int)8388608L;
    /**
     * {@snippet lang=c :
     * enum VkImageCompressionFixedRateFlagBitsEXT.VK_IMAGE_COMPRESSION_FIXED_RATE_24BPC_BIT_EXT = 8388608
     * }
     */
    public static int VK_IMAGE_COMPRESSION_FIXED_RATE_24BPC_BIT_EXT() {
        return VK_IMAGE_COMPRESSION_FIXED_RATE_24BPC_BIT_EXT;
    }
    private static final int VK_IMAGE_COMPRESSION_FIXED_RATE_FLAG_BITS_MAX_ENUM_EXT = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkImageCompressionFixedRateFlagBitsEXT.VK_IMAGE_COMPRESSION_FIXED_RATE_FLAG_BITS_MAX_ENUM_EXT = 2147483647
     * }
     */
    public static int VK_IMAGE_COMPRESSION_FIXED_RATE_FLAG_BITS_MAX_ENUM_EXT() {
        return VK_IMAGE_COMPRESSION_FIXED_RATE_FLAG_BITS_MAX_ENUM_EXT;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkImageCompressionFixedRateFlagsEXT
     * }
     */
    public static final OfInt VkImageCompressionFixedRateFlagsEXT = vulkan_h.C_INT;
    private static final int VK_DEVICE_FAULT_ADDRESS_TYPE_NONE_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkDeviceFaultAddressTypeEXT.VK_DEVICE_FAULT_ADDRESS_TYPE_NONE_EXT = 0
     * }
     */
    public static int VK_DEVICE_FAULT_ADDRESS_TYPE_NONE_EXT() {
        return VK_DEVICE_FAULT_ADDRESS_TYPE_NONE_EXT;
    }
    private static final int VK_DEVICE_FAULT_ADDRESS_TYPE_READ_INVALID_EXT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkDeviceFaultAddressTypeEXT.VK_DEVICE_FAULT_ADDRESS_TYPE_READ_INVALID_EXT = 1
     * }
     */
    public static int VK_DEVICE_FAULT_ADDRESS_TYPE_READ_INVALID_EXT() {
        return VK_DEVICE_FAULT_ADDRESS_TYPE_READ_INVALID_EXT;
    }
    private static final int VK_DEVICE_FAULT_ADDRESS_TYPE_WRITE_INVALID_EXT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkDeviceFaultAddressTypeEXT.VK_DEVICE_FAULT_ADDRESS_TYPE_WRITE_INVALID_EXT = 2
     * }
     */
    public static int VK_DEVICE_FAULT_ADDRESS_TYPE_WRITE_INVALID_EXT() {
        return VK_DEVICE_FAULT_ADDRESS_TYPE_WRITE_INVALID_EXT;
    }
    private static final int VK_DEVICE_FAULT_ADDRESS_TYPE_EXECUTE_INVALID_EXT = (int)3L;
    /**
     * {@snippet lang=c :
     * enum VkDeviceFaultAddressTypeEXT.VK_DEVICE_FAULT_ADDRESS_TYPE_EXECUTE_INVALID_EXT = 3
     * }
     */
    public static int VK_DEVICE_FAULT_ADDRESS_TYPE_EXECUTE_INVALID_EXT() {
        return VK_DEVICE_FAULT_ADDRESS_TYPE_EXECUTE_INVALID_EXT;
    }
    private static final int VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_UNKNOWN_EXT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkDeviceFaultAddressTypeEXT.VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_UNKNOWN_EXT = 4
     * }
     */
    public static int VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_UNKNOWN_EXT() {
        return VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_UNKNOWN_EXT;
    }
    private static final int VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_INVALID_EXT = (int)5L;
    /**
     * {@snippet lang=c :
     * enum VkDeviceFaultAddressTypeEXT.VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_INVALID_EXT = 5
     * }
     */
    public static int VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_INVALID_EXT() {
        return VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_INVALID_EXT;
    }
    private static final int VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_FAULT_EXT = (int)6L;
    /**
     * {@snippet lang=c :
     * enum VkDeviceFaultAddressTypeEXT.VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_FAULT_EXT = 6
     * }
     */
    public static int VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_FAULT_EXT() {
        return VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_FAULT_EXT;
    }
    private static final int VK_DEVICE_FAULT_ADDRESS_TYPE_MAX_ENUM_EXT = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkDeviceFaultAddressTypeEXT.VK_DEVICE_FAULT_ADDRESS_TYPE_MAX_ENUM_EXT = 2147483647
     * }
     */
    public static int VK_DEVICE_FAULT_ADDRESS_TYPE_MAX_ENUM_EXT() {
        return VK_DEVICE_FAULT_ADDRESS_TYPE_MAX_ENUM_EXT;
    }
    private static final int VK_DEVICE_FAULT_VENDOR_BINARY_HEADER_VERSION_ONE_EXT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkDeviceFaultVendorBinaryHeaderVersionEXT.VK_DEVICE_FAULT_VENDOR_BINARY_HEADER_VERSION_ONE_EXT = 1
     * }
     */
    public static int VK_DEVICE_FAULT_VENDOR_BINARY_HEADER_VERSION_ONE_EXT() {
        return VK_DEVICE_FAULT_VENDOR_BINARY_HEADER_VERSION_ONE_EXT;
    }
    private static final int VK_DEVICE_FAULT_VENDOR_BINARY_HEADER_VERSION_MAX_ENUM_EXT = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkDeviceFaultVendorBinaryHeaderVersionEXT.VK_DEVICE_FAULT_VENDOR_BINARY_HEADER_VERSION_MAX_ENUM_EXT = 2147483647
     * }
     */
    public static int VK_DEVICE_FAULT_VENDOR_BINARY_HEADER_VERSION_MAX_ENUM_EXT() {
        return VK_DEVICE_FAULT_VENDOR_BINARY_HEADER_VERSION_MAX_ENUM_EXT;
    }

    private static class vkGetDeviceFaultInfoEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkGetDeviceFaultInfoEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkGetDeviceFaultInfoEXT(VkDevice device, VkDeviceFaultCountsEXT *pFaultCounts, VkDeviceFaultInfoEXT *pFaultInfo)
     * }
     */
    public static FunctionDescriptor vkGetDeviceFaultInfoEXT$descriptor() {
        return vkGetDeviceFaultInfoEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkGetDeviceFaultInfoEXT(VkDevice device, VkDeviceFaultCountsEXT *pFaultCounts, VkDeviceFaultInfoEXT *pFaultInfo)
     * }
     */
    public static MethodHandle vkGetDeviceFaultInfoEXT$handle() {
        return vkGetDeviceFaultInfoEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * VkResult vkGetDeviceFaultInfoEXT(VkDevice device, VkDeviceFaultCountsEXT *pFaultCounts, VkDeviceFaultInfoEXT *pFaultInfo)
     * }
     */
    public static int vkGetDeviceFaultInfoEXT(MemorySegment device, MemorySegment pFaultCounts, MemorySegment pFaultInfo) {
        var mh$ = vkGetDeviceFaultInfoEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetDeviceFaultInfoEXT", device, pFaultCounts, pFaultInfo);
            }
            return (int)mh$.invokeExact(device, pFaultCounts, pFaultInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdSetVertexInputEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdSetVertexInputEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdSetVertexInputEXT(VkCommandBuffer commandBuffer, uint32_t vertexBindingDescriptionCount, const VkVertexInputBindingDescription2EXT *pVertexBindingDescriptions, uint32_t vertexAttributeDescriptionCount, const VkVertexInputAttributeDescription2EXT *pVertexAttributeDescriptions)
     * }
     */
    public static FunctionDescriptor vkCmdSetVertexInputEXT$descriptor() {
        return vkCmdSetVertexInputEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdSetVertexInputEXT(VkCommandBuffer commandBuffer, uint32_t vertexBindingDescriptionCount, const VkVertexInputBindingDescription2EXT *pVertexBindingDescriptions, uint32_t vertexAttributeDescriptionCount, const VkVertexInputAttributeDescription2EXT *pVertexAttributeDescriptions)
     * }
     */
    public static MethodHandle vkCmdSetVertexInputEXT$handle() {
        return vkCmdSetVertexInputEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdSetVertexInputEXT(VkCommandBuffer commandBuffer, uint32_t vertexBindingDescriptionCount, const VkVertexInputBindingDescription2EXT *pVertexBindingDescriptions, uint32_t vertexAttributeDescriptionCount, const VkVertexInputAttributeDescription2EXT *pVertexAttributeDescriptions)
     * }
     */
    public static void vkCmdSetVertexInputEXT(MemorySegment commandBuffer, int vertexBindingDescriptionCount, MemorySegment pVertexBindingDescriptions, int vertexAttributeDescriptionCount, MemorySegment pVertexAttributeDescriptions) {
        var mh$ = vkCmdSetVertexInputEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetVertexInputEXT", commandBuffer, vertexBindingDescriptionCount, pVertexBindingDescriptions, vertexAttributeDescriptionCount, pVertexAttributeDescriptions);
            }
            mh$.invokeExact(commandBuffer, vertexBindingDescriptionCount, pVertexBindingDescriptions, vertexAttributeDescriptionCount, pVertexAttributeDescriptions);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int VK_DEVICE_ADDRESS_BINDING_TYPE_BIND_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkDeviceAddressBindingTypeEXT.VK_DEVICE_ADDRESS_BINDING_TYPE_BIND_EXT = 0
     * }
     */
    public static int VK_DEVICE_ADDRESS_BINDING_TYPE_BIND_EXT() {
        return VK_DEVICE_ADDRESS_BINDING_TYPE_BIND_EXT;
    }
    private static final int VK_DEVICE_ADDRESS_BINDING_TYPE_UNBIND_EXT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkDeviceAddressBindingTypeEXT.VK_DEVICE_ADDRESS_BINDING_TYPE_UNBIND_EXT = 1
     * }
     */
    public static int VK_DEVICE_ADDRESS_BINDING_TYPE_UNBIND_EXT() {
        return VK_DEVICE_ADDRESS_BINDING_TYPE_UNBIND_EXT;
    }
    private static final int VK_DEVICE_ADDRESS_BINDING_TYPE_MAX_ENUM_EXT = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkDeviceAddressBindingTypeEXT.VK_DEVICE_ADDRESS_BINDING_TYPE_MAX_ENUM_EXT = 2147483647
     * }
     */
    public static int VK_DEVICE_ADDRESS_BINDING_TYPE_MAX_ENUM_EXT() {
        return VK_DEVICE_ADDRESS_BINDING_TYPE_MAX_ENUM_EXT;
    }
    private static final int VK_DEVICE_ADDRESS_BINDING_INTERNAL_OBJECT_BIT_EXT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkDeviceAddressBindingFlagBitsEXT.VK_DEVICE_ADDRESS_BINDING_INTERNAL_OBJECT_BIT_EXT = 1
     * }
     */
    public static int VK_DEVICE_ADDRESS_BINDING_INTERNAL_OBJECT_BIT_EXT() {
        return VK_DEVICE_ADDRESS_BINDING_INTERNAL_OBJECT_BIT_EXT;
    }
    private static final int VK_DEVICE_ADDRESS_BINDING_FLAG_BITS_MAX_ENUM_EXT = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkDeviceAddressBindingFlagBitsEXT.VK_DEVICE_ADDRESS_BINDING_FLAG_BITS_MAX_ENUM_EXT = 2147483647
     * }
     */
    public static int VK_DEVICE_ADDRESS_BINDING_FLAG_BITS_MAX_ENUM_EXT() {
        return VK_DEVICE_ADDRESS_BINDING_FLAG_BITS_MAX_ENUM_EXT;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkDeviceAddressBindingFlagsEXT
     * }
     */
    public static final OfInt VkDeviceAddressBindingFlagsEXT = vulkan_h.C_INT;

    private static class vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI(VkDevice device, VkRenderPass renderpass, VkExtent2D *pMaxWorkgroupSize)
     * }
     */
    public static FunctionDescriptor vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI$descriptor() {
        return vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI(VkDevice device, VkRenderPass renderpass, VkExtent2D *pMaxWorkgroupSize)
     * }
     */
    public static MethodHandle vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI$handle() {
        return vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * VkResult vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI(VkDevice device, VkRenderPass renderpass, VkExtent2D *pMaxWorkgroupSize)
     * }
     */
    public static int vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI(MemorySegment device, MemorySegment renderpass, MemorySegment pMaxWorkgroupSize) {
        var mh$ = vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI", device, renderpass, pMaxWorkgroupSize);
            }
            return (int)mh$.invokeExact(device, renderpass, pMaxWorkgroupSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdSubpassShadingHUAWEI {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdSubpassShadingHUAWEI"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdSubpassShadingHUAWEI(VkCommandBuffer commandBuffer)
     * }
     */
    public static FunctionDescriptor vkCmdSubpassShadingHUAWEI$descriptor() {
        return vkCmdSubpassShadingHUAWEI.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdSubpassShadingHUAWEI(VkCommandBuffer commandBuffer)
     * }
     */
    public static MethodHandle vkCmdSubpassShadingHUAWEI$handle() {
        return vkCmdSubpassShadingHUAWEI.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdSubpassShadingHUAWEI(VkCommandBuffer commandBuffer)
     * }
     */
    public static void vkCmdSubpassShadingHUAWEI(MemorySegment commandBuffer) {
        var mh$ = vkCmdSubpassShadingHUAWEI.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSubpassShadingHUAWEI", commandBuffer);
            }
            mh$.invokeExact(commandBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdBindInvocationMaskHUAWEI {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdBindInvocationMaskHUAWEI"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdBindInvocationMaskHUAWEI(VkCommandBuffer commandBuffer, VkImageView imageView, VkImageLayout imageLayout)
     * }
     */
    public static FunctionDescriptor vkCmdBindInvocationMaskHUAWEI$descriptor() {
        return vkCmdBindInvocationMaskHUAWEI.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdBindInvocationMaskHUAWEI(VkCommandBuffer commandBuffer, VkImageView imageView, VkImageLayout imageLayout)
     * }
     */
    public static MethodHandle vkCmdBindInvocationMaskHUAWEI$handle() {
        return vkCmdBindInvocationMaskHUAWEI.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdBindInvocationMaskHUAWEI(VkCommandBuffer commandBuffer, VkImageView imageView, VkImageLayout imageLayout)
     * }
     */
    public static void vkCmdBindInvocationMaskHUAWEI(MemorySegment commandBuffer, MemorySegment imageView, int imageLayout) {
        var mh$ = vkCmdBindInvocationMaskHUAWEI.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdBindInvocationMaskHUAWEI", commandBuffer, imageView, imageLayout);
            }
            mh$.invokeExact(commandBuffer, imageView, imageLayout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef void *VkRemoteAddressNV
     * }
     */
    public static final AddressLayout VkRemoteAddressNV = vulkan_h.C_POINTER;

    private static class vkGetMemoryRemoteAddressNV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkGetMemoryRemoteAddressNV"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkGetMemoryRemoteAddressNV(VkDevice device, const VkMemoryGetRemoteAddressInfoNV *pMemoryGetRemoteAddressInfo, VkRemoteAddressNV *pAddress)
     * }
     */
    public static FunctionDescriptor vkGetMemoryRemoteAddressNV$descriptor() {
        return vkGetMemoryRemoteAddressNV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkGetMemoryRemoteAddressNV(VkDevice device, const VkMemoryGetRemoteAddressInfoNV *pMemoryGetRemoteAddressInfo, VkRemoteAddressNV *pAddress)
     * }
     */
    public static MethodHandle vkGetMemoryRemoteAddressNV$handle() {
        return vkGetMemoryRemoteAddressNV.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * VkResult vkGetMemoryRemoteAddressNV(VkDevice device, const VkMemoryGetRemoteAddressInfoNV *pMemoryGetRemoteAddressInfo, VkRemoteAddressNV *pAddress)
     * }
     */
    public static int vkGetMemoryRemoteAddressNV(MemorySegment device, MemorySegment pMemoryGetRemoteAddressInfo, MemorySegment pAddress) {
        var mh$ = vkGetMemoryRemoteAddressNV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetMemoryRemoteAddressNV", device, pMemoryGetRemoteAddressInfo, pAddress);
            }
            return (int)mh$.invokeExact(device, pMemoryGetRemoteAddressInfo, pAddress);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetPipelinePropertiesEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkGetPipelinePropertiesEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkGetPipelinePropertiesEXT(VkDevice device, const VkPipelineInfoEXT *pPipelineInfo, VkBaseOutStructure *pPipelineProperties)
     * }
     */
    public static FunctionDescriptor vkGetPipelinePropertiesEXT$descriptor() {
        return vkGetPipelinePropertiesEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkGetPipelinePropertiesEXT(VkDevice device, const VkPipelineInfoEXT *pPipelineInfo, VkBaseOutStructure *pPipelineProperties)
     * }
     */
    public static MethodHandle vkGetPipelinePropertiesEXT$handle() {
        return vkGetPipelinePropertiesEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * VkResult vkGetPipelinePropertiesEXT(VkDevice device, const VkPipelineInfoEXT *pPipelineInfo, VkBaseOutStructure *pPipelineProperties)
     * }
     */
    public static int vkGetPipelinePropertiesEXT(MemorySegment device, MemorySegment pPipelineInfo, MemorySegment pPipelineProperties) {
        var mh$ = vkGetPipelinePropertiesEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetPipelinePropertiesEXT", device, pPipelineInfo, pPipelineProperties);
            }
            return (int)mh$.invokeExact(device, pPipelineInfo, pPipelineProperties);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int VK_FRAME_BOUNDARY_FRAME_END_BIT_EXT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkFrameBoundaryFlagBitsEXT.VK_FRAME_BOUNDARY_FRAME_END_BIT_EXT = 1
     * }
     */
    public static int VK_FRAME_BOUNDARY_FRAME_END_BIT_EXT() {
        return VK_FRAME_BOUNDARY_FRAME_END_BIT_EXT;
    }
    private static final int VK_FRAME_BOUNDARY_FLAG_BITS_MAX_ENUM_EXT = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkFrameBoundaryFlagBitsEXT.VK_FRAME_BOUNDARY_FLAG_BITS_MAX_ENUM_EXT = 2147483647
     * }
     */
    public static int VK_FRAME_BOUNDARY_FLAG_BITS_MAX_ENUM_EXT() {
        return VK_FRAME_BOUNDARY_FLAG_BITS_MAX_ENUM_EXT;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkFrameBoundaryFlagsEXT
     * }
     */
    public static final OfInt VkFrameBoundaryFlagsEXT = vulkan_h.C_INT;

    private static class vkCmdSetPatchControlPointsEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdSetPatchControlPointsEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdSetPatchControlPointsEXT(VkCommandBuffer commandBuffer, uint32_t patchControlPoints)
     * }
     */
    public static FunctionDescriptor vkCmdSetPatchControlPointsEXT$descriptor() {
        return vkCmdSetPatchControlPointsEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdSetPatchControlPointsEXT(VkCommandBuffer commandBuffer, uint32_t patchControlPoints)
     * }
     */
    public static MethodHandle vkCmdSetPatchControlPointsEXT$handle() {
        return vkCmdSetPatchControlPointsEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdSetPatchControlPointsEXT(VkCommandBuffer commandBuffer, uint32_t patchControlPoints)
     * }
     */
    public static void vkCmdSetPatchControlPointsEXT(MemorySegment commandBuffer, int patchControlPoints) {
        var mh$ = vkCmdSetPatchControlPointsEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetPatchControlPointsEXT", commandBuffer, patchControlPoints);
            }
            mh$.invokeExact(commandBuffer, patchControlPoints);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdSetRasterizerDiscardEnableEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdSetRasterizerDiscardEnableEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdSetRasterizerDiscardEnableEXT(VkCommandBuffer commandBuffer, VkBool32 rasterizerDiscardEnable)
     * }
     */
    public static FunctionDescriptor vkCmdSetRasterizerDiscardEnableEXT$descriptor() {
        return vkCmdSetRasterizerDiscardEnableEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdSetRasterizerDiscardEnableEXT(VkCommandBuffer commandBuffer, VkBool32 rasterizerDiscardEnable)
     * }
     */
    public static MethodHandle vkCmdSetRasterizerDiscardEnableEXT$handle() {
        return vkCmdSetRasterizerDiscardEnableEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdSetRasterizerDiscardEnableEXT(VkCommandBuffer commandBuffer, VkBool32 rasterizerDiscardEnable)
     * }
     */
    public static void vkCmdSetRasterizerDiscardEnableEXT(MemorySegment commandBuffer, int rasterizerDiscardEnable) {
        var mh$ = vkCmdSetRasterizerDiscardEnableEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetRasterizerDiscardEnableEXT", commandBuffer, rasterizerDiscardEnable);
            }
            mh$.invokeExact(commandBuffer, rasterizerDiscardEnable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdSetDepthBiasEnableEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdSetDepthBiasEnableEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdSetDepthBiasEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthBiasEnable)
     * }
     */
    public static FunctionDescriptor vkCmdSetDepthBiasEnableEXT$descriptor() {
        return vkCmdSetDepthBiasEnableEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdSetDepthBiasEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthBiasEnable)
     * }
     */
    public static MethodHandle vkCmdSetDepthBiasEnableEXT$handle() {
        return vkCmdSetDepthBiasEnableEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdSetDepthBiasEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthBiasEnable)
     * }
     */
    public static void vkCmdSetDepthBiasEnableEXT(MemorySegment commandBuffer, int depthBiasEnable) {
        var mh$ = vkCmdSetDepthBiasEnableEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetDepthBiasEnableEXT", commandBuffer, depthBiasEnable);
            }
            mh$.invokeExact(commandBuffer, depthBiasEnable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdSetLogicOpEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdSetLogicOpEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdSetLogicOpEXT(VkCommandBuffer commandBuffer, VkLogicOp logicOp)
     * }
     */
    public static FunctionDescriptor vkCmdSetLogicOpEXT$descriptor() {
        return vkCmdSetLogicOpEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdSetLogicOpEXT(VkCommandBuffer commandBuffer, VkLogicOp logicOp)
     * }
     */
    public static MethodHandle vkCmdSetLogicOpEXT$handle() {
        return vkCmdSetLogicOpEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdSetLogicOpEXT(VkCommandBuffer commandBuffer, VkLogicOp logicOp)
     * }
     */
    public static void vkCmdSetLogicOpEXT(MemorySegment commandBuffer, int logicOp) {
        var mh$ = vkCmdSetLogicOpEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetLogicOpEXT", commandBuffer, logicOp);
            }
            mh$.invokeExact(commandBuffer, logicOp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdSetPrimitiveRestartEnableEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdSetPrimitiveRestartEnableEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdSetPrimitiveRestartEnableEXT(VkCommandBuffer commandBuffer, VkBool32 primitiveRestartEnable)
     * }
     */
    public static FunctionDescriptor vkCmdSetPrimitiveRestartEnableEXT$descriptor() {
        return vkCmdSetPrimitiveRestartEnableEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdSetPrimitiveRestartEnableEXT(VkCommandBuffer commandBuffer, VkBool32 primitiveRestartEnable)
     * }
     */
    public static MethodHandle vkCmdSetPrimitiveRestartEnableEXT$handle() {
        return vkCmdSetPrimitiveRestartEnableEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdSetPrimitiveRestartEnableEXT(VkCommandBuffer commandBuffer, VkBool32 primitiveRestartEnable)
     * }
     */
    public static void vkCmdSetPrimitiveRestartEnableEXT(MemorySegment commandBuffer, int primitiveRestartEnable) {
        var mh$ = vkCmdSetPrimitiveRestartEnableEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetPrimitiveRestartEnableEXT", commandBuffer, primitiveRestartEnable);
            }
            mh$.invokeExact(commandBuffer, primitiveRestartEnable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdSetColorWriteEnableEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdSetColorWriteEnableEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdSetColorWriteEnableEXT(VkCommandBuffer commandBuffer, uint32_t attachmentCount, const VkBool32 *pColorWriteEnables)
     * }
     */
    public static FunctionDescriptor vkCmdSetColorWriteEnableEXT$descriptor() {
        return vkCmdSetColorWriteEnableEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdSetColorWriteEnableEXT(VkCommandBuffer commandBuffer, uint32_t attachmentCount, const VkBool32 *pColorWriteEnables)
     * }
     */
    public static MethodHandle vkCmdSetColorWriteEnableEXT$handle() {
        return vkCmdSetColorWriteEnableEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdSetColorWriteEnableEXT(VkCommandBuffer commandBuffer, uint32_t attachmentCount, const VkBool32 *pColorWriteEnables)
     * }
     */
    public static void vkCmdSetColorWriteEnableEXT(MemorySegment commandBuffer, int attachmentCount, MemorySegment pColorWriteEnables) {
        var mh$ = vkCmdSetColorWriteEnableEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetColorWriteEnableEXT", commandBuffer, attachmentCount, pColorWriteEnables);
            }
            mh$.invokeExact(commandBuffer, attachmentCount, pColorWriteEnables);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdDrawMultiEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdDrawMultiEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdDrawMultiEXT(VkCommandBuffer commandBuffer, uint32_t drawCount, const VkMultiDrawInfoEXT *pVertexInfo, uint32_t instanceCount, uint32_t firstInstance, uint32_t stride)
     * }
     */
    public static FunctionDescriptor vkCmdDrawMultiEXT$descriptor() {
        return vkCmdDrawMultiEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdDrawMultiEXT(VkCommandBuffer commandBuffer, uint32_t drawCount, const VkMultiDrawInfoEXT *pVertexInfo, uint32_t instanceCount, uint32_t firstInstance, uint32_t stride)
     * }
     */
    public static MethodHandle vkCmdDrawMultiEXT$handle() {
        return vkCmdDrawMultiEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdDrawMultiEXT(VkCommandBuffer commandBuffer, uint32_t drawCount, const VkMultiDrawInfoEXT *pVertexInfo, uint32_t instanceCount, uint32_t firstInstance, uint32_t stride)
     * }
     */
    public static void vkCmdDrawMultiEXT(MemorySegment commandBuffer, int drawCount, MemorySegment pVertexInfo, int instanceCount, int firstInstance, int stride) {
        var mh$ = vkCmdDrawMultiEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdDrawMultiEXT", commandBuffer, drawCount, pVertexInfo, instanceCount, firstInstance, stride);
            }
            mh$.invokeExact(commandBuffer, drawCount, pVertexInfo, instanceCount, firstInstance, stride);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdDrawMultiIndexedEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdDrawMultiIndexedEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdDrawMultiIndexedEXT(VkCommandBuffer commandBuffer, uint32_t drawCount, const VkMultiDrawIndexedInfoEXT *pIndexInfo, uint32_t instanceCount, uint32_t firstInstance, uint32_t stride, const int32_t *pVertexOffset)
     * }
     */
    public static FunctionDescriptor vkCmdDrawMultiIndexedEXT$descriptor() {
        return vkCmdDrawMultiIndexedEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdDrawMultiIndexedEXT(VkCommandBuffer commandBuffer, uint32_t drawCount, const VkMultiDrawIndexedInfoEXT *pIndexInfo, uint32_t instanceCount, uint32_t firstInstance, uint32_t stride, const int32_t *pVertexOffset)
     * }
     */
    public static MethodHandle vkCmdDrawMultiIndexedEXT$handle() {
        return vkCmdDrawMultiIndexedEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdDrawMultiIndexedEXT(VkCommandBuffer commandBuffer, uint32_t drawCount, const VkMultiDrawIndexedInfoEXT *pIndexInfo, uint32_t instanceCount, uint32_t firstInstance, uint32_t stride, const int32_t *pVertexOffset)
     * }
     */
    public static void vkCmdDrawMultiIndexedEXT(MemorySegment commandBuffer, int drawCount, MemorySegment pIndexInfo, int instanceCount, int firstInstance, int stride, MemorySegment pVertexOffset) {
        var mh$ = vkCmdDrawMultiIndexedEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdDrawMultiIndexedEXT", commandBuffer, drawCount, pIndexInfo, instanceCount, firstInstance, stride, pVertexOffset);
            }
            mh$.invokeExact(commandBuffer, drawCount, pIndexInfo, instanceCount, firstInstance, stride, pVertexOffset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct VkMicromapEXT_T *VkMicromapEXT
     * }
     */
    public static final AddressLayout VkMicromapEXT = vulkan_h.C_POINTER;
    private static final int VK_MICROMAP_TYPE_OPACITY_MICROMAP_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkMicromapTypeEXT.VK_MICROMAP_TYPE_OPACITY_MICROMAP_EXT = 0
     * }
     */
    public static int VK_MICROMAP_TYPE_OPACITY_MICROMAP_EXT() {
        return VK_MICROMAP_TYPE_OPACITY_MICROMAP_EXT;
    }
    private static final int VK_MICROMAP_TYPE_MAX_ENUM_EXT = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkMicromapTypeEXT.VK_MICROMAP_TYPE_MAX_ENUM_EXT = 2147483647
     * }
     */
    public static int VK_MICROMAP_TYPE_MAX_ENUM_EXT() {
        return VK_MICROMAP_TYPE_MAX_ENUM_EXT;
    }
    private static final int VK_BUILD_MICROMAP_MODE_BUILD_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkBuildMicromapModeEXT.VK_BUILD_MICROMAP_MODE_BUILD_EXT = 0
     * }
     */
    public static int VK_BUILD_MICROMAP_MODE_BUILD_EXT() {
        return VK_BUILD_MICROMAP_MODE_BUILD_EXT;
    }
    private static final int VK_BUILD_MICROMAP_MODE_MAX_ENUM_EXT = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkBuildMicromapModeEXT.VK_BUILD_MICROMAP_MODE_MAX_ENUM_EXT = 2147483647
     * }
     */
    public static int VK_BUILD_MICROMAP_MODE_MAX_ENUM_EXT() {
        return VK_BUILD_MICROMAP_MODE_MAX_ENUM_EXT;
    }
    private static final int VK_COPY_MICROMAP_MODE_CLONE_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkCopyMicromapModeEXT.VK_COPY_MICROMAP_MODE_CLONE_EXT = 0
     * }
     */
    public static int VK_COPY_MICROMAP_MODE_CLONE_EXT() {
        return VK_COPY_MICROMAP_MODE_CLONE_EXT;
    }
    private static final int VK_COPY_MICROMAP_MODE_SERIALIZE_EXT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkCopyMicromapModeEXT.VK_COPY_MICROMAP_MODE_SERIALIZE_EXT = 1
     * }
     */
    public static int VK_COPY_MICROMAP_MODE_SERIALIZE_EXT() {
        return VK_COPY_MICROMAP_MODE_SERIALIZE_EXT;
    }
    private static final int VK_COPY_MICROMAP_MODE_DESERIALIZE_EXT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkCopyMicromapModeEXT.VK_COPY_MICROMAP_MODE_DESERIALIZE_EXT = 2
     * }
     */
    public static int VK_COPY_MICROMAP_MODE_DESERIALIZE_EXT() {
        return VK_COPY_MICROMAP_MODE_DESERIALIZE_EXT;
    }
    private static final int VK_COPY_MICROMAP_MODE_COMPACT_EXT = (int)3L;
    /**
     * {@snippet lang=c :
     * enum VkCopyMicromapModeEXT.VK_COPY_MICROMAP_MODE_COMPACT_EXT = 3
     * }
     */
    public static int VK_COPY_MICROMAP_MODE_COMPACT_EXT() {
        return VK_COPY_MICROMAP_MODE_COMPACT_EXT;
    }
    private static final int VK_COPY_MICROMAP_MODE_MAX_ENUM_EXT = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkCopyMicromapModeEXT.VK_COPY_MICROMAP_MODE_MAX_ENUM_EXT = 2147483647
     * }
     */
    public static int VK_COPY_MICROMAP_MODE_MAX_ENUM_EXT() {
        return VK_COPY_MICROMAP_MODE_MAX_ENUM_EXT;
    }
    private static final int VK_OPACITY_MICROMAP_FORMAT_2_STATE_EXT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkOpacityMicromapFormatEXT.VK_OPACITY_MICROMAP_FORMAT_2_STATE_EXT = 1
     * }
     */
    public static int VK_OPACITY_MICROMAP_FORMAT_2_STATE_EXT() {
        return VK_OPACITY_MICROMAP_FORMAT_2_STATE_EXT;
    }
    private static final int VK_OPACITY_MICROMAP_FORMAT_4_STATE_EXT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkOpacityMicromapFormatEXT.VK_OPACITY_MICROMAP_FORMAT_4_STATE_EXT = 2
     * }
     */
    public static int VK_OPACITY_MICROMAP_FORMAT_4_STATE_EXT() {
        return VK_OPACITY_MICROMAP_FORMAT_4_STATE_EXT;
    }
    private static final int VK_OPACITY_MICROMAP_FORMAT_MAX_ENUM_EXT = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkOpacityMicromapFormatEXT.VK_OPACITY_MICROMAP_FORMAT_MAX_ENUM_EXT = 2147483647
     * }
     */
    public static int VK_OPACITY_MICROMAP_FORMAT_MAX_ENUM_EXT() {
        return VK_OPACITY_MICROMAP_FORMAT_MAX_ENUM_EXT;
    }
    private static final int VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_TRANSPARENT_EXT = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum VkOpacityMicromapSpecialIndexEXT.VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_TRANSPARENT_EXT = -1
     * }
     */
    public static int VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_TRANSPARENT_EXT() {
        return VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_TRANSPARENT_EXT;
    }
    private static final int VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_OPAQUE_EXT = (int)-2L;
    /**
     * {@snippet lang=c :
     * enum VkOpacityMicromapSpecialIndexEXT.VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_OPAQUE_EXT = -2
     * }
     */
    public static int VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_OPAQUE_EXT() {
        return VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_OPAQUE_EXT;
    }
    private static final int VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_UNKNOWN_TRANSPARENT_EXT = (int)-3L;
    /**
     * {@snippet lang=c :
     * enum VkOpacityMicromapSpecialIndexEXT.VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_UNKNOWN_TRANSPARENT_EXT = -3
     * }
     */
    public static int VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_UNKNOWN_TRANSPARENT_EXT() {
        return VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_UNKNOWN_TRANSPARENT_EXT;
    }
    private static final int VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_UNKNOWN_OPAQUE_EXT = (int)-4L;
    /**
     * {@snippet lang=c :
     * enum VkOpacityMicromapSpecialIndexEXT.VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_UNKNOWN_OPAQUE_EXT = -4
     * }
     */
    public static int VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_UNKNOWN_OPAQUE_EXT() {
        return VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_UNKNOWN_OPAQUE_EXT;
    }
    private static final int VK_OPACITY_MICROMAP_SPECIAL_INDEX_MAX_ENUM_EXT = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkOpacityMicromapSpecialIndexEXT.VK_OPACITY_MICROMAP_SPECIAL_INDEX_MAX_ENUM_EXT = 2147483647
     * }
     */
    public static int VK_OPACITY_MICROMAP_SPECIAL_INDEX_MAX_ENUM_EXT() {
        return VK_OPACITY_MICROMAP_SPECIAL_INDEX_MAX_ENUM_EXT;
    }
    private static final int VK_ACCELERATION_STRUCTURE_COMPATIBILITY_COMPATIBLE_KHR = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkAccelerationStructureCompatibilityKHR.VK_ACCELERATION_STRUCTURE_COMPATIBILITY_COMPATIBLE_KHR = 0
     * }
     */
    public static int VK_ACCELERATION_STRUCTURE_COMPATIBILITY_COMPATIBLE_KHR() {
        return VK_ACCELERATION_STRUCTURE_COMPATIBILITY_COMPATIBLE_KHR;
    }
    private static final int VK_ACCELERATION_STRUCTURE_COMPATIBILITY_INCOMPATIBLE_KHR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkAccelerationStructureCompatibilityKHR.VK_ACCELERATION_STRUCTURE_COMPATIBILITY_INCOMPATIBLE_KHR = 1
     * }
     */
    public static int VK_ACCELERATION_STRUCTURE_COMPATIBILITY_INCOMPATIBLE_KHR() {
        return VK_ACCELERATION_STRUCTURE_COMPATIBILITY_INCOMPATIBLE_KHR;
    }
    private static final int VK_ACCELERATION_STRUCTURE_COMPATIBILITY_MAX_ENUM_KHR = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkAccelerationStructureCompatibilityKHR.VK_ACCELERATION_STRUCTURE_COMPATIBILITY_MAX_ENUM_KHR = 2147483647
     * }
     */
    public static int VK_ACCELERATION_STRUCTURE_COMPATIBILITY_MAX_ENUM_KHR() {
        return VK_ACCELERATION_STRUCTURE_COMPATIBILITY_MAX_ENUM_KHR;
    }
    private static final int VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_KHR = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkAccelerationStructureBuildTypeKHR.VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_KHR = 0
     * }
     */
    public static int VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_KHR() {
        return VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_KHR;
    }
    private static final int VK_ACCELERATION_STRUCTURE_BUILD_TYPE_DEVICE_KHR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkAccelerationStructureBuildTypeKHR.VK_ACCELERATION_STRUCTURE_BUILD_TYPE_DEVICE_KHR = 1
     * }
     */
    public static int VK_ACCELERATION_STRUCTURE_BUILD_TYPE_DEVICE_KHR() {
        return VK_ACCELERATION_STRUCTURE_BUILD_TYPE_DEVICE_KHR;
    }
    private static final int VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_OR_DEVICE_KHR = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkAccelerationStructureBuildTypeKHR.VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_OR_DEVICE_KHR = 2
     * }
     */
    public static int VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_OR_DEVICE_KHR() {
        return VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_OR_DEVICE_KHR;
    }
    private static final int VK_ACCELERATION_STRUCTURE_BUILD_TYPE_MAX_ENUM_KHR = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkAccelerationStructureBuildTypeKHR.VK_ACCELERATION_STRUCTURE_BUILD_TYPE_MAX_ENUM_KHR = 2147483647
     * }
     */
    public static int VK_ACCELERATION_STRUCTURE_BUILD_TYPE_MAX_ENUM_KHR() {
        return VK_ACCELERATION_STRUCTURE_BUILD_TYPE_MAX_ENUM_KHR;
    }
    private static final int VK_BUILD_MICROMAP_PREFER_FAST_TRACE_BIT_EXT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkBuildMicromapFlagBitsEXT.VK_BUILD_MICROMAP_PREFER_FAST_TRACE_BIT_EXT = 1
     * }
     */
    public static int VK_BUILD_MICROMAP_PREFER_FAST_TRACE_BIT_EXT() {
        return VK_BUILD_MICROMAP_PREFER_FAST_TRACE_BIT_EXT;
    }
    private static final int VK_BUILD_MICROMAP_PREFER_FAST_BUILD_BIT_EXT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkBuildMicromapFlagBitsEXT.VK_BUILD_MICROMAP_PREFER_FAST_BUILD_BIT_EXT = 2
     * }
     */
    public static int VK_BUILD_MICROMAP_PREFER_FAST_BUILD_BIT_EXT() {
        return VK_BUILD_MICROMAP_PREFER_FAST_BUILD_BIT_EXT;
    }
    private static final int VK_BUILD_MICROMAP_ALLOW_COMPACTION_BIT_EXT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkBuildMicromapFlagBitsEXT.VK_BUILD_MICROMAP_ALLOW_COMPACTION_BIT_EXT = 4
     * }
     */
    public static int VK_BUILD_MICROMAP_ALLOW_COMPACTION_BIT_EXT() {
        return VK_BUILD_MICROMAP_ALLOW_COMPACTION_BIT_EXT;
    }
    private static final int VK_BUILD_MICROMAP_FLAG_BITS_MAX_ENUM_EXT = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkBuildMicromapFlagBitsEXT.VK_BUILD_MICROMAP_FLAG_BITS_MAX_ENUM_EXT = 2147483647
     * }
     */
    public static int VK_BUILD_MICROMAP_FLAG_BITS_MAX_ENUM_EXT() {
        return VK_BUILD_MICROMAP_FLAG_BITS_MAX_ENUM_EXT;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkBuildMicromapFlagsEXT
     * }
     */
    public static final OfInt VkBuildMicromapFlagsEXT = vulkan_h.C_INT;
    private static final int VK_MICROMAP_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkMicromapCreateFlagBitsEXT.VK_MICROMAP_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT = 1
     * }
     */
    public static int VK_MICROMAP_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT() {
        return VK_MICROMAP_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT;
    }
    private static final int VK_MICROMAP_CREATE_FLAG_BITS_MAX_ENUM_EXT = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkMicromapCreateFlagBitsEXT.VK_MICROMAP_CREATE_FLAG_BITS_MAX_ENUM_EXT = 2147483647
     * }
     */
    public static int VK_MICROMAP_CREATE_FLAG_BITS_MAX_ENUM_EXT() {
        return VK_MICROMAP_CREATE_FLAG_BITS_MAX_ENUM_EXT;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkMicromapCreateFlagsEXT
     * }
     */
    public static final OfInt VkMicromapCreateFlagsEXT = vulkan_h.C_INT;

    private static class vkCreateMicromapEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCreateMicromapEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkCreateMicromapEXT(VkDevice device, const VkMicromapCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkMicromapEXT *pMicromap)
     * }
     */
    public static FunctionDescriptor vkCreateMicromapEXT$descriptor() {
        return vkCreateMicromapEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkCreateMicromapEXT(VkDevice device, const VkMicromapCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkMicromapEXT *pMicromap)
     * }
     */
    public static MethodHandle vkCreateMicromapEXT$handle() {
        return vkCreateMicromapEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * VkResult vkCreateMicromapEXT(VkDevice device, const VkMicromapCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkMicromapEXT *pMicromap)
     * }
     */
    public static int vkCreateMicromapEXT(MemorySegment device, MemorySegment pCreateInfo, MemorySegment pAllocator, MemorySegment pMicromap) {
        var mh$ = vkCreateMicromapEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCreateMicromapEXT", device, pCreateInfo, pAllocator, pMicromap);
            }
            return (int)mh$.invokeExact(device, pCreateInfo, pAllocator, pMicromap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkDestroyMicromapEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkDestroyMicromapEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkDestroyMicromapEXT(VkDevice device, VkMicromapEXT micromap, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static FunctionDescriptor vkDestroyMicromapEXT$descriptor() {
        return vkDestroyMicromapEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkDestroyMicromapEXT(VkDevice device, VkMicromapEXT micromap, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static MethodHandle vkDestroyMicromapEXT$handle() {
        return vkDestroyMicromapEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkDestroyMicromapEXT(VkDevice device, VkMicromapEXT micromap, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static void vkDestroyMicromapEXT(MemorySegment device, MemorySegment micromap, MemorySegment pAllocator) {
        var mh$ = vkDestroyMicromapEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkDestroyMicromapEXT", device, micromap, pAllocator);
            }
            mh$.invokeExact(device, micromap, pAllocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdBuildMicromapsEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdBuildMicromapsEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdBuildMicromapsEXT(VkCommandBuffer commandBuffer, uint32_t infoCount, const VkMicromapBuildInfoEXT *pInfos)
     * }
     */
    public static FunctionDescriptor vkCmdBuildMicromapsEXT$descriptor() {
        return vkCmdBuildMicromapsEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdBuildMicromapsEXT(VkCommandBuffer commandBuffer, uint32_t infoCount, const VkMicromapBuildInfoEXT *pInfos)
     * }
     */
    public static MethodHandle vkCmdBuildMicromapsEXT$handle() {
        return vkCmdBuildMicromapsEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdBuildMicromapsEXT(VkCommandBuffer commandBuffer, uint32_t infoCount, const VkMicromapBuildInfoEXT *pInfos)
     * }
     */
    public static void vkCmdBuildMicromapsEXT(MemorySegment commandBuffer, int infoCount, MemorySegment pInfos) {
        var mh$ = vkCmdBuildMicromapsEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdBuildMicromapsEXT", commandBuffer, infoCount, pInfos);
            }
            mh$.invokeExact(commandBuffer, infoCount, pInfos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkBuildMicromapsEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkBuildMicromapsEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkBuildMicromapsEXT(VkDevice device, VkDeferredOperationKHR deferredOperation, uint32_t infoCount, const VkMicromapBuildInfoEXT *pInfos)
     * }
     */
    public static FunctionDescriptor vkBuildMicromapsEXT$descriptor() {
        return vkBuildMicromapsEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkBuildMicromapsEXT(VkDevice device, VkDeferredOperationKHR deferredOperation, uint32_t infoCount, const VkMicromapBuildInfoEXT *pInfos)
     * }
     */
    public static MethodHandle vkBuildMicromapsEXT$handle() {
        return vkBuildMicromapsEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * VkResult vkBuildMicromapsEXT(VkDevice device, VkDeferredOperationKHR deferredOperation, uint32_t infoCount, const VkMicromapBuildInfoEXT *pInfos)
     * }
     */
    public static int vkBuildMicromapsEXT(MemorySegment device, MemorySegment deferredOperation, int infoCount, MemorySegment pInfos) {
        var mh$ = vkBuildMicromapsEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkBuildMicromapsEXT", device, deferredOperation, infoCount, pInfos);
            }
            return (int)mh$.invokeExact(device, deferredOperation, infoCount, pInfos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCopyMicromapEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCopyMicromapEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkCopyMicromapEXT(VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyMicromapInfoEXT *pInfo)
     * }
     */
    public static FunctionDescriptor vkCopyMicromapEXT$descriptor() {
        return vkCopyMicromapEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkCopyMicromapEXT(VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyMicromapInfoEXT *pInfo)
     * }
     */
    public static MethodHandle vkCopyMicromapEXT$handle() {
        return vkCopyMicromapEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * VkResult vkCopyMicromapEXT(VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyMicromapInfoEXT *pInfo)
     * }
     */
    public static int vkCopyMicromapEXT(MemorySegment device, MemorySegment deferredOperation, MemorySegment pInfo) {
        var mh$ = vkCopyMicromapEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCopyMicromapEXT", device, deferredOperation, pInfo);
            }
            return (int)mh$.invokeExact(device, deferredOperation, pInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCopyMicromapToMemoryEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCopyMicromapToMemoryEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkCopyMicromapToMemoryEXT(VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyMicromapToMemoryInfoEXT *pInfo)
     * }
     */
    public static FunctionDescriptor vkCopyMicromapToMemoryEXT$descriptor() {
        return vkCopyMicromapToMemoryEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkCopyMicromapToMemoryEXT(VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyMicromapToMemoryInfoEXT *pInfo)
     * }
     */
    public static MethodHandle vkCopyMicromapToMemoryEXT$handle() {
        return vkCopyMicromapToMemoryEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * VkResult vkCopyMicromapToMemoryEXT(VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyMicromapToMemoryInfoEXT *pInfo)
     * }
     */
    public static int vkCopyMicromapToMemoryEXT(MemorySegment device, MemorySegment deferredOperation, MemorySegment pInfo) {
        var mh$ = vkCopyMicromapToMemoryEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCopyMicromapToMemoryEXT", device, deferredOperation, pInfo);
            }
            return (int)mh$.invokeExact(device, deferredOperation, pInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCopyMemoryToMicromapEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCopyMemoryToMicromapEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkCopyMemoryToMicromapEXT(VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyMemoryToMicromapInfoEXT *pInfo)
     * }
     */
    public static FunctionDescriptor vkCopyMemoryToMicromapEXT$descriptor() {
        return vkCopyMemoryToMicromapEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkCopyMemoryToMicromapEXT(VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyMemoryToMicromapInfoEXT *pInfo)
     * }
     */
    public static MethodHandle vkCopyMemoryToMicromapEXT$handle() {
        return vkCopyMemoryToMicromapEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * VkResult vkCopyMemoryToMicromapEXT(VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyMemoryToMicromapInfoEXT *pInfo)
     * }
     */
    public static int vkCopyMemoryToMicromapEXT(MemorySegment device, MemorySegment deferredOperation, MemorySegment pInfo) {
        var mh$ = vkCopyMemoryToMicromapEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCopyMemoryToMicromapEXT", device, deferredOperation, pInfo);
            }
            return (int)mh$.invokeExact(device, deferredOperation, pInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkWriteMicromapsPropertiesEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_LONG,
            vulkan_h.C_POINTER,
            vulkan_h.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkWriteMicromapsPropertiesEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkWriteMicromapsPropertiesEXT(VkDevice device, uint32_t micromapCount, const VkMicromapEXT *pMicromaps, VkQueryType queryType, size_t dataSize, void *pData, size_t stride)
     * }
     */
    public static FunctionDescriptor vkWriteMicromapsPropertiesEXT$descriptor() {
        return vkWriteMicromapsPropertiesEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkWriteMicromapsPropertiesEXT(VkDevice device, uint32_t micromapCount, const VkMicromapEXT *pMicromaps, VkQueryType queryType, size_t dataSize, void *pData, size_t stride)
     * }
     */
    public static MethodHandle vkWriteMicromapsPropertiesEXT$handle() {
        return vkWriteMicromapsPropertiesEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * VkResult vkWriteMicromapsPropertiesEXT(VkDevice device, uint32_t micromapCount, const VkMicromapEXT *pMicromaps, VkQueryType queryType, size_t dataSize, void *pData, size_t stride)
     * }
     */
    public static int vkWriteMicromapsPropertiesEXT(MemorySegment device, int micromapCount, MemorySegment pMicromaps, int queryType, long dataSize, MemorySegment pData, long stride) {
        var mh$ = vkWriteMicromapsPropertiesEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkWriteMicromapsPropertiesEXT", device, micromapCount, pMicromaps, queryType, dataSize, pData, stride);
            }
            return (int)mh$.invokeExact(device, micromapCount, pMicromaps, queryType, dataSize, pData, stride);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdCopyMicromapEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdCopyMicromapEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdCopyMicromapEXT(VkCommandBuffer commandBuffer, const VkCopyMicromapInfoEXT *pInfo)
     * }
     */
    public static FunctionDescriptor vkCmdCopyMicromapEXT$descriptor() {
        return vkCmdCopyMicromapEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdCopyMicromapEXT(VkCommandBuffer commandBuffer, const VkCopyMicromapInfoEXT *pInfo)
     * }
     */
    public static MethodHandle vkCmdCopyMicromapEXT$handle() {
        return vkCmdCopyMicromapEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdCopyMicromapEXT(VkCommandBuffer commandBuffer, const VkCopyMicromapInfoEXT *pInfo)
     * }
     */
    public static void vkCmdCopyMicromapEXT(MemorySegment commandBuffer, MemorySegment pInfo) {
        var mh$ = vkCmdCopyMicromapEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdCopyMicromapEXT", commandBuffer, pInfo);
            }
            mh$.invokeExact(commandBuffer, pInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdCopyMicromapToMemoryEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdCopyMicromapToMemoryEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdCopyMicromapToMemoryEXT(VkCommandBuffer commandBuffer, const VkCopyMicromapToMemoryInfoEXT *pInfo)
     * }
     */
    public static FunctionDescriptor vkCmdCopyMicromapToMemoryEXT$descriptor() {
        return vkCmdCopyMicromapToMemoryEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdCopyMicromapToMemoryEXT(VkCommandBuffer commandBuffer, const VkCopyMicromapToMemoryInfoEXT *pInfo)
     * }
     */
    public static MethodHandle vkCmdCopyMicromapToMemoryEXT$handle() {
        return vkCmdCopyMicromapToMemoryEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdCopyMicromapToMemoryEXT(VkCommandBuffer commandBuffer, const VkCopyMicromapToMemoryInfoEXT *pInfo)
     * }
     */
    public static void vkCmdCopyMicromapToMemoryEXT(MemorySegment commandBuffer, MemorySegment pInfo) {
        var mh$ = vkCmdCopyMicromapToMemoryEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdCopyMicromapToMemoryEXT", commandBuffer, pInfo);
            }
            mh$.invokeExact(commandBuffer, pInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdCopyMemoryToMicromapEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdCopyMemoryToMicromapEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdCopyMemoryToMicromapEXT(VkCommandBuffer commandBuffer, const VkCopyMemoryToMicromapInfoEXT *pInfo)
     * }
     */
    public static FunctionDescriptor vkCmdCopyMemoryToMicromapEXT$descriptor() {
        return vkCmdCopyMemoryToMicromapEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdCopyMemoryToMicromapEXT(VkCommandBuffer commandBuffer, const VkCopyMemoryToMicromapInfoEXT *pInfo)
     * }
     */
    public static MethodHandle vkCmdCopyMemoryToMicromapEXT$handle() {
        return vkCmdCopyMemoryToMicromapEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdCopyMemoryToMicromapEXT(VkCommandBuffer commandBuffer, const VkCopyMemoryToMicromapInfoEXT *pInfo)
     * }
     */
    public static void vkCmdCopyMemoryToMicromapEXT(MemorySegment commandBuffer, MemorySegment pInfo) {
        var mh$ = vkCmdCopyMemoryToMicromapEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdCopyMemoryToMicromapEXT", commandBuffer, pInfo);
            }
            mh$.invokeExact(commandBuffer, pInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdWriteMicromapsPropertiesEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdWriteMicromapsPropertiesEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdWriteMicromapsPropertiesEXT(VkCommandBuffer commandBuffer, uint32_t micromapCount, const VkMicromapEXT *pMicromaps, VkQueryType queryType, VkQueryPool queryPool, uint32_t firstQuery)
     * }
     */
    public static FunctionDescriptor vkCmdWriteMicromapsPropertiesEXT$descriptor() {
        return vkCmdWriteMicromapsPropertiesEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdWriteMicromapsPropertiesEXT(VkCommandBuffer commandBuffer, uint32_t micromapCount, const VkMicromapEXT *pMicromaps, VkQueryType queryType, VkQueryPool queryPool, uint32_t firstQuery)
     * }
     */
    public static MethodHandle vkCmdWriteMicromapsPropertiesEXT$handle() {
        return vkCmdWriteMicromapsPropertiesEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdWriteMicromapsPropertiesEXT(VkCommandBuffer commandBuffer, uint32_t micromapCount, const VkMicromapEXT *pMicromaps, VkQueryType queryType, VkQueryPool queryPool, uint32_t firstQuery)
     * }
     */
    public static void vkCmdWriteMicromapsPropertiesEXT(MemorySegment commandBuffer, int micromapCount, MemorySegment pMicromaps, int queryType, MemorySegment queryPool, int firstQuery) {
        var mh$ = vkCmdWriteMicromapsPropertiesEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdWriteMicromapsPropertiesEXT", commandBuffer, micromapCount, pMicromaps, queryType, queryPool, firstQuery);
            }
            mh$.invokeExact(commandBuffer, micromapCount, pMicromaps, queryType, queryPool, firstQuery);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetDeviceMicromapCompatibilityEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkGetDeviceMicromapCompatibilityEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkGetDeviceMicromapCompatibilityEXT(VkDevice device, const VkMicromapVersionInfoEXT *pVersionInfo, VkAccelerationStructureCompatibilityKHR *pCompatibility)
     * }
     */
    public static FunctionDescriptor vkGetDeviceMicromapCompatibilityEXT$descriptor() {
        return vkGetDeviceMicromapCompatibilityEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkGetDeviceMicromapCompatibilityEXT(VkDevice device, const VkMicromapVersionInfoEXT *pVersionInfo, VkAccelerationStructureCompatibilityKHR *pCompatibility)
     * }
     */
    public static MethodHandle vkGetDeviceMicromapCompatibilityEXT$handle() {
        return vkGetDeviceMicromapCompatibilityEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkGetDeviceMicromapCompatibilityEXT(VkDevice device, const VkMicromapVersionInfoEXT *pVersionInfo, VkAccelerationStructureCompatibilityKHR *pCompatibility)
     * }
     */
    public static void vkGetDeviceMicromapCompatibilityEXT(MemorySegment device, MemorySegment pVersionInfo, MemorySegment pCompatibility) {
        var mh$ = vkGetDeviceMicromapCompatibilityEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetDeviceMicromapCompatibilityEXT", device, pVersionInfo, pCompatibility);
            }
            mh$.invokeExact(device, pVersionInfo, pCompatibility);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetMicromapBuildSizesEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkGetMicromapBuildSizesEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkGetMicromapBuildSizesEXT(VkDevice device, VkAccelerationStructureBuildTypeKHR buildType, const VkMicromapBuildInfoEXT *pBuildInfo, VkMicromapBuildSizesInfoEXT *pSizeInfo)
     * }
     */
    public static FunctionDescriptor vkGetMicromapBuildSizesEXT$descriptor() {
        return vkGetMicromapBuildSizesEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkGetMicromapBuildSizesEXT(VkDevice device, VkAccelerationStructureBuildTypeKHR buildType, const VkMicromapBuildInfoEXT *pBuildInfo, VkMicromapBuildSizesInfoEXT *pSizeInfo)
     * }
     */
    public static MethodHandle vkGetMicromapBuildSizesEXT$handle() {
        return vkGetMicromapBuildSizesEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkGetMicromapBuildSizesEXT(VkDevice device, VkAccelerationStructureBuildTypeKHR buildType, const VkMicromapBuildInfoEXT *pBuildInfo, VkMicromapBuildSizesInfoEXT *pSizeInfo)
     * }
     */
    public static void vkGetMicromapBuildSizesEXT(MemorySegment device, int buildType, MemorySegment pBuildInfo, MemorySegment pSizeInfo) {
        var mh$ = vkGetMicromapBuildSizesEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetMicromapBuildSizesEXT", device, buildType, pBuildInfo, pSizeInfo);
            }
            mh$.invokeExact(device, buildType, pBuildInfo, pSizeInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdDrawClusterHUAWEI {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdDrawClusterHUAWEI"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdDrawClusterHUAWEI(VkCommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ)
     * }
     */
    public static FunctionDescriptor vkCmdDrawClusterHUAWEI$descriptor() {
        return vkCmdDrawClusterHUAWEI.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdDrawClusterHUAWEI(VkCommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ)
     * }
     */
    public static MethodHandle vkCmdDrawClusterHUAWEI$handle() {
        return vkCmdDrawClusterHUAWEI.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdDrawClusterHUAWEI(VkCommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ)
     * }
     */
    public static void vkCmdDrawClusterHUAWEI(MemorySegment commandBuffer, int groupCountX, int groupCountY, int groupCountZ) {
        var mh$ = vkCmdDrawClusterHUAWEI.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdDrawClusterHUAWEI", commandBuffer, groupCountX, groupCountY, groupCountZ);
            }
            mh$.invokeExact(commandBuffer, groupCountX, groupCountY, groupCountZ);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdDrawClusterIndirectHUAWEI {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdDrawClusterIndirectHUAWEI"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdDrawClusterIndirectHUAWEI(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset)
     * }
     */
    public static FunctionDescriptor vkCmdDrawClusterIndirectHUAWEI$descriptor() {
        return vkCmdDrawClusterIndirectHUAWEI.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdDrawClusterIndirectHUAWEI(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset)
     * }
     */
    public static MethodHandle vkCmdDrawClusterIndirectHUAWEI$handle() {
        return vkCmdDrawClusterIndirectHUAWEI.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdDrawClusterIndirectHUAWEI(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset)
     * }
     */
    public static void vkCmdDrawClusterIndirectHUAWEI(MemorySegment commandBuffer, MemorySegment buffer, long offset) {
        var mh$ = vkCmdDrawClusterIndirectHUAWEI.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdDrawClusterIndirectHUAWEI", commandBuffer, buffer, offset);
            }
            mh$.invokeExact(commandBuffer, buffer, offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkSetDeviceMemoryPriorityEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkSetDeviceMemoryPriorityEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkSetDeviceMemoryPriorityEXT(VkDevice device, VkDeviceMemory memory, float priority)
     * }
     */
    public static FunctionDescriptor vkSetDeviceMemoryPriorityEXT$descriptor() {
        return vkSetDeviceMemoryPriorityEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkSetDeviceMemoryPriorityEXT(VkDevice device, VkDeviceMemory memory, float priority)
     * }
     */
    public static MethodHandle vkSetDeviceMemoryPriorityEXT$handle() {
        return vkSetDeviceMemoryPriorityEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkSetDeviceMemoryPriorityEXT(VkDevice device, VkDeviceMemory memory, float priority)
     * }
     */
    public static void vkSetDeviceMemoryPriorityEXT(MemorySegment device, MemorySegment memory, float priority) {
        var mh$ = vkSetDeviceMemoryPriorityEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkSetDeviceMemoryPriorityEXT", device, memory, priority);
            }
            mh$.invokeExact(device, memory, priority);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags64 VkPhysicalDeviceSchedulingControlsFlagsARM
     * }
     */
    public static final OfLong VkPhysicalDeviceSchedulingControlsFlagsARM = vulkan_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef VkFlags64 VkPhysicalDeviceSchedulingControlsFlagBitsARM
     * }
     */
    public static final OfLong VkPhysicalDeviceSchedulingControlsFlagBitsARM = vulkan_h.C_LONG_LONG;

    private static class vkGetDescriptorSetLayoutHostMappingInfoVALVE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkGetDescriptorSetLayoutHostMappingInfoVALVE"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkGetDescriptorSetLayoutHostMappingInfoVALVE(VkDevice device, const VkDescriptorSetBindingReferenceVALVE *pBindingReference, VkDescriptorSetLayoutHostMappingInfoVALVE *pHostMapping)
     * }
     */
    public static FunctionDescriptor vkGetDescriptorSetLayoutHostMappingInfoVALVE$descriptor() {
        return vkGetDescriptorSetLayoutHostMappingInfoVALVE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkGetDescriptorSetLayoutHostMappingInfoVALVE(VkDevice device, const VkDescriptorSetBindingReferenceVALVE *pBindingReference, VkDescriptorSetLayoutHostMappingInfoVALVE *pHostMapping)
     * }
     */
    public static MethodHandle vkGetDescriptorSetLayoutHostMappingInfoVALVE$handle() {
        return vkGetDescriptorSetLayoutHostMappingInfoVALVE.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkGetDescriptorSetLayoutHostMappingInfoVALVE(VkDevice device, const VkDescriptorSetBindingReferenceVALVE *pBindingReference, VkDescriptorSetLayoutHostMappingInfoVALVE *pHostMapping)
     * }
     */
    public static void vkGetDescriptorSetLayoutHostMappingInfoVALVE(MemorySegment device, MemorySegment pBindingReference, MemorySegment pHostMapping) {
        var mh$ = vkGetDescriptorSetLayoutHostMappingInfoVALVE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetDescriptorSetLayoutHostMappingInfoVALVE", device, pBindingReference, pHostMapping);
            }
            mh$.invokeExact(device, pBindingReference, pHostMapping);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetDescriptorSetHostMappingVALVE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkGetDescriptorSetHostMappingVALVE"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkGetDescriptorSetHostMappingVALVE(VkDevice device, VkDescriptorSet descriptorSet, void **ppData)
     * }
     */
    public static FunctionDescriptor vkGetDescriptorSetHostMappingVALVE$descriptor() {
        return vkGetDescriptorSetHostMappingVALVE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkGetDescriptorSetHostMappingVALVE(VkDevice device, VkDescriptorSet descriptorSet, void **ppData)
     * }
     */
    public static MethodHandle vkGetDescriptorSetHostMappingVALVE$handle() {
        return vkGetDescriptorSetHostMappingVALVE.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkGetDescriptorSetHostMappingVALVE(VkDevice device, VkDescriptorSet descriptorSet, void **ppData)
     * }
     */
    public static void vkGetDescriptorSetHostMappingVALVE(MemorySegment device, MemorySegment descriptorSet, MemorySegment ppData) {
        var mh$ = vkGetDescriptorSetHostMappingVALVE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetDescriptorSetHostMappingVALVE", device, descriptorSet, ppData);
            }
            mh$.invokeExact(device, descriptorSet, ppData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdCopyMemoryIndirectNV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_LONG_LONG,
            vulkan_h.C_INT,
            vulkan_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdCopyMemoryIndirectNV"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdCopyMemoryIndirectNV(VkCommandBuffer commandBuffer, VkDeviceAddress copyBufferAddress, uint32_t copyCount, uint32_t stride)
     * }
     */
    public static FunctionDescriptor vkCmdCopyMemoryIndirectNV$descriptor() {
        return vkCmdCopyMemoryIndirectNV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdCopyMemoryIndirectNV(VkCommandBuffer commandBuffer, VkDeviceAddress copyBufferAddress, uint32_t copyCount, uint32_t stride)
     * }
     */
    public static MethodHandle vkCmdCopyMemoryIndirectNV$handle() {
        return vkCmdCopyMemoryIndirectNV.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdCopyMemoryIndirectNV(VkCommandBuffer commandBuffer, VkDeviceAddress copyBufferAddress, uint32_t copyCount, uint32_t stride)
     * }
     */
    public static void vkCmdCopyMemoryIndirectNV(MemorySegment commandBuffer, long copyBufferAddress, int copyCount, int stride) {
        var mh$ = vkCmdCopyMemoryIndirectNV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdCopyMemoryIndirectNV", commandBuffer, copyBufferAddress, copyCount, stride);
            }
            mh$.invokeExact(commandBuffer, copyBufferAddress, copyCount, stride);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdCopyMemoryToImageIndirectNV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_LONG_LONG,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdCopyMemoryToImageIndirectNV"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdCopyMemoryToImageIndirectNV(VkCommandBuffer commandBuffer, VkDeviceAddress copyBufferAddress, uint32_t copyCount, uint32_t stride, VkImage dstImage, VkImageLayout dstImageLayout, const VkImageSubresourceLayers *pImageSubresources)
     * }
     */
    public static FunctionDescriptor vkCmdCopyMemoryToImageIndirectNV$descriptor() {
        return vkCmdCopyMemoryToImageIndirectNV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdCopyMemoryToImageIndirectNV(VkCommandBuffer commandBuffer, VkDeviceAddress copyBufferAddress, uint32_t copyCount, uint32_t stride, VkImage dstImage, VkImageLayout dstImageLayout, const VkImageSubresourceLayers *pImageSubresources)
     * }
     */
    public static MethodHandle vkCmdCopyMemoryToImageIndirectNV$handle() {
        return vkCmdCopyMemoryToImageIndirectNV.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdCopyMemoryToImageIndirectNV(VkCommandBuffer commandBuffer, VkDeviceAddress copyBufferAddress, uint32_t copyCount, uint32_t stride, VkImage dstImage, VkImageLayout dstImageLayout, const VkImageSubresourceLayers *pImageSubresources)
     * }
     */
    public static void vkCmdCopyMemoryToImageIndirectNV(MemorySegment commandBuffer, long copyBufferAddress, int copyCount, int stride, MemorySegment dstImage, int dstImageLayout, MemorySegment pImageSubresources) {
        var mh$ = vkCmdCopyMemoryToImageIndirectNV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdCopyMemoryToImageIndirectNV", commandBuffer, copyBufferAddress, copyCount, stride, dstImage, dstImageLayout, pImageSubresources);
            }
            mh$.invokeExact(commandBuffer, copyBufferAddress, copyCount, stride, dstImage, dstImageLayout, pImageSubresources);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags64 VkMemoryDecompressionMethodFlagBitsNV
     * }
     */
    public static final OfLong VkMemoryDecompressionMethodFlagBitsNV = vulkan_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef VkFlags64 VkMemoryDecompressionMethodFlagsNV
     * }
     */
    public static final OfLong VkMemoryDecompressionMethodFlagsNV = vulkan_h.C_LONG_LONG;

    private static class vkCmdDecompressMemoryNV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdDecompressMemoryNV"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdDecompressMemoryNV(VkCommandBuffer commandBuffer, uint32_t decompressRegionCount, const VkDecompressMemoryRegionNV *pDecompressMemoryRegions)
     * }
     */
    public static FunctionDescriptor vkCmdDecompressMemoryNV$descriptor() {
        return vkCmdDecompressMemoryNV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdDecompressMemoryNV(VkCommandBuffer commandBuffer, uint32_t decompressRegionCount, const VkDecompressMemoryRegionNV *pDecompressMemoryRegions)
     * }
     */
    public static MethodHandle vkCmdDecompressMemoryNV$handle() {
        return vkCmdDecompressMemoryNV.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdDecompressMemoryNV(VkCommandBuffer commandBuffer, uint32_t decompressRegionCount, const VkDecompressMemoryRegionNV *pDecompressMemoryRegions)
     * }
     */
    public static void vkCmdDecompressMemoryNV(MemorySegment commandBuffer, int decompressRegionCount, MemorySegment pDecompressMemoryRegions) {
        var mh$ = vkCmdDecompressMemoryNV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdDecompressMemoryNV", commandBuffer, decompressRegionCount, pDecompressMemoryRegions);
            }
            mh$.invokeExact(commandBuffer, decompressRegionCount, pDecompressMemoryRegions);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdDecompressMemoryIndirectCountNV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_LONG_LONG,
            vulkan_h.C_LONG_LONG,
            vulkan_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdDecompressMemoryIndirectCountNV"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdDecompressMemoryIndirectCountNV(VkCommandBuffer commandBuffer, VkDeviceAddress indirectCommandsAddress, VkDeviceAddress indirectCommandsCountAddress, uint32_t stride)
     * }
     */
    public static FunctionDescriptor vkCmdDecompressMemoryIndirectCountNV$descriptor() {
        return vkCmdDecompressMemoryIndirectCountNV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdDecompressMemoryIndirectCountNV(VkCommandBuffer commandBuffer, VkDeviceAddress indirectCommandsAddress, VkDeviceAddress indirectCommandsCountAddress, uint32_t stride)
     * }
     */
    public static MethodHandle vkCmdDecompressMemoryIndirectCountNV$handle() {
        return vkCmdDecompressMemoryIndirectCountNV.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdDecompressMemoryIndirectCountNV(VkCommandBuffer commandBuffer, VkDeviceAddress indirectCommandsAddress, VkDeviceAddress indirectCommandsCountAddress, uint32_t stride)
     * }
     */
    public static void vkCmdDecompressMemoryIndirectCountNV(MemorySegment commandBuffer, long indirectCommandsAddress, long indirectCommandsCountAddress, int stride) {
        var mh$ = vkCmdDecompressMemoryIndirectCountNV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdDecompressMemoryIndirectCountNV", commandBuffer, indirectCommandsAddress, indirectCommandsCountAddress, stride);
            }
            mh$.invokeExact(commandBuffer, indirectCommandsAddress, indirectCommandsCountAddress, stride);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetPipelineIndirectMemoryRequirementsNV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkGetPipelineIndirectMemoryRequirementsNV"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkGetPipelineIndirectMemoryRequirementsNV(VkDevice device, const VkComputePipelineCreateInfo *pCreateInfo, VkMemoryRequirements2 *pMemoryRequirements)
     * }
     */
    public static FunctionDescriptor vkGetPipelineIndirectMemoryRequirementsNV$descriptor() {
        return vkGetPipelineIndirectMemoryRequirementsNV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkGetPipelineIndirectMemoryRequirementsNV(VkDevice device, const VkComputePipelineCreateInfo *pCreateInfo, VkMemoryRequirements2 *pMemoryRequirements)
     * }
     */
    public static MethodHandle vkGetPipelineIndirectMemoryRequirementsNV$handle() {
        return vkGetPipelineIndirectMemoryRequirementsNV.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkGetPipelineIndirectMemoryRequirementsNV(VkDevice device, const VkComputePipelineCreateInfo *pCreateInfo, VkMemoryRequirements2 *pMemoryRequirements)
     * }
     */
    public static void vkGetPipelineIndirectMemoryRequirementsNV(MemorySegment device, MemorySegment pCreateInfo, MemorySegment pMemoryRequirements) {
        var mh$ = vkGetPipelineIndirectMemoryRequirementsNV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetPipelineIndirectMemoryRequirementsNV", device, pCreateInfo, pMemoryRequirements);
            }
            mh$.invokeExact(device, pCreateInfo, pMemoryRequirements);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdUpdatePipelineIndirectBufferNV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdUpdatePipelineIndirectBufferNV"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdUpdatePipelineIndirectBufferNV(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline)
     * }
     */
    public static FunctionDescriptor vkCmdUpdatePipelineIndirectBufferNV$descriptor() {
        return vkCmdUpdatePipelineIndirectBufferNV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdUpdatePipelineIndirectBufferNV(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline)
     * }
     */
    public static MethodHandle vkCmdUpdatePipelineIndirectBufferNV$handle() {
        return vkCmdUpdatePipelineIndirectBufferNV.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdUpdatePipelineIndirectBufferNV(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline)
     * }
     */
    public static void vkCmdUpdatePipelineIndirectBufferNV(MemorySegment commandBuffer, int pipelineBindPoint, MemorySegment pipeline) {
        var mh$ = vkCmdUpdatePipelineIndirectBufferNV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdUpdatePipelineIndirectBufferNV", commandBuffer, pipelineBindPoint, pipeline);
            }
            mh$.invokeExact(commandBuffer, pipelineBindPoint, pipeline);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetPipelineIndirectDeviceAddressNV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_LONG_LONG,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkGetPipelineIndirectDeviceAddressNV"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkDeviceAddress vkGetPipelineIndirectDeviceAddressNV(VkDevice device, const VkPipelineIndirectDeviceAddressInfoNV *pInfo)
     * }
     */
    public static FunctionDescriptor vkGetPipelineIndirectDeviceAddressNV$descriptor() {
        return vkGetPipelineIndirectDeviceAddressNV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkDeviceAddress vkGetPipelineIndirectDeviceAddressNV(VkDevice device, const VkPipelineIndirectDeviceAddressInfoNV *pInfo)
     * }
     */
    public static MethodHandle vkGetPipelineIndirectDeviceAddressNV$handle() {
        return vkGetPipelineIndirectDeviceAddressNV.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * VkDeviceAddress vkGetPipelineIndirectDeviceAddressNV(VkDevice device, const VkPipelineIndirectDeviceAddressInfoNV *pInfo)
     * }
     */
    public static long vkGetPipelineIndirectDeviceAddressNV(MemorySegment device, MemorySegment pInfo) {
        var mh$ = vkGetPipelineIndirectDeviceAddressNV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetPipelineIndirectDeviceAddressNV", device, pInfo);
            }
            return (long)mh$.invokeExact(device, pInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdSetDepthClampEnableEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdSetDepthClampEnableEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdSetDepthClampEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthClampEnable)
     * }
     */
    public static FunctionDescriptor vkCmdSetDepthClampEnableEXT$descriptor() {
        return vkCmdSetDepthClampEnableEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdSetDepthClampEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthClampEnable)
     * }
     */
    public static MethodHandle vkCmdSetDepthClampEnableEXT$handle() {
        return vkCmdSetDepthClampEnableEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdSetDepthClampEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthClampEnable)
     * }
     */
    public static void vkCmdSetDepthClampEnableEXT(MemorySegment commandBuffer, int depthClampEnable) {
        var mh$ = vkCmdSetDepthClampEnableEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetDepthClampEnableEXT", commandBuffer, depthClampEnable);
            }
            mh$.invokeExact(commandBuffer, depthClampEnable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdSetPolygonModeEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdSetPolygonModeEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdSetPolygonModeEXT(VkCommandBuffer commandBuffer, VkPolygonMode polygonMode)
     * }
     */
    public static FunctionDescriptor vkCmdSetPolygonModeEXT$descriptor() {
        return vkCmdSetPolygonModeEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdSetPolygonModeEXT(VkCommandBuffer commandBuffer, VkPolygonMode polygonMode)
     * }
     */
    public static MethodHandle vkCmdSetPolygonModeEXT$handle() {
        return vkCmdSetPolygonModeEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdSetPolygonModeEXT(VkCommandBuffer commandBuffer, VkPolygonMode polygonMode)
     * }
     */
    public static void vkCmdSetPolygonModeEXT(MemorySegment commandBuffer, int polygonMode) {
        var mh$ = vkCmdSetPolygonModeEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetPolygonModeEXT", commandBuffer, polygonMode);
            }
            mh$.invokeExact(commandBuffer, polygonMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdSetRasterizationSamplesEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdSetRasterizationSamplesEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdSetRasterizationSamplesEXT(VkCommandBuffer commandBuffer, VkSampleCountFlagBits rasterizationSamples)
     * }
     */
    public static FunctionDescriptor vkCmdSetRasterizationSamplesEXT$descriptor() {
        return vkCmdSetRasterizationSamplesEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdSetRasterizationSamplesEXT(VkCommandBuffer commandBuffer, VkSampleCountFlagBits rasterizationSamples)
     * }
     */
    public static MethodHandle vkCmdSetRasterizationSamplesEXT$handle() {
        return vkCmdSetRasterizationSamplesEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdSetRasterizationSamplesEXT(VkCommandBuffer commandBuffer, VkSampleCountFlagBits rasterizationSamples)
     * }
     */
    public static void vkCmdSetRasterizationSamplesEXT(MemorySegment commandBuffer, int rasterizationSamples) {
        var mh$ = vkCmdSetRasterizationSamplesEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetRasterizationSamplesEXT", commandBuffer, rasterizationSamples);
            }
            mh$.invokeExact(commandBuffer, rasterizationSamples);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdSetSampleMaskEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdSetSampleMaskEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdSetSampleMaskEXT(VkCommandBuffer commandBuffer, VkSampleCountFlagBits samples, const VkSampleMask *pSampleMask)
     * }
     */
    public static FunctionDescriptor vkCmdSetSampleMaskEXT$descriptor() {
        return vkCmdSetSampleMaskEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdSetSampleMaskEXT(VkCommandBuffer commandBuffer, VkSampleCountFlagBits samples, const VkSampleMask *pSampleMask)
     * }
     */
    public static MethodHandle vkCmdSetSampleMaskEXT$handle() {
        return vkCmdSetSampleMaskEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdSetSampleMaskEXT(VkCommandBuffer commandBuffer, VkSampleCountFlagBits samples, const VkSampleMask *pSampleMask)
     * }
     */
    public static void vkCmdSetSampleMaskEXT(MemorySegment commandBuffer, int samples, MemorySegment pSampleMask) {
        var mh$ = vkCmdSetSampleMaskEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetSampleMaskEXT", commandBuffer, samples, pSampleMask);
            }
            mh$.invokeExact(commandBuffer, samples, pSampleMask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdSetAlphaToCoverageEnableEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdSetAlphaToCoverageEnableEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdSetAlphaToCoverageEnableEXT(VkCommandBuffer commandBuffer, VkBool32 alphaToCoverageEnable)
     * }
     */
    public static FunctionDescriptor vkCmdSetAlphaToCoverageEnableEXT$descriptor() {
        return vkCmdSetAlphaToCoverageEnableEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdSetAlphaToCoverageEnableEXT(VkCommandBuffer commandBuffer, VkBool32 alphaToCoverageEnable)
     * }
     */
    public static MethodHandle vkCmdSetAlphaToCoverageEnableEXT$handle() {
        return vkCmdSetAlphaToCoverageEnableEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdSetAlphaToCoverageEnableEXT(VkCommandBuffer commandBuffer, VkBool32 alphaToCoverageEnable)
     * }
     */
    public static void vkCmdSetAlphaToCoverageEnableEXT(MemorySegment commandBuffer, int alphaToCoverageEnable) {
        var mh$ = vkCmdSetAlphaToCoverageEnableEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetAlphaToCoverageEnableEXT", commandBuffer, alphaToCoverageEnable);
            }
            mh$.invokeExact(commandBuffer, alphaToCoverageEnable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdSetAlphaToOneEnableEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdSetAlphaToOneEnableEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdSetAlphaToOneEnableEXT(VkCommandBuffer commandBuffer, VkBool32 alphaToOneEnable)
     * }
     */
    public static FunctionDescriptor vkCmdSetAlphaToOneEnableEXT$descriptor() {
        return vkCmdSetAlphaToOneEnableEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdSetAlphaToOneEnableEXT(VkCommandBuffer commandBuffer, VkBool32 alphaToOneEnable)
     * }
     */
    public static MethodHandle vkCmdSetAlphaToOneEnableEXT$handle() {
        return vkCmdSetAlphaToOneEnableEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdSetAlphaToOneEnableEXT(VkCommandBuffer commandBuffer, VkBool32 alphaToOneEnable)
     * }
     */
    public static void vkCmdSetAlphaToOneEnableEXT(MemorySegment commandBuffer, int alphaToOneEnable) {
        var mh$ = vkCmdSetAlphaToOneEnableEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetAlphaToOneEnableEXT", commandBuffer, alphaToOneEnable);
            }
            mh$.invokeExact(commandBuffer, alphaToOneEnable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdSetLogicOpEnableEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdSetLogicOpEnableEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdSetLogicOpEnableEXT(VkCommandBuffer commandBuffer, VkBool32 logicOpEnable)
     * }
     */
    public static FunctionDescriptor vkCmdSetLogicOpEnableEXT$descriptor() {
        return vkCmdSetLogicOpEnableEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdSetLogicOpEnableEXT(VkCommandBuffer commandBuffer, VkBool32 logicOpEnable)
     * }
     */
    public static MethodHandle vkCmdSetLogicOpEnableEXT$handle() {
        return vkCmdSetLogicOpEnableEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdSetLogicOpEnableEXT(VkCommandBuffer commandBuffer, VkBool32 logicOpEnable)
     * }
     */
    public static void vkCmdSetLogicOpEnableEXT(MemorySegment commandBuffer, int logicOpEnable) {
        var mh$ = vkCmdSetLogicOpEnableEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetLogicOpEnableEXT", commandBuffer, logicOpEnable);
            }
            mh$.invokeExact(commandBuffer, logicOpEnable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdSetColorBlendEnableEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdSetColorBlendEnableEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdSetColorBlendEnableEXT(VkCommandBuffer commandBuffer, uint32_t firstAttachment, uint32_t attachmentCount, const VkBool32 *pColorBlendEnables)
     * }
     */
    public static FunctionDescriptor vkCmdSetColorBlendEnableEXT$descriptor() {
        return vkCmdSetColorBlendEnableEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdSetColorBlendEnableEXT(VkCommandBuffer commandBuffer, uint32_t firstAttachment, uint32_t attachmentCount, const VkBool32 *pColorBlendEnables)
     * }
     */
    public static MethodHandle vkCmdSetColorBlendEnableEXT$handle() {
        return vkCmdSetColorBlendEnableEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdSetColorBlendEnableEXT(VkCommandBuffer commandBuffer, uint32_t firstAttachment, uint32_t attachmentCount, const VkBool32 *pColorBlendEnables)
     * }
     */
    public static void vkCmdSetColorBlendEnableEXT(MemorySegment commandBuffer, int firstAttachment, int attachmentCount, MemorySegment pColorBlendEnables) {
        var mh$ = vkCmdSetColorBlendEnableEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetColorBlendEnableEXT", commandBuffer, firstAttachment, attachmentCount, pColorBlendEnables);
            }
            mh$.invokeExact(commandBuffer, firstAttachment, attachmentCount, pColorBlendEnables);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdSetColorBlendEquationEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdSetColorBlendEquationEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdSetColorBlendEquationEXT(VkCommandBuffer commandBuffer, uint32_t firstAttachment, uint32_t attachmentCount, const VkColorBlendEquationEXT *pColorBlendEquations)
     * }
     */
    public static FunctionDescriptor vkCmdSetColorBlendEquationEXT$descriptor() {
        return vkCmdSetColorBlendEquationEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdSetColorBlendEquationEXT(VkCommandBuffer commandBuffer, uint32_t firstAttachment, uint32_t attachmentCount, const VkColorBlendEquationEXT *pColorBlendEquations)
     * }
     */
    public static MethodHandle vkCmdSetColorBlendEquationEXT$handle() {
        return vkCmdSetColorBlendEquationEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdSetColorBlendEquationEXT(VkCommandBuffer commandBuffer, uint32_t firstAttachment, uint32_t attachmentCount, const VkColorBlendEquationEXT *pColorBlendEquations)
     * }
     */
    public static void vkCmdSetColorBlendEquationEXT(MemorySegment commandBuffer, int firstAttachment, int attachmentCount, MemorySegment pColorBlendEquations) {
        var mh$ = vkCmdSetColorBlendEquationEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetColorBlendEquationEXT", commandBuffer, firstAttachment, attachmentCount, pColorBlendEquations);
            }
            mh$.invokeExact(commandBuffer, firstAttachment, attachmentCount, pColorBlendEquations);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdSetColorWriteMaskEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdSetColorWriteMaskEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdSetColorWriteMaskEXT(VkCommandBuffer commandBuffer, uint32_t firstAttachment, uint32_t attachmentCount, const VkColorComponentFlags *pColorWriteMasks)
     * }
     */
    public static FunctionDescriptor vkCmdSetColorWriteMaskEXT$descriptor() {
        return vkCmdSetColorWriteMaskEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdSetColorWriteMaskEXT(VkCommandBuffer commandBuffer, uint32_t firstAttachment, uint32_t attachmentCount, const VkColorComponentFlags *pColorWriteMasks)
     * }
     */
    public static MethodHandle vkCmdSetColorWriteMaskEXT$handle() {
        return vkCmdSetColorWriteMaskEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdSetColorWriteMaskEXT(VkCommandBuffer commandBuffer, uint32_t firstAttachment, uint32_t attachmentCount, const VkColorComponentFlags *pColorWriteMasks)
     * }
     */
    public static void vkCmdSetColorWriteMaskEXT(MemorySegment commandBuffer, int firstAttachment, int attachmentCount, MemorySegment pColorWriteMasks) {
        var mh$ = vkCmdSetColorWriteMaskEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetColorWriteMaskEXT", commandBuffer, firstAttachment, attachmentCount, pColorWriteMasks);
            }
            mh$.invokeExact(commandBuffer, firstAttachment, attachmentCount, pColorWriteMasks);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdSetTessellationDomainOriginEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdSetTessellationDomainOriginEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdSetTessellationDomainOriginEXT(VkCommandBuffer commandBuffer, VkTessellationDomainOrigin domainOrigin)
     * }
     */
    public static FunctionDescriptor vkCmdSetTessellationDomainOriginEXT$descriptor() {
        return vkCmdSetTessellationDomainOriginEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdSetTessellationDomainOriginEXT(VkCommandBuffer commandBuffer, VkTessellationDomainOrigin domainOrigin)
     * }
     */
    public static MethodHandle vkCmdSetTessellationDomainOriginEXT$handle() {
        return vkCmdSetTessellationDomainOriginEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdSetTessellationDomainOriginEXT(VkCommandBuffer commandBuffer, VkTessellationDomainOrigin domainOrigin)
     * }
     */
    public static void vkCmdSetTessellationDomainOriginEXT(MemorySegment commandBuffer, int domainOrigin) {
        var mh$ = vkCmdSetTessellationDomainOriginEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetTessellationDomainOriginEXT", commandBuffer, domainOrigin);
            }
            mh$.invokeExact(commandBuffer, domainOrigin);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdSetRasterizationStreamEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdSetRasterizationStreamEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdSetRasterizationStreamEXT(VkCommandBuffer commandBuffer, uint32_t rasterizationStream)
     * }
     */
    public static FunctionDescriptor vkCmdSetRasterizationStreamEXT$descriptor() {
        return vkCmdSetRasterizationStreamEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdSetRasterizationStreamEXT(VkCommandBuffer commandBuffer, uint32_t rasterizationStream)
     * }
     */
    public static MethodHandle vkCmdSetRasterizationStreamEXT$handle() {
        return vkCmdSetRasterizationStreamEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdSetRasterizationStreamEXT(VkCommandBuffer commandBuffer, uint32_t rasterizationStream)
     * }
     */
    public static void vkCmdSetRasterizationStreamEXT(MemorySegment commandBuffer, int rasterizationStream) {
        var mh$ = vkCmdSetRasterizationStreamEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetRasterizationStreamEXT", commandBuffer, rasterizationStream);
            }
            mh$.invokeExact(commandBuffer, rasterizationStream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdSetConservativeRasterizationModeEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdSetConservativeRasterizationModeEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdSetConservativeRasterizationModeEXT(VkCommandBuffer commandBuffer, VkConservativeRasterizationModeEXT conservativeRasterizationMode)
     * }
     */
    public static FunctionDescriptor vkCmdSetConservativeRasterizationModeEXT$descriptor() {
        return vkCmdSetConservativeRasterizationModeEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdSetConservativeRasterizationModeEXT(VkCommandBuffer commandBuffer, VkConservativeRasterizationModeEXT conservativeRasterizationMode)
     * }
     */
    public static MethodHandle vkCmdSetConservativeRasterizationModeEXT$handle() {
        return vkCmdSetConservativeRasterizationModeEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdSetConservativeRasterizationModeEXT(VkCommandBuffer commandBuffer, VkConservativeRasterizationModeEXT conservativeRasterizationMode)
     * }
     */
    public static void vkCmdSetConservativeRasterizationModeEXT(MemorySegment commandBuffer, int conservativeRasterizationMode) {
        var mh$ = vkCmdSetConservativeRasterizationModeEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetConservativeRasterizationModeEXT", commandBuffer, conservativeRasterizationMode);
            }
            mh$.invokeExact(commandBuffer, conservativeRasterizationMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdSetExtraPrimitiveOverestimationSizeEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdSetExtraPrimitiveOverestimationSizeEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdSetExtraPrimitiveOverestimationSizeEXT(VkCommandBuffer commandBuffer, float extraPrimitiveOverestimationSize)
     * }
     */
    public static FunctionDescriptor vkCmdSetExtraPrimitiveOverestimationSizeEXT$descriptor() {
        return vkCmdSetExtraPrimitiveOverestimationSizeEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdSetExtraPrimitiveOverestimationSizeEXT(VkCommandBuffer commandBuffer, float extraPrimitiveOverestimationSize)
     * }
     */
    public static MethodHandle vkCmdSetExtraPrimitiveOverestimationSizeEXT$handle() {
        return vkCmdSetExtraPrimitiveOverestimationSizeEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdSetExtraPrimitiveOverestimationSizeEXT(VkCommandBuffer commandBuffer, float extraPrimitiveOverestimationSize)
     * }
     */
    public static void vkCmdSetExtraPrimitiveOverestimationSizeEXT(MemorySegment commandBuffer, float extraPrimitiveOverestimationSize) {
        var mh$ = vkCmdSetExtraPrimitiveOverestimationSizeEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetExtraPrimitiveOverestimationSizeEXT", commandBuffer, extraPrimitiveOverestimationSize);
            }
            mh$.invokeExact(commandBuffer, extraPrimitiveOverestimationSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdSetDepthClipEnableEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdSetDepthClipEnableEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdSetDepthClipEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthClipEnable)
     * }
     */
    public static FunctionDescriptor vkCmdSetDepthClipEnableEXT$descriptor() {
        return vkCmdSetDepthClipEnableEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdSetDepthClipEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthClipEnable)
     * }
     */
    public static MethodHandle vkCmdSetDepthClipEnableEXT$handle() {
        return vkCmdSetDepthClipEnableEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdSetDepthClipEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthClipEnable)
     * }
     */
    public static void vkCmdSetDepthClipEnableEXT(MemorySegment commandBuffer, int depthClipEnable) {
        var mh$ = vkCmdSetDepthClipEnableEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetDepthClipEnableEXT", commandBuffer, depthClipEnable);
            }
            mh$.invokeExact(commandBuffer, depthClipEnable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdSetSampleLocationsEnableEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdSetSampleLocationsEnableEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdSetSampleLocationsEnableEXT(VkCommandBuffer commandBuffer, VkBool32 sampleLocationsEnable)
     * }
     */
    public static FunctionDescriptor vkCmdSetSampleLocationsEnableEXT$descriptor() {
        return vkCmdSetSampleLocationsEnableEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdSetSampleLocationsEnableEXT(VkCommandBuffer commandBuffer, VkBool32 sampleLocationsEnable)
     * }
     */
    public static MethodHandle vkCmdSetSampleLocationsEnableEXT$handle() {
        return vkCmdSetSampleLocationsEnableEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdSetSampleLocationsEnableEXT(VkCommandBuffer commandBuffer, VkBool32 sampleLocationsEnable)
     * }
     */
    public static void vkCmdSetSampleLocationsEnableEXT(MemorySegment commandBuffer, int sampleLocationsEnable) {
        var mh$ = vkCmdSetSampleLocationsEnableEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetSampleLocationsEnableEXT", commandBuffer, sampleLocationsEnable);
            }
            mh$.invokeExact(commandBuffer, sampleLocationsEnable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdSetColorBlendAdvancedEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdSetColorBlendAdvancedEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdSetColorBlendAdvancedEXT(VkCommandBuffer commandBuffer, uint32_t firstAttachment, uint32_t attachmentCount, const VkColorBlendAdvancedEXT *pColorBlendAdvanced)
     * }
     */
    public static FunctionDescriptor vkCmdSetColorBlendAdvancedEXT$descriptor() {
        return vkCmdSetColorBlendAdvancedEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdSetColorBlendAdvancedEXT(VkCommandBuffer commandBuffer, uint32_t firstAttachment, uint32_t attachmentCount, const VkColorBlendAdvancedEXT *pColorBlendAdvanced)
     * }
     */
    public static MethodHandle vkCmdSetColorBlendAdvancedEXT$handle() {
        return vkCmdSetColorBlendAdvancedEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdSetColorBlendAdvancedEXT(VkCommandBuffer commandBuffer, uint32_t firstAttachment, uint32_t attachmentCount, const VkColorBlendAdvancedEXT *pColorBlendAdvanced)
     * }
     */
    public static void vkCmdSetColorBlendAdvancedEXT(MemorySegment commandBuffer, int firstAttachment, int attachmentCount, MemorySegment pColorBlendAdvanced) {
        var mh$ = vkCmdSetColorBlendAdvancedEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetColorBlendAdvancedEXT", commandBuffer, firstAttachment, attachmentCount, pColorBlendAdvanced);
            }
            mh$.invokeExact(commandBuffer, firstAttachment, attachmentCount, pColorBlendAdvanced);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdSetProvokingVertexModeEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdSetProvokingVertexModeEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdSetProvokingVertexModeEXT(VkCommandBuffer commandBuffer, VkProvokingVertexModeEXT provokingVertexMode)
     * }
     */
    public static FunctionDescriptor vkCmdSetProvokingVertexModeEXT$descriptor() {
        return vkCmdSetProvokingVertexModeEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdSetProvokingVertexModeEXT(VkCommandBuffer commandBuffer, VkProvokingVertexModeEXT provokingVertexMode)
     * }
     */
    public static MethodHandle vkCmdSetProvokingVertexModeEXT$handle() {
        return vkCmdSetProvokingVertexModeEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdSetProvokingVertexModeEXT(VkCommandBuffer commandBuffer, VkProvokingVertexModeEXT provokingVertexMode)
     * }
     */
    public static void vkCmdSetProvokingVertexModeEXT(MemorySegment commandBuffer, int provokingVertexMode) {
        var mh$ = vkCmdSetProvokingVertexModeEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetProvokingVertexModeEXT", commandBuffer, provokingVertexMode);
            }
            mh$.invokeExact(commandBuffer, provokingVertexMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdSetLineRasterizationModeEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdSetLineRasterizationModeEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdSetLineRasterizationModeEXT(VkCommandBuffer commandBuffer, VkLineRasterizationModeEXT lineRasterizationMode)
     * }
     */
    public static FunctionDescriptor vkCmdSetLineRasterizationModeEXT$descriptor() {
        return vkCmdSetLineRasterizationModeEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdSetLineRasterizationModeEXT(VkCommandBuffer commandBuffer, VkLineRasterizationModeEXT lineRasterizationMode)
     * }
     */
    public static MethodHandle vkCmdSetLineRasterizationModeEXT$handle() {
        return vkCmdSetLineRasterizationModeEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdSetLineRasterizationModeEXT(VkCommandBuffer commandBuffer, VkLineRasterizationModeEXT lineRasterizationMode)
     * }
     */
    public static void vkCmdSetLineRasterizationModeEXT(MemorySegment commandBuffer, int lineRasterizationMode) {
        var mh$ = vkCmdSetLineRasterizationModeEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetLineRasterizationModeEXT", commandBuffer, lineRasterizationMode);
            }
            mh$.invokeExact(commandBuffer, lineRasterizationMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdSetLineStippleEnableEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdSetLineStippleEnableEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdSetLineStippleEnableEXT(VkCommandBuffer commandBuffer, VkBool32 stippledLineEnable)
     * }
     */
    public static FunctionDescriptor vkCmdSetLineStippleEnableEXT$descriptor() {
        return vkCmdSetLineStippleEnableEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdSetLineStippleEnableEXT(VkCommandBuffer commandBuffer, VkBool32 stippledLineEnable)
     * }
     */
    public static MethodHandle vkCmdSetLineStippleEnableEXT$handle() {
        return vkCmdSetLineStippleEnableEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdSetLineStippleEnableEXT(VkCommandBuffer commandBuffer, VkBool32 stippledLineEnable)
     * }
     */
    public static void vkCmdSetLineStippleEnableEXT(MemorySegment commandBuffer, int stippledLineEnable) {
        var mh$ = vkCmdSetLineStippleEnableEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetLineStippleEnableEXT", commandBuffer, stippledLineEnable);
            }
            mh$.invokeExact(commandBuffer, stippledLineEnable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdSetDepthClipNegativeOneToOneEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdSetDepthClipNegativeOneToOneEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdSetDepthClipNegativeOneToOneEXT(VkCommandBuffer commandBuffer, VkBool32 negativeOneToOne)
     * }
     */
    public static FunctionDescriptor vkCmdSetDepthClipNegativeOneToOneEXT$descriptor() {
        return vkCmdSetDepthClipNegativeOneToOneEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdSetDepthClipNegativeOneToOneEXT(VkCommandBuffer commandBuffer, VkBool32 negativeOneToOne)
     * }
     */
    public static MethodHandle vkCmdSetDepthClipNegativeOneToOneEXT$handle() {
        return vkCmdSetDepthClipNegativeOneToOneEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdSetDepthClipNegativeOneToOneEXT(VkCommandBuffer commandBuffer, VkBool32 negativeOneToOne)
     * }
     */
    public static void vkCmdSetDepthClipNegativeOneToOneEXT(MemorySegment commandBuffer, int negativeOneToOne) {
        var mh$ = vkCmdSetDepthClipNegativeOneToOneEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetDepthClipNegativeOneToOneEXT", commandBuffer, negativeOneToOne);
            }
            mh$.invokeExact(commandBuffer, negativeOneToOne);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdSetViewportWScalingEnableNV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdSetViewportWScalingEnableNV"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdSetViewportWScalingEnableNV(VkCommandBuffer commandBuffer, VkBool32 viewportWScalingEnable)
     * }
     */
    public static FunctionDescriptor vkCmdSetViewportWScalingEnableNV$descriptor() {
        return vkCmdSetViewportWScalingEnableNV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdSetViewportWScalingEnableNV(VkCommandBuffer commandBuffer, VkBool32 viewportWScalingEnable)
     * }
     */
    public static MethodHandle vkCmdSetViewportWScalingEnableNV$handle() {
        return vkCmdSetViewportWScalingEnableNV.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdSetViewportWScalingEnableNV(VkCommandBuffer commandBuffer, VkBool32 viewportWScalingEnable)
     * }
     */
    public static void vkCmdSetViewportWScalingEnableNV(MemorySegment commandBuffer, int viewportWScalingEnable) {
        var mh$ = vkCmdSetViewportWScalingEnableNV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetViewportWScalingEnableNV", commandBuffer, viewportWScalingEnable);
            }
            mh$.invokeExact(commandBuffer, viewportWScalingEnable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdSetViewportSwizzleNV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdSetViewportSwizzleNV"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdSetViewportSwizzleNV(VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkViewportSwizzleNV *pViewportSwizzles)
     * }
     */
    public static FunctionDescriptor vkCmdSetViewportSwizzleNV$descriptor() {
        return vkCmdSetViewportSwizzleNV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdSetViewportSwizzleNV(VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkViewportSwizzleNV *pViewportSwizzles)
     * }
     */
    public static MethodHandle vkCmdSetViewportSwizzleNV$handle() {
        return vkCmdSetViewportSwizzleNV.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdSetViewportSwizzleNV(VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkViewportSwizzleNV *pViewportSwizzles)
     * }
     */
    public static void vkCmdSetViewportSwizzleNV(MemorySegment commandBuffer, int firstViewport, int viewportCount, MemorySegment pViewportSwizzles) {
        var mh$ = vkCmdSetViewportSwizzleNV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetViewportSwizzleNV", commandBuffer, firstViewport, viewportCount, pViewportSwizzles);
            }
            mh$.invokeExact(commandBuffer, firstViewport, viewportCount, pViewportSwizzles);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdSetCoverageToColorEnableNV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdSetCoverageToColorEnableNV"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdSetCoverageToColorEnableNV(VkCommandBuffer commandBuffer, VkBool32 coverageToColorEnable)
     * }
     */
    public static FunctionDescriptor vkCmdSetCoverageToColorEnableNV$descriptor() {
        return vkCmdSetCoverageToColorEnableNV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdSetCoverageToColorEnableNV(VkCommandBuffer commandBuffer, VkBool32 coverageToColorEnable)
     * }
     */
    public static MethodHandle vkCmdSetCoverageToColorEnableNV$handle() {
        return vkCmdSetCoverageToColorEnableNV.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdSetCoverageToColorEnableNV(VkCommandBuffer commandBuffer, VkBool32 coverageToColorEnable)
     * }
     */
    public static void vkCmdSetCoverageToColorEnableNV(MemorySegment commandBuffer, int coverageToColorEnable) {
        var mh$ = vkCmdSetCoverageToColorEnableNV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetCoverageToColorEnableNV", commandBuffer, coverageToColorEnable);
            }
            mh$.invokeExact(commandBuffer, coverageToColorEnable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdSetCoverageToColorLocationNV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdSetCoverageToColorLocationNV"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdSetCoverageToColorLocationNV(VkCommandBuffer commandBuffer, uint32_t coverageToColorLocation)
     * }
     */
    public static FunctionDescriptor vkCmdSetCoverageToColorLocationNV$descriptor() {
        return vkCmdSetCoverageToColorLocationNV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdSetCoverageToColorLocationNV(VkCommandBuffer commandBuffer, uint32_t coverageToColorLocation)
     * }
     */
    public static MethodHandle vkCmdSetCoverageToColorLocationNV$handle() {
        return vkCmdSetCoverageToColorLocationNV.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdSetCoverageToColorLocationNV(VkCommandBuffer commandBuffer, uint32_t coverageToColorLocation)
     * }
     */
    public static void vkCmdSetCoverageToColorLocationNV(MemorySegment commandBuffer, int coverageToColorLocation) {
        var mh$ = vkCmdSetCoverageToColorLocationNV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetCoverageToColorLocationNV", commandBuffer, coverageToColorLocation);
            }
            mh$.invokeExact(commandBuffer, coverageToColorLocation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdSetCoverageModulationModeNV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdSetCoverageModulationModeNV"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdSetCoverageModulationModeNV(VkCommandBuffer commandBuffer, VkCoverageModulationModeNV coverageModulationMode)
     * }
     */
    public static FunctionDescriptor vkCmdSetCoverageModulationModeNV$descriptor() {
        return vkCmdSetCoverageModulationModeNV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdSetCoverageModulationModeNV(VkCommandBuffer commandBuffer, VkCoverageModulationModeNV coverageModulationMode)
     * }
     */
    public static MethodHandle vkCmdSetCoverageModulationModeNV$handle() {
        return vkCmdSetCoverageModulationModeNV.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdSetCoverageModulationModeNV(VkCommandBuffer commandBuffer, VkCoverageModulationModeNV coverageModulationMode)
     * }
     */
    public static void vkCmdSetCoverageModulationModeNV(MemorySegment commandBuffer, int coverageModulationMode) {
        var mh$ = vkCmdSetCoverageModulationModeNV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetCoverageModulationModeNV", commandBuffer, coverageModulationMode);
            }
            mh$.invokeExact(commandBuffer, coverageModulationMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdSetCoverageModulationTableEnableNV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdSetCoverageModulationTableEnableNV"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdSetCoverageModulationTableEnableNV(VkCommandBuffer commandBuffer, VkBool32 coverageModulationTableEnable)
     * }
     */
    public static FunctionDescriptor vkCmdSetCoverageModulationTableEnableNV$descriptor() {
        return vkCmdSetCoverageModulationTableEnableNV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdSetCoverageModulationTableEnableNV(VkCommandBuffer commandBuffer, VkBool32 coverageModulationTableEnable)
     * }
     */
    public static MethodHandle vkCmdSetCoverageModulationTableEnableNV$handle() {
        return vkCmdSetCoverageModulationTableEnableNV.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdSetCoverageModulationTableEnableNV(VkCommandBuffer commandBuffer, VkBool32 coverageModulationTableEnable)
     * }
     */
    public static void vkCmdSetCoverageModulationTableEnableNV(MemorySegment commandBuffer, int coverageModulationTableEnable) {
        var mh$ = vkCmdSetCoverageModulationTableEnableNV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetCoverageModulationTableEnableNV", commandBuffer, coverageModulationTableEnable);
            }
            mh$.invokeExact(commandBuffer, coverageModulationTableEnable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdSetCoverageModulationTableNV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdSetCoverageModulationTableNV"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdSetCoverageModulationTableNV(VkCommandBuffer commandBuffer, uint32_t coverageModulationTableCount, const float *pCoverageModulationTable)
     * }
     */
    public static FunctionDescriptor vkCmdSetCoverageModulationTableNV$descriptor() {
        return vkCmdSetCoverageModulationTableNV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdSetCoverageModulationTableNV(VkCommandBuffer commandBuffer, uint32_t coverageModulationTableCount, const float *pCoverageModulationTable)
     * }
     */
    public static MethodHandle vkCmdSetCoverageModulationTableNV$handle() {
        return vkCmdSetCoverageModulationTableNV.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdSetCoverageModulationTableNV(VkCommandBuffer commandBuffer, uint32_t coverageModulationTableCount, const float *pCoverageModulationTable)
     * }
     */
    public static void vkCmdSetCoverageModulationTableNV(MemorySegment commandBuffer, int coverageModulationTableCount, MemorySegment pCoverageModulationTable) {
        var mh$ = vkCmdSetCoverageModulationTableNV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetCoverageModulationTableNV", commandBuffer, coverageModulationTableCount, pCoverageModulationTable);
            }
            mh$.invokeExact(commandBuffer, coverageModulationTableCount, pCoverageModulationTable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdSetShadingRateImageEnableNV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdSetShadingRateImageEnableNV"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdSetShadingRateImageEnableNV(VkCommandBuffer commandBuffer, VkBool32 shadingRateImageEnable)
     * }
     */
    public static FunctionDescriptor vkCmdSetShadingRateImageEnableNV$descriptor() {
        return vkCmdSetShadingRateImageEnableNV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdSetShadingRateImageEnableNV(VkCommandBuffer commandBuffer, VkBool32 shadingRateImageEnable)
     * }
     */
    public static MethodHandle vkCmdSetShadingRateImageEnableNV$handle() {
        return vkCmdSetShadingRateImageEnableNV.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdSetShadingRateImageEnableNV(VkCommandBuffer commandBuffer, VkBool32 shadingRateImageEnable)
     * }
     */
    public static void vkCmdSetShadingRateImageEnableNV(MemorySegment commandBuffer, int shadingRateImageEnable) {
        var mh$ = vkCmdSetShadingRateImageEnableNV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetShadingRateImageEnableNV", commandBuffer, shadingRateImageEnable);
            }
            mh$.invokeExact(commandBuffer, shadingRateImageEnable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdSetRepresentativeFragmentTestEnableNV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdSetRepresentativeFragmentTestEnableNV"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdSetRepresentativeFragmentTestEnableNV(VkCommandBuffer commandBuffer, VkBool32 representativeFragmentTestEnable)
     * }
     */
    public static FunctionDescriptor vkCmdSetRepresentativeFragmentTestEnableNV$descriptor() {
        return vkCmdSetRepresentativeFragmentTestEnableNV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdSetRepresentativeFragmentTestEnableNV(VkCommandBuffer commandBuffer, VkBool32 representativeFragmentTestEnable)
     * }
     */
    public static MethodHandle vkCmdSetRepresentativeFragmentTestEnableNV$handle() {
        return vkCmdSetRepresentativeFragmentTestEnableNV.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdSetRepresentativeFragmentTestEnableNV(VkCommandBuffer commandBuffer, VkBool32 representativeFragmentTestEnable)
     * }
     */
    public static void vkCmdSetRepresentativeFragmentTestEnableNV(MemorySegment commandBuffer, int representativeFragmentTestEnable) {
        var mh$ = vkCmdSetRepresentativeFragmentTestEnableNV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetRepresentativeFragmentTestEnableNV", commandBuffer, representativeFragmentTestEnable);
            }
            mh$.invokeExact(commandBuffer, representativeFragmentTestEnable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdSetCoverageReductionModeNV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdSetCoverageReductionModeNV"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdSetCoverageReductionModeNV(VkCommandBuffer commandBuffer, VkCoverageReductionModeNV coverageReductionMode)
     * }
     */
    public static FunctionDescriptor vkCmdSetCoverageReductionModeNV$descriptor() {
        return vkCmdSetCoverageReductionModeNV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdSetCoverageReductionModeNV(VkCommandBuffer commandBuffer, VkCoverageReductionModeNV coverageReductionMode)
     * }
     */
    public static MethodHandle vkCmdSetCoverageReductionModeNV$handle() {
        return vkCmdSetCoverageReductionModeNV.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdSetCoverageReductionModeNV(VkCommandBuffer commandBuffer, VkCoverageReductionModeNV coverageReductionMode)
     * }
     */
    public static void vkCmdSetCoverageReductionModeNV(MemorySegment commandBuffer, int coverageReductionMode) {
        var mh$ = vkCmdSetCoverageReductionModeNV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetCoverageReductionModeNV", commandBuffer, coverageReductionMode);
            }
            mh$.invokeExact(commandBuffer, coverageReductionMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int VK_SUBPASS_MERGE_STATUS_MERGED_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkSubpassMergeStatusEXT.VK_SUBPASS_MERGE_STATUS_MERGED_EXT = 0
     * }
     */
    public static int VK_SUBPASS_MERGE_STATUS_MERGED_EXT() {
        return VK_SUBPASS_MERGE_STATUS_MERGED_EXT;
    }
    private static final int VK_SUBPASS_MERGE_STATUS_DISALLOWED_EXT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkSubpassMergeStatusEXT.VK_SUBPASS_MERGE_STATUS_DISALLOWED_EXT = 1
     * }
     */
    public static int VK_SUBPASS_MERGE_STATUS_DISALLOWED_EXT() {
        return VK_SUBPASS_MERGE_STATUS_DISALLOWED_EXT;
    }
    private static final int VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SIDE_EFFECTS_EXT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkSubpassMergeStatusEXT.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SIDE_EFFECTS_EXT = 2
     * }
     */
    public static int VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SIDE_EFFECTS_EXT() {
        return VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SIDE_EFFECTS_EXT;
    }
    private static final int VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SAMPLES_MISMATCH_EXT = (int)3L;
    /**
     * {@snippet lang=c :
     * enum VkSubpassMergeStatusEXT.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SAMPLES_MISMATCH_EXT = 3
     * }
     */
    public static int VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SAMPLES_MISMATCH_EXT() {
        return VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SAMPLES_MISMATCH_EXT;
    }
    private static final int VK_SUBPASS_MERGE_STATUS_NOT_MERGED_VIEWS_MISMATCH_EXT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkSubpassMergeStatusEXT.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_VIEWS_MISMATCH_EXT = 4
     * }
     */
    public static int VK_SUBPASS_MERGE_STATUS_NOT_MERGED_VIEWS_MISMATCH_EXT() {
        return VK_SUBPASS_MERGE_STATUS_NOT_MERGED_VIEWS_MISMATCH_EXT;
    }
    private static final int VK_SUBPASS_MERGE_STATUS_NOT_MERGED_ALIASING_EXT = (int)5L;
    /**
     * {@snippet lang=c :
     * enum VkSubpassMergeStatusEXT.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_ALIASING_EXT = 5
     * }
     */
    public static int VK_SUBPASS_MERGE_STATUS_NOT_MERGED_ALIASING_EXT() {
        return VK_SUBPASS_MERGE_STATUS_NOT_MERGED_ALIASING_EXT;
    }
    private static final int VK_SUBPASS_MERGE_STATUS_NOT_MERGED_DEPENDENCIES_EXT = (int)6L;
    /**
     * {@snippet lang=c :
     * enum VkSubpassMergeStatusEXT.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_DEPENDENCIES_EXT = 6
     * }
     */
    public static int VK_SUBPASS_MERGE_STATUS_NOT_MERGED_DEPENDENCIES_EXT() {
        return VK_SUBPASS_MERGE_STATUS_NOT_MERGED_DEPENDENCIES_EXT;
    }
    private static final int VK_SUBPASS_MERGE_STATUS_NOT_MERGED_INCOMPATIBLE_INPUT_ATTACHMENT_EXT = (int)7L;
    /**
     * {@snippet lang=c :
     * enum VkSubpassMergeStatusEXT.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_INCOMPATIBLE_INPUT_ATTACHMENT_EXT = 7
     * }
     */
    public static int VK_SUBPASS_MERGE_STATUS_NOT_MERGED_INCOMPATIBLE_INPUT_ATTACHMENT_EXT() {
        return VK_SUBPASS_MERGE_STATUS_NOT_MERGED_INCOMPATIBLE_INPUT_ATTACHMENT_EXT;
    }
    private static final int VK_SUBPASS_MERGE_STATUS_NOT_MERGED_TOO_MANY_ATTACHMENTS_EXT = (int)8L;
    /**
     * {@snippet lang=c :
     * enum VkSubpassMergeStatusEXT.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_TOO_MANY_ATTACHMENTS_EXT = 8
     * }
     */
    public static int VK_SUBPASS_MERGE_STATUS_NOT_MERGED_TOO_MANY_ATTACHMENTS_EXT() {
        return VK_SUBPASS_MERGE_STATUS_NOT_MERGED_TOO_MANY_ATTACHMENTS_EXT;
    }
    private static final int VK_SUBPASS_MERGE_STATUS_NOT_MERGED_INSUFFICIENT_STORAGE_EXT = (int)9L;
    /**
     * {@snippet lang=c :
     * enum VkSubpassMergeStatusEXT.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_INSUFFICIENT_STORAGE_EXT = 9
     * }
     */
    public static int VK_SUBPASS_MERGE_STATUS_NOT_MERGED_INSUFFICIENT_STORAGE_EXT() {
        return VK_SUBPASS_MERGE_STATUS_NOT_MERGED_INSUFFICIENT_STORAGE_EXT;
    }
    private static final int VK_SUBPASS_MERGE_STATUS_NOT_MERGED_DEPTH_STENCIL_COUNT_EXT = (int)10L;
    /**
     * {@snippet lang=c :
     * enum VkSubpassMergeStatusEXT.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_DEPTH_STENCIL_COUNT_EXT = 10
     * }
     */
    public static int VK_SUBPASS_MERGE_STATUS_NOT_MERGED_DEPTH_STENCIL_COUNT_EXT() {
        return VK_SUBPASS_MERGE_STATUS_NOT_MERGED_DEPTH_STENCIL_COUNT_EXT;
    }
    private static final int VK_SUBPASS_MERGE_STATUS_NOT_MERGED_RESOLVE_ATTACHMENT_REUSE_EXT = (int)11L;
    /**
     * {@snippet lang=c :
     * enum VkSubpassMergeStatusEXT.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_RESOLVE_ATTACHMENT_REUSE_EXT = 11
     * }
     */
    public static int VK_SUBPASS_MERGE_STATUS_NOT_MERGED_RESOLVE_ATTACHMENT_REUSE_EXT() {
        return VK_SUBPASS_MERGE_STATUS_NOT_MERGED_RESOLVE_ATTACHMENT_REUSE_EXT;
    }
    private static final int VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SINGLE_SUBPASS_EXT = (int)12L;
    /**
     * {@snippet lang=c :
     * enum VkSubpassMergeStatusEXT.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SINGLE_SUBPASS_EXT = 12
     * }
     */
    public static int VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SINGLE_SUBPASS_EXT() {
        return VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SINGLE_SUBPASS_EXT;
    }
    private static final int VK_SUBPASS_MERGE_STATUS_NOT_MERGED_UNSPECIFIED_EXT = (int)13L;
    /**
     * {@snippet lang=c :
     * enum VkSubpassMergeStatusEXT.VK_SUBPASS_MERGE_STATUS_NOT_MERGED_UNSPECIFIED_EXT = 13
     * }
     */
    public static int VK_SUBPASS_MERGE_STATUS_NOT_MERGED_UNSPECIFIED_EXT() {
        return VK_SUBPASS_MERGE_STATUS_NOT_MERGED_UNSPECIFIED_EXT;
    }
    private static final int VK_SUBPASS_MERGE_STATUS_MAX_ENUM_EXT = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkSubpassMergeStatusEXT.VK_SUBPASS_MERGE_STATUS_MAX_ENUM_EXT = 2147483647
     * }
     */
    public static int VK_SUBPASS_MERGE_STATUS_MAX_ENUM_EXT() {
        return VK_SUBPASS_MERGE_STATUS_MAX_ENUM_EXT;
    }
    private static final int VK_DIRECT_DRIVER_LOADING_MODE_EXCLUSIVE_LUNARG = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkDirectDriverLoadingModeLUNARG.VK_DIRECT_DRIVER_LOADING_MODE_EXCLUSIVE_LUNARG = 0
     * }
     */
    public static int VK_DIRECT_DRIVER_LOADING_MODE_EXCLUSIVE_LUNARG() {
        return VK_DIRECT_DRIVER_LOADING_MODE_EXCLUSIVE_LUNARG;
    }
    private static final int VK_DIRECT_DRIVER_LOADING_MODE_INCLUSIVE_LUNARG = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkDirectDriverLoadingModeLUNARG.VK_DIRECT_DRIVER_LOADING_MODE_INCLUSIVE_LUNARG = 1
     * }
     */
    public static int VK_DIRECT_DRIVER_LOADING_MODE_INCLUSIVE_LUNARG() {
        return VK_DIRECT_DRIVER_LOADING_MODE_INCLUSIVE_LUNARG;
    }
    private static final int VK_DIRECT_DRIVER_LOADING_MODE_MAX_ENUM_LUNARG = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkDirectDriverLoadingModeLUNARG.VK_DIRECT_DRIVER_LOADING_MODE_MAX_ENUM_LUNARG = 2147483647
     * }
     */
    public static int VK_DIRECT_DRIVER_LOADING_MODE_MAX_ENUM_LUNARG() {
        return VK_DIRECT_DRIVER_LOADING_MODE_MAX_ENUM_LUNARG;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkDirectDriverLoadingFlagsLUNARG
     * }
     */
    public static final OfInt VkDirectDriverLoadingFlagsLUNARG = vulkan_h.C_INT;

    private static class vkGetShaderModuleIdentifierEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkGetShaderModuleIdentifierEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkGetShaderModuleIdentifierEXT(VkDevice device, VkShaderModule shaderModule, VkShaderModuleIdentifierEXT *pIdentifier)
     * }
     */
    public static FunctionDescriptor vkGetShaderModuleIdentifierEXT$descriptor() {
        return vkGetShaderModuleIdentifierEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkGetShaderModuleIdentifierEXT(VkDevice device, VkShaderModule shaderModule, VkShaderModuleIdentifierEXT *pIdentifier)
     * }
     */
    public static MethodHandle vkGetShaderModuleIdentifierEXT$handle() {
        return vkGetShaderModuleIdentifierEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkGetShaderModuleIdentifierEXT(VkDevice device, VkShaderModule shaderModule, VkShaderModuleIdentifierEXT *pIdentifier)
     * }
     */
    public static void vkGetShaderModuleIdentifierEXT(MemorySegment device, MemorySegment shaderModule, MemorySegment pIdentifier) {
        var mh$ = vkGetShaderModuleIdentifierEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetShaderModuleIdentifierEXT", device, shaderModule, pIdentifier);
            }
            mh$.invokeExact(device, shaderModule, pIdentifier);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetShaderModuleCreateInfoIdentifierEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkGetShaderModuleCreateInfoIdentifierEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkGetShaderModuleCreateInfoIdentifierEXT(VkDevice device, const VkShaderModuleCreateInfo *pCreateInfo, VkShaderModuleIdentifierEXT *pIdentifier)
     * }
     */
    public static FunctionDescriptor vkGetShaderModuleCreateInfoIdentifierEXT$descriptor() {
        return vkGetShaderModuleCreateInfoIdentifierEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkGetShaderModuleCreateInfoIdentifierEXT(VkDevice device, const VkShaderModuleCreateInfo *pCreateInfo, VkShaderModuleIdentifierEXT *pIdentifier)
     * }
     */
    public static MethodHandle vkGetShaderModuleCreateInfoIdentifierEXT$handle() {
        return vkGetShaderModuleCreateInfoIdentifierEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkGetShaderModuleCreateInfoIdentifierEXT(VkDevice device, const VkShaderModuleCreateInfo *pCreateInfo, VkShaderModuleIdentifierEXT *pIdentifier)
     * }
     */
    public static void vkGetShaderModuleCreateInfoIdentifierEXT(MemorySegment device, MemorySegment pCreateInfo, MemorySegment pIdentifier) {
        var mh$ = vkGetShaderModuleCreateInfoIdentifierEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetShaderModuleCreateInfoIdentifierEXT", device, pCreateInfo, pIdentifier);
            }
            mh$.invokeExact(device, pCreateInfo, pIdentifier);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct VkOpticalFlowSessionNV_T *VkOpticalFlowSessionNV
     * }
     */
    public static final AddressLayout VkOpticalFlowSessionNV = vulkan_h.C_POINTER;
    private static final int VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_UNKNOWN_NV = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkOpticalFlowPerformanceLevelNV.VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_UNKNOWN_NV = 0
     * }
     */
    public static int VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_UNKNOWN_NV() {
        return VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_UNKNOWN_NV;
    }
    private static final int VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_SLOW_NV = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkOpticalFlowPerformanceLevelNV.VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_SLOW_NV = 1
     * }
     */
    public static int VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_SLOW_NV() {
        return VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_SLOW_NV;
    }
    private static final int VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_MEDIUM_NV = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkOpticalFlowPerformanceLevelNV.VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_MEDIUM_NV = 2
     * }
     */
    public static int VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_MEDIUM_NV() {
        return VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_MEDIUM_NV;
    }
    private static final int VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_FAST_NV = (int)3L;
    /**
     * {@snippet lang=c :
     * enum VkOpticalFlowPerformanceLevelNV.VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_FAST_NV = 3
     * }
     */
    public static int VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_FAST_NV() {
        return VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_FAST_NV;
    }
    private static final int VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_MAX_ENUM_NV = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkOpticalFlowPerformanceLevelNV.VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_MAX_ENUM_NV = 2147483647
     * }
     */
    public static int VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_MAX_ENUM_NV() {
        return VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_MAX_ENUM_NV;
    }
    private static final int VK_OPTICAL_FLOW_SESSION_BINDING_POINT_UNKNOWN_NV = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkOpticalFlowSessionBindingPointNV.VK_OPTICAL_FLOW_SESSION_BINDING_POINT_UNKNOWN_NV = 0
     * }
     */
    public static int VK_OPTICAL_FLOW_SESSION_BINDING_POINT_UNKNOWN_NV() {
        return VK_OPTICAL_FLOW_SESSION_BINDING_POINT_UNKNOWN_NV;
    }
    private static final int VK_OPTICAL_FLOW_SESSION_BINDING_POINT_INPUT_NV = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkOpticalFlowSessionBindingPointNV.VK_OPTICAL_FLOW_SESSION_BINDING_POINT_INPUT_NV = 1
     * }
     */
    public static int VK_OPTICAL_FLOW_SESSION_BINDING_POINT_INPUT_NV() {
        return VK_OPTICAL_FLOW_SESSION_BINDING_POINT_INPUT_NV;
    }
    private static final int VK_OPTICAL_FLOW_SESSION_BINDING_POINT_REFERENCE_NV = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkOpticalFlowSessionBindingPointNV.VK_OPTICAL_FLOW_SESSION_BINDING_POINT_REFERENCE_NV = 2
     * }
     */
    public static int VK_OPTICAL_FLOW_SESSION_BINDING_POINT_REFERENCE_NV() {
        return VK_OPTICAL_FLOW_SESSION_BINDING_POINT_REFERENCE_NV;
    }
    private static final int VK_OPTICAL_FLOW_SESSION_BINDING_POINT_HINT_NV = (int)3L;
    /**
     * {@snippet lang=c :
     * enum VkOpticalFlowSessionBindingPointNV.VK_OPTICAL_FLOW_SESSION_BINDING_POINT_HINT_NV = 3
     * }
     */
    public static int VK_OPTICAL_FLOW_SESSION_BINDING_POINT_HINT_NV() {
        return VK_OPTICAL_FLOW_SESSION_BINDING_POINT_HINT_NV;
    }
    private static final int VK_OPTICAL_FLOW_SESSION_BINDING_POINT_FLOW_VECTOR_NV = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkOpticalFlowSessionBindingPointNV.VK_OPTICAL_FLOW_SESSION_BINDING_POINT_FLOW_VECTOR_NV = 4
     * }
     */
    public static int VK_OPTICAL_FLOW_SESSION_BINDING_POINT_FLOW_VECTOR_NV() {
        return VK_OPTICAL_FLOW_SESSION_BINDING_POINT_FLOW_VECTOR_NV;
    }
    private static final int VK_OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_FLOW_VECTOR_NV = (int)5L;
    /**
     * {@snippet lang=c :
     * enum VkOpticalFlowSessionBindingPointNV.VK_OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_FLOW_VECTOR_NV = 5
     * }
     */
    public static int VK_OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_FLOW_VECTOR_NV() {
        return VK_OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_FLOW_VECTOR_NV;
    }
    private static final int VK_OPTICAL_FLOW_SESSION_BINDING_POINT_COST_NV = (int)6L;
    /**
     * {@snippet lang=c :
     * enum VkOpticalFlowSessionBindingPointNV.VK_OPTICAL_FLOW_SESSION_BINDING_POINT_COST_NV = 6
     * }
     */
    public static int VK_OPTICAL_FLOW_SESSION_BINDING_POINT_COST_NV() {
        return VK_OPTICAL_FLOW_SESSION_BINDING_POINT_COST_NV;
    }
    private static final int VK_OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_COST_NV = (int)7L;
    /**
     * {@snippet lang=c :
     * enum VkOpticalFlowSessionBindingPointNV.VK_OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_COST_NV = 7
     * }
     */
    public static int VK_OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_COST_NV() {
        return VK_OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_COST_NV;
    }
    private static final int VK_OPTICAL_FLOW_SESSION_BINDING_POINT_GLOBAL_FLOW_NV = (int)8L;
    /**
     * {@snippet lang=c :
     * enum VkOpticalFlowSessionBindingPointNV.VK_OPTICAL_FLOW_SESSION_BINDING_POINT_GLOBAL_FLOW_NV = 8
     * }
     */
    public static int VK_OPTICAL_FLOW_SESSION_BINDING_POINT_GLOBAL_FLOW_NV() {
        return VK_OPTICAL_FLOW_SESSION_BINDING_POINT_GLOBAL_FLOW_NV;
    }
    private static final int VK_OPTICAL_FLOW_SESSION_BINDING_POINT_MAX_ENUM_NV = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkOpticalFlowSessionBindingPointNV.VK_OPTICAL_FLOW_SESSION_BINDING_POINT_MAX_ENUM_NV = 2147483647
     * }
     */
    public static int VK_OPTICAL_FLOW_SESSION_BINDING_POINT_MAX_ENUM_NV() {
        return VK_OPTICAL_FLOW_SESSION_BINDING_POINT_MAX_ENUM_NV;
    }
    private static final int VK_OPTICAL_FLOW_GRID_SIZE_UNKNOWN_NV = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkOpticalFlowGridSizeFlagBitsNV.VK_OPTICAL_FLOW_GRID_SIZE_UNKNOWN_NV = 0
     * }
     */
    public static int VK_OPTICAL_FLOW_GRID_SIZE_UNKNOWN_NV() {
        return VK_OPTICAL_FLOW_GRID_SIZE_UNKNOWN_NV;
    }
    private static final int VK_OPTICAL_FLOW_GRID_SIZE_1X1_BIT_NV = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkOpticalFlowGridSizeFlagBitsNV.VK_OPTICAL_FLOW_GRID_SIZE_1X1_BIT_NV = 1
     * }
     */
    public static int VK_OPTICAL_FLOW_GRID_SIZE_1X1_BIT_NV() {
        return VK_OPTICAL_FLOW_GRID_SIZE_1X1_BIT_NV;
    }
    private static final int VK_OPTICAL_FLOW_GRID_SIZE_2X2_BIT_NV = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkOpticalFlowGridSizeFlagBitsNV.VK_OPTICAL_FLOW_GRID_SIZE_2X2_BIT_NV = 2
     * }
     */
    public static int VK_OPTICAL_FLOW_GRID_SIZE_2X2_BIT_NV() {
        return VK_OPTICAL_FLOW_GRID_SIZE_2X2_BIT_NV;
    }
    private static final int VK_OPTICAL_FLOW_GRID_SIZE_4X4_BIT_NV = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkOpticalFlowGridSizeFlagBitsNV.VK_OPTICAL_FLOW_GRID_SIZE_4X4_BIT_NV = 4
     * }
     */
    public static int VK_OPTICAL_FLOW_GRID_SIZE_4X4_BIT_NV() {
        return VK_OPTICAL_FLOW_GRID_SIZE_4X4_BIT_NV;
    }
    private static final int VK_OPTICAL_FLOW_GRID_SIZE_8X8_BIT_NV = (int)8L;
    /**
     * {@snippet lang=c :
     * enum VkOpticalFlowGridSizeFlagBitsNV.VK_OPTICAL_FLOW_GRID_SIZE_8X8_BIT_NV = 8
     * }
     */
    public static int VK_OPTICAL_FLOW_GRID_SIZE_8X8_BIT_NV() {
        return VK_OPTICAL_FLOW_GRID_SIZE_8X8_BIT_NV;
    }
    private static final int VK_OPTICAL_FLOW_GRID_SIZE_FLAG_BITS_MAX_ENUM_NV = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkOpticalFlowGridSizeFlagBitsNV.VK_OPTICAL_FLOW_GRID_SIZE_FLAG_BITS_MAX_ENUM_NV = 2147483647
     * }
     */
    public static int VK_OPTICAL_FLOW_GRID_SIZE_FLAG_BITS_MAX_ENUM_NV() {
        return VK_OPTICAL_FLOW_GRID_SIZE_FLAG_BITS_MAX_ENUM_NV;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkOpticalFlowGridSizeFlagsNV
     * }
     */
    public static final OfInt VkOpticalFlowGridSizeFlagsNV = vulkan_h.C_INT;
    private static final int VK_OPTICAL_FLOW_USAGE_UNKNOWN_NV = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkOpticalFlowUsageFlagBitsNV.VK_OPTICAL_FLOW_USAGE_UNKNOWN_NV = 0
     * }
     */
    public static int VK_OPTICAL_FLOW_USAGE_UNKNOWN_NV() {
        return VK_OPTICAL_FLOW_USAGE_UNKNOWN_NV;
    }
    private static final int VK_OPTICAL_FLOW_USAGE_INPUT_BIT_NV = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkOpticalFlowUsageFlagBitsNV.VK_OPTICAL_FLOW_USAGE_INPUT_BIT_NV = 1
     * }
     */
    public static int VK_OPTICAL_FLOW_USAGE_INPUT_BIT_NV() {
        return VK_OPTICAL_FLOW_USAGE_INPUT_BIT_NV;
    }
    private static final int VK_OPTICAL_FLOW_USAGE_OUTPUT_BIT_NV = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkOpticalFlowUsageFlagBitsNV.VK_OPTICAL_FLOW_USAGE_OUTPUT_BIT_NV = 2
     * }
     */
    public static int VK_OPTICAL_FLOW_USAGE_OUTPUT_BIT_NV() {
        return VK_OPTICAL_FLOW_USAGE_OUTPUT_BIT_NV;
    }
    private static final int VK_OPTICAL_FLOW_USAGE_HINT_BIT_NV = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkOpticalFlowUsageFlagBitsNV.VK_OPTICAL_FLOW_USAGE_HINT_BIT_NV = 4
     * }
     */
    public static int VK_OPTICAL_FLOW_USAGE_HINT_BIT_NV() {
        return VK_OPTICAL_FLOW_USAGE_HINT_BIT_NV;
    }
    private static final int VK_OPTICAL_FLOW_USAGE_COST_BIT_NV = (int)8L;
    /**
     * {@snippet lang=c :
     * enum VkOpticalFlowUsageFlagBitsNV.VK_OPTICAL_FLOW_USAGE_COST_BIT_NV = 8
     * }
     */
    public static int VK_OPTICAL_FLOW_USAGE_COST_BIT_NV() {
        return VK_OPTICAL_FLOW_USAGE_COST_BIT_NV;
    }
    private static final int VK_OPTICAL_FLOW_USAGE_GLOBAL_FLOW_BIT_NV = (int)16L;
    /**
     * {@snippet lang=c :
     * enum VkOpticalFlowUsageFlagBitsNV.VK_OPTICAL_FLOW_USAGE_GLOBAL_FLOW_BIT_NV = 16
     * }
     */
    public static int VK_OPTICAL_FLOW_USAGE_GLOBAL_FLOW_BIT_NV() {
        return VK_OPTICAL_FLOW_USAGE_GLOBAL_FLOW_BIT_NV;
    }
    private static final int VK_OPTICAL_FLOW_USAGE_FLAG_BITS_MAX_ENUM_NV = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkOpticalFlowUsageFlagBitsNV.VK_OPTICAL_FLOW_USAGE_FLAG_BITS_MAX_ENUM_NV = 2147483647
     * }
     */
    public static int VK_OPTICAL_FLOW_USAGE_FLAG_BITS_MAX_ENUM_NV() {
        return VK_OPTICAL_FLOW_USAGE_FLAG_BITS_MAX_ENUM_NV;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkOpticalFlowUsageFlagsNV
     * }
     */
    public static final OfInt VkOpticalFlowUsageFlagsNV = vulkan_h.C_INT;
    private static final int VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_HINT_BIT_NV = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkOpticalFlowSessionCreateFlagBitsNV.VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_HINT_BIT_NV = 1
     * }
     */
    public static int VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_HINT_BIT_NV() {
        return VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_HINT_BIT_NV;
    }
    private static final int VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_COST_BIT_NV = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkOpticalFlowSessionCreateFlagBitsNV.VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_COST_BIT_NV = 2
     * }
     */
    public static int VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_COST_BIT_NV() {
        return VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_COST_BIT_NV;
    }
    private static final int VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_GLOBAL_FLOW_BIT_NV = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkOpticalFlowSessionCreateFlagBitsNV.VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_GLOBAL_FLOW_BIT_NV = 4
     * }
     */
    public static int VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_GLOBAL_FLOW_BIT_NV() {
        return VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_GLOBAL_FLOW_BIT_NV;
    }
    private static final int VK_OPTICAL_FLOW_SESSION_CREATE_ALLOW_REGIONS_BIT_NV = (int)8L;
    /**
     * {@snippet lang=c :
     * enum VkOpticalFlowSessionCreateFlagBitsNV.VK_OPTICAL_FLOW_SESSION_CREATE_ALLOW_REGIONS_BIT_NV = 8
     * }
     */
    public static int VK_OPTICAL_FLOW_SESSION_CREATE_ALLOW_REGIONS_BIT_NV() {
        return VK_OPTICAL_FLOW_SESSION_CREATE_ALLOW_REGIONS_BIT_NV;
    }
    private static final int VK_OPTICAL_FLOW_SESSION_CREATE_BOTH_DIRECTIONS_BIT_NV = (int)16L;
    /**
     * {@snippet lang=c :
     * enum VkOpticalFlowSessionCreateFlagBitsNV.VK_OPTICAL_FLOW_SESSION_CREATE_BOTH_DIRECTIONS_BIT_NV = 16
     * }
     */
    public static int VK_OPTICAL_FLOW_SESSION_CREATE_BOTH_DIRECTIONS_BIT_NV() {
        return VK_OPTICAL_FLOW_SESSION_CREATE_BOTH_DIRECTIONS_BIT_NV;
    }
    private static final int VK_OPTICAL_FLOW_SESSION_CREATE_FLAG_BITS_MAX_ENUM_NV = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkOpticalFlowSessionCreateFlagBitsNV.VK_OPTICAL_FLOW_SESSION_CREATE_FLAG_BITS_MAX_ENUM_NV = 2147483647
     * }
     */
    public static int VK_OPTICAL_FLOW_SESSION_CREATE_FLAG_BITS_MAX_ENUM_NV() {
        return VK_OPTICAL_FLOW_SESSION_CREATE_FLAG_BITS_MAX_ENUM_NV;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkOpticalFlowSessionCreateFlagsNV
     * }
     */
    public static final OfInt VkOpticalFlowSessionCreateFlagsNV = vulkan_h.C_INT;
    private static final int VK_OPTICAL_FLOW_EXECUTE_DISABLE_TEMPORAL_HINTS_BIT_NV = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkOpticalFlowExecuteFlagBitsNV.VK_OPTICAL_FLOW_EXECUTE_DISABLE_TEMPORAL_HINTS_BIT_NV = 1
     * }
     */
    public static int VK_OPTICAL_FLOW_EXECUTE_DISABLE_TEMPORAL_HINTS_BIT_NV() {
        return VK_OPTICAL_FLOW_EXECUTE_DISABLE_TEMPORAL_HINTS_BIT_NV;
    }
    private static final int VK_OPTICAL_FLOW_EXECUTE_FLAG_BITS_MAX_ENUM_NV = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkOpticalFlowExecuteFlagBitsNV.VK_OPTICAL_FLOW_EXECUTE_FLAG_BITS_MAX_ENUM_NV = 2147483647
     * }
     */
    public static int VK_OPTICAL_FLOW_EXECUTE_FLAG_BITS_MAX_ENUM_NV() {
        return VK_OPTICAL_FLOW_EXECUTE_FLAG_BITS_MAX_ENUM_NV;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkOpticalFlowExecuteFlagsNV
     * }
     */
    public static final OfInt VkOpticalFlowExecuteFlagsNV = vulkan_h.C_INT;

    private static class vkGetPhysicalDeviceOpticalFlowImageFormatsNV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkGetPhysicalDeviceOpticalFlowImageFormatsNV"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceOpticalFlowImageFormatsNV(VkPhysicalDevice physicalDevice, const VkOpticalFlowImageFormatInfoNV *pOpticalFlowImageFormatInfo, uint32_t *pFormatCount, VkOpticalFlowImageFormatPropertiesNV *pImageFormatProperties)
     * }
     */
    public static FunctionDescriptor vkGetPhysicalDeviceOpticalFlowImageFormatsNV$descriptor() {
        return vkGetPhysicalDeviceOpticalFlowImageFormatsNV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceOpticalFlowImageFormatsNV(VkPhysicalDevice physicalDevice, const VkOpticalFlowImageFormatInfoNV *pOpticalFlowImageFormatInfo, uint32_t *pFormatCount, VkOpticalFlowImageFormatPropertiesNV *pImageFormatProperties)
     * }
     */
    public static MethodHandle vkGetPhysicalDeviceOpticalFlowImageFormatsNV$handle() {
        return vkGetPhysicalDeviceOpticalFlowImageFormatsNV.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceOpticalFlowImageFormatsNV(VkPhysicalDevice physicalDevice, const VkOpticalFlowImageFormatInfoNV *pOpticalFlowImageFormatInfo, uint32_t *pFormatCount, VkOpticalFlowImageFormatPropertiesNV *pImageFormatProperties)
     * }
     */
    public static int vkGetPhysicalDeviceOpticalFlowImageFormatsNV(MemorySegment physicalDevice, MemorySegment pOpticalFlowImageFormatInfo, MemorySegment pFormatCount, MemorySegment pImageFormatProperties) {
        var mh$ = vkGetPhysicalDeviceOpticalFlowImageFormatsNV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetPhysicalDeviceOpticalFlowImageFormatsNV", physicalDevice, pOpticalFlowImageFormatInfo, pFormatCount, pImageFormatProperties);
            }
            return (int)mh$.invokeExact(physicalDevice, pOpticalFlowImageFormatInfo, pFormatCount, pImageFormatProperties);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCreateOpticalFlowSessionNV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCreateOpticalFlowSessionNV"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkCreateOpticalFlowSessionNV(VkDevice device, const VkOpticalFlowSessionCreateInfoNV *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkOpticalFlowSessionNV *pSession)
     * }
     */
    public static FunctionDescriptor vkCreateOpticalFlowSessionNV$descriptor() {
        return vkCreateOpticalFlowSessionNV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkCreateOpticalFlowSessionNV(VkDevice device, const VkOpticalFlowSessionCreateInfoNV *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkOpticalFlowSessionNV *pSession)
     * }
     */
    public static MethodHandle vkCreateOpticalFlowSessionNV$handle() {
        return vkCreateOpticalFlowSessionNV.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * VkResult vkCreateOpticalFlowSessionNV(VkDevice device, const VkOpticalFlowSessionCreateInfoNV *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkOpticalFlowSessionNV *pSession)
     * }
     */
    public static int vkCreateOpticalFlowSessionNV(MemorySegment device, MemorySegment pCreateInfo, MemorySegment pAllocator, MemorySegment pSession) {
        var mh$ = vkCreateOpticalFlowSessionNV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCreateOpticalFlowSessionNV", device, pCreateInfo, pAllocator, pSession);
            }
            return (int)mh$.invokeExact(device, pCreateInfo, pAllocator, pSession);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkDestroyOpticalFlowSessionNV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkDestroyOpticalFlowSessionNV"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkDestroyOpticalFlowSessionNV(VkDevice device, VkOpticalFlowSessionNV session, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static FunctionDescriptor vkDestroyOpticalFlowSessionNV$descriptor() {
        return vkDestroyOpticalFlowSessionNV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkDestroyOpticalFlowSessionNV(VkDevice device, VkOpticalFlowSessionNV session, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static MethodHandle vkDestroyOpticalFlowSessionNV$handle() {
        return vkDestroyOpticalFlowSessionNV.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkDestroyOpticalFlowSessionNV(VkDevice device, VkOpticalFlowSessionNV session, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static void vkDestroyOpticalFlowSessionNV(MemorySegment device, MemorySegment session, MemorySegment pAllocator) {
        var mh$ = vkDestroyOpticalFlowSessionNV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkDestroyOpticalFlowSessionNV", device, session, pAllocator);
            }
            mh$.invokeExact(device, session, pAllocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkBindOpticalFlowSessionImageNV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkBindOpticalFlowSessionImageNV"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkBindOpticalFlowSessionImageNV(VkDevice device, VkOpticalFlowSessionNV session, VkOpticalFlowSessionBindingPointNV bindingPoint, VkImageView view, VkImageLayout layout)
     * }
     */
    public static FunctionDescriptor vkBindOpticalFlowSessionImageNV$descriptor() {
        return vkBindOpticalFlowSessionImageNV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkBindOpticalFlowSessionImageNV(VkDevice device, VkOpticalFlowSessionNV session, VkOpticalFlowSessionBindingPointNV bindingPoint, VkImageView view, VkImageLayout layout)
     * }
     */
    public static MethodHandle vkBindOpticalFlowSessionImageNV$handle() {
        return vkBindOpticalFlowSessionImageNV.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * VkResult vkBindOpticalFlowSessionImageNV(VkDevice device, VkOpticalFlowSessionNV session, VkOpticalFlowSessionBindingPointNV bindingPoint, VkImageView view, VkImageLayout layout)
     * }
     */
    public static int vkBindOpticalFlowSessionImageNV(MemorySegment device, MemorySegment session, int bindingPoint, MemorySegment view, int layout) {
        var mh$ = vkBindOpticalFlowSessionImageNV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkBindOpticalFlowSessionImageNV", device, session, bindingPoint, view, layout);
            }
            return (int)mh$.invokeExact(device, session, bindingPoint, view, layout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdOpticalFlowExecuteNV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdOpticalFlowExecuteNV"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdOpticalFlowExecuteNV(VkCommandBuffer commandBuffer, VkOpticalFlowSessionNV session, const VkOpticalFlowExecuteInfoNV *pExecuteInfo)
     * }
     */
    public static FunctionDescriptor vkCmdOpticalFlowExecuteNV$descriptor() {
        return vkCmdOpticalFlowExecuteNV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdOpticalFlowExecuteNV(VkCommandBuffer commandBuffer, VkOpticalFlowSessionNV session, const VkOpticalFlowExecuteInfoNV *pExecuteInfo)
     * }
     */
    public static MethodHandle vkCmdOpticalFlowExecuteNV$handle() {
        return vkCmdOpticalFlowExecuteNV.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdOpticalFlowExecuteNV(VkCommandBuffer commandBuffer, VkOpticalFlowSessionNV session, const VkOpticalFlowExecuteInfoNV *pExecuteInfo)
     * }
     */
    public static void vkCmdOpticalFlowExecuteNV(MemorySegment commandBuffer, MemorySegment session, MemorySegment pExecuteInfo) {
        var mh$ = vkCmdOpticalFlowExecuteNV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdOpticalFlowExecuteNV", commandBuffer, session, pExecuteInfo);
            }
            mh$.invokeExact(commandBuffer, session, pExecuteInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct VkShaderEXT_T *VkShaderEXT
     * }
     */
    public static final AddressLayout VkShaderEXT = vulkan_h.C_POINTER;
    private static final int VK_SHADER_CODE_TYPE_BINARY_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkShaderCodeTypeEXT.VK_SHADER_CODE_TYPE_BINARY_EXT = 0
     * }
     */
    public static int VK_SHADER_CODE_TYPE_BINARY_EXT() {
        return VK_SHADER_CODE_TYPE_BINARY_EXT;
    }
    private static final int VK_SHADER_CODE_TYPE_SPIRV_EXT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkShaderCodeTypeEXT.VK_SHADER_CODE_TYPE_SPIRV_EXT = 1
     * }
     */
    public static int VK_SHADER_CODE_TYPE_SPIRV_EXT() {
        return VK_SHADER_CODE_TYPE_SPIRV_EXT;
    }
    private static final int VK_SHADER_CODE_TYPE_MAX_ENUM_EXT = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkShaderCodeTypeEXT.VK_SHADER_CODE_TYPE_MAX_ENUM_EXT = 2147483647
     * }
     */
    public static int VK_SHADER_CODE_TYPE_MAX_ENUM_EXT() {
        return VK_SHADER_CODE_TYPE_MAX_ENUM_EXT;
    }
    private static final int VK_SHADER_CREATE_LINK_STAGE_BIT_EXT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkShaderCreateFlagBitsEXT.VK_SHADER_CREATE_LINK_STAGE_BIT_EXT = 1
     * }
     */
    public static int VK_SHADER_CREATE_LINK_STAGE_BIT_EXT() {
        return VK_SHADER_CREATE_LINK_STAGE_BIT_EXT;
    }
    private static final int VK_SHADER_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkShaderCreateFlagBitsEXT.VK_SHADER_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT = 2
     * }
     */
    public static int VK_SHADER_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT() {
        return VK_SHADER_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT;
    }
    private static final int VK_SHADER_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkShaderCreateFlagBitsEXT.VK_SHADER_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT = 4
     * }
     */
    public static int VK_SHADER_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT() {
        return VK_SHADER_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT;
    }
    private static final int VK_SHADER_CREATE_NO_TASK_SHADER_BIT_EXT = (int)8L;
    /**
     * {@snippet lang=c :
     * enum VkShaderCreateFlagBitsEXT.VK_SHADER_CREATE_NO_TASK_SHADER_BIT_EXT = 8
     * }
     */
    public static int VK_SHADER_CREATE_NO_TASK_SHADER_BIT_EXT() {
        return VK_SHADER_CREATE_NO_TASK_SHADER_BIT_EXT;
    }
    private static final int VK_SHADER_CREATE_DISPATCH_BASE_BIT_EXT = (int)16L;
    /**
     * {@snippet lang=c :
     * enum VkShaderCreateFlagBitsEXT.VK_SHADER_CREATE_DISPATCH_BASE_BIT_EXT = 16
     * }
     */
    public static int VK_SHADER_CREATE_DISPATCH_BASE_BIT_EXT() {
        return VK_SHADER_CREATE_DISPATCH_BASE_BIT_EXT;
    }
    private static final int VK_SHADER_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_EXT = (int)32L;
    /**
     * {@snippet lang=c :
     * enum VkShaderCreateFlagBitsEXT.VK_SHADER_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_EXT = 32
     * }
     */
    public static int VK_SHADER_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_EXT() {
        return VK_SHADER_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_EXT;
    }
    private static final int VK_SHADER_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT = (int)64L;
    /**
     * {@snippet lang=c :
     * enum VkShaderCreateFlagBitsEXT.VK_SHADER_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT = 64
     * }
     */
    public static int VK_SHADER_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT() {
        return VK_SHADER_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT;
    }
    private static final int VK_SHADER_CREATE_FLAG_BITS_MAX_ENUM_EXT = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkShaderCreateFlagBitsEXT.VK_SHADER_CREATE_FLAG_BITS_MAX_ENUM_EXT = 2147483647
     * }
     */
    public static int VK_SHADER_CREATE_FLAG_BITS_MAX_ENUM_EXT() {
        return VK_SHADER_CREATE_FLAG_BITS_MAX_ENUM_EXT;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkShaderCreateFlagsEXT
     * }
     */
    public static final OfInt VkShaderCreateFlagsEXT = vulkan_h.C_INT;

    private static class vkCreateShadersEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCreateShadersEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkCreateShadersEXT(VkDevice device, uint32_t createInfoCount, const VkShaderCreateInfoEXT *pCreateInfos, const VkAllocationCallbacks *pAllocator, VkShaderEXT *pShaders)
     * }
     */
    public static FunctionDescriptor vkCreateShadersEXT$descriptor() {
        return vkCreateShadersEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkCreateShadersEXT(VkDevice device, uint32_t createInfoCount, const VkShaderCreateInfoEXT *pCreateInfos, const VkAllocationCallbacks *pAllocator, VkShaderEXT *pShaders)
     * }
     */
    public static MethodHandle vkCreateShadersEXT$handle() {
        return vkCreateShadersEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * VkResult vkCreateShadersEXT(VkDevice device, uint32_t createInfoCount, const VkShaderCreateInfoEXT *pCreateInfos, const VkAllocationCallbacks *pAllocator, VkShaderEXT *pShaders)
     * }
     */
    public static int vkCreateShadersEXT(MemorySegment device, int createInfoCount, MemorySegment pCreateInfos, MemorySegment pAllocator, MemorySegment pShaders) {
        var mh$ = vkCreateShadersEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCreateShadersEXT", device, createInfoCount, pCreateInfos, pAllocator, pShaders);
            }
            return (int)mh$.invokeExact(device, createInfoCount, pCreateInfos, pAllocator, pShaders);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkDestroyShaderEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkDestroyShaderEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkDestroyShaderEXT(VkDevice device, VkShaderEXT shader, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static FunctionDescriptor vkDestroyShaderEXT$descriptor() {
        return vkDestroyShaderEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkDestroyShaderEXT(VkDevice device, VkShaderEXT shader, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static MethodHandle vkDestroyShaderEXT$handle() {
        return vkDestroyShaderEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkDestroyShaderEXT(VkDevice device, VkShaderEXT shader, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static void vkDestroyShaderEXT(MemorySegment device, MemorySegment shader, MemorySegment pAllocator) {
        var mh$ = vkDestroyShaderEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkDestroyShaderEXT", device, shader, pAllocator);
            }
            mh$.invokeExact(device, shader, pAllocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetShaderBinaryDataEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkGetShaderBinaryDataEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkGetShaderBinaryDataEXT(VkDevice device, VkShaderEXT shader, size_t *pDataSize, void *pData)
     * }
     */
    public static FunctionDescriptor vkGetShaderBinaryDataEXT$descriptor() {
        return vkGetShaderBinaryDataEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkGetShaderBinaryDataEXT(VkDevice device, VkShaderEXT shader, size_t *pDataSize, void *pData)
     * }
     */
    public static MethodHandle vkGetShaderBinaryDataEXT$handle() {
        return vkGetShaderBinaryDataEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * VkResult vkGetShaderBinaryDataEXT(VkDevice device, VkShaderEXT shader, size_t *pDataSize, void *pData)
     * }
     */
    public static int vkGetShaderBinaryDataEXT(MemorySegment device, MemorySegment shader, MemorySegment pDataSize, MemorySegment pData) {
        var mh$ = vkGetShaderBinaryDataEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetShaderBinaryDataEXT", device, shader, pDataSize, pData);
            }
            return (int)mh$.invokeExact(device, shader, pDataSize, pData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdBindShadersEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdBindShadersEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdBindShadersEXT(VkCommandBuffer commandBuffer, uint32_t stageCount, const VkShaderStageFlagBits *pStages, const VkShaderEXT *pShaders)
     * }
     */
    public static FunctionDescriptor vkCmdBindShadersEXT$descriptor() {
        return vkCmdBindShadersEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdBindShadersEXT(VkCommandBuffer commandBuffer, uint32_t stageCount, const VkShaderStageFlagBits *pStages, const VkShaderEXT *pShaders)
     * }
     */
    public static MethodHandle vkCmdBindShadersEXT$handle() {
        return vkCmdBindShadersEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdBindShadersEXT(VkCommandBuffer commandBuffer, uint32_t stageCount, const VkShaderStageFlagBits *pStages, const VkShaderEXT *pShaders)
     * }
     */
    public static void vkCmdBindShadersEXT(MemorySegment commandBuffer, int stageCount, MemorySegment pStages, MemorySegment pShaders) {
        var mh$ = vkCmdBindShadersEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdBindShadersEXT", commandBuffer, stageCount, pStages, pShaders);
            }
            mh$.invokeExact(commandBuffer, stageCount, pStages, pShaders);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetFramebufferTilePropertiesQCOM {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkGetFramebufferTilePropertiesQCOM"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkGetFramebufferTilePropertiesQCOM(VkDevice device, VkFramebuffer framebuffer, uint32_t *pPropertiesCount, VkTilePropertiesQCOM *pProperties)
     * }
     */
    public static FunctionDescriptor vkGetFramebufferTilePropertiesQCOM$descriptor() {
        return vkGetFramebufferTilePropertiesQCOM.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkGetFramebufferTilePropertiesQCOM(VkDevice device, VkFramebuffer framebuffer, uint32_t *pPropertiesCount, VkTilePropertiesQCOM *pProperties)
     * }
     */
    public static MethodHandle vkGetFramebufferTilePropertiesQCOM$handle() {
        return vkGetFramebufferTilePropertiesQCOM.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * VkResult vkGetFramebufferTilePropertiesQCOM(VkDevice device, VkFramebuffer framebuffer, uint32_t *pPropertiesCount, VkTilePropertiesQCOM *pProperties)
     * }
     */
    public static int vkGetFramebufferTilePropertiesQCOM(MemorySegment device, MemorySegment framebuffer, MemorySegment pPropertiesCount, MemorySegment pProperties) {
        var mh$ = vkGetFramebufferTilePropertiesQCOM.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetFramebufferTilePropertiesQCOM", device, framebuffer, pPropertiesCount, pProperties);
            }
            return (int)mh$.invokeExact(device, framebuffer, pPropertiesCount, pProperties);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetDynamicRenderingTilePropertiesQCOM {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkGetDynamicRenderingTilePropertiesQCOM"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkGetDynamicRenderingTilePropertiesQCOM(VkDevice device, const VkRenderingInfo *pRenderingInfo, VkTilePropertiesQCOM *pProperties)
     * }
     */
    public static FunctionDescriptor vkGetDynamicRenderingTilePropertiesQCOM$descriptor() {
        return vkGetDynamicRenderingTilePropertiesQCOM.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkGetDynamicRenderingTilePropertiesQCOM(VkDevice device, const VkRenderingInfo *pRenderingInfo, VkTilePropertiesQCOM *pProperties)
     * }
     */
    public static MethodHandle vkGetDynamicRenderingTilePropertiesQCOM$handle() {
        return vkGetDynamicRenderingTilePropertiesQCOM.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * VkResult vkGetDynamicRenderingTilePropertiesQCOM(VkDevice device, const VkRenderingInfo *pRenderingInfo, VkTilePropertiesQCOM *pProperties)
     * }
     */
    public static int vkGetDynamicRenderingTilePropertiesQCOM(MemorySegment device, MemorySegment pRenderingInfo, MemorySegment pProperties) {
        var mh$ = vkGetDynamicRenderingTilePropertiesQCOM.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetDynamicRenderingTilePropertiesQCOM", device, pRenderingInfo, pProperties);
            }
            return (int)mh$.invokeExact(device, pRenderingInfo, pProperties);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int VK_RAY_TRACING_INVOCATION_REORDER_MODE_NONE_NV = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkRayTracingInvocationReorderModeNV.VK_RAY_TRACING_INVOCATION_REORDER_MODE_NONE_NV = 0
     * }
     */
    public static int VK_RAY_TRACING_INVOCATION_REORDER_MODE_NONE_NV() {
        return VK_RAY_TRACING_INVOCATION_REORDER_MODE_NONE_NV;
    }
    private static final int VK_RAY_TRACING_INVOCATION_REORDER_MODE_REORDER_NV = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkRayTracingInvocationReorderModeNV.VK_RAY_TRACING_INVOCATION_REORDER_MODE_REORDER_NV = 1
     * }
     */
    public static int VK_RAY_TRACING_INVOCATION_REORDER_MODE_REORDER_NV() {
        return VK_RAY_TRACING_INVOCATION_REORDER_MODE_REORDER_NV;
    }
    private static final int VK_RAY_TRACING_INVOCATION_REORDER_MODE_MAX_ENUM_NV = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkRayTracingInvocationReorderModeNV.VK_RAY_TRACING_INVOCATION_REORDER_MODE_MAX_ENUM_NV = 2147483647
     * }
     */
    public static int VK_RAY_TRACING_INVOCATION_REORDER_MODE_MAX_ENUM_NV() {
        return VK_RAY_TRACING_INVOCATION_REORDER_MODE_MAX_ENUM_NV;
    }
    private static final int VK_LAYER_SETTING_TYPE_BOOL32_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkLayerSettingTypeEXT.VK_LAYER_SETTING_TYPE_BOOL32_EXT = 0
     * }
     */
    public static int VK_LAYER_SETTING_TYPE_BOOL32_EXT() {
        return VK_LAYER_SETTING_TYPE_BOOL32_EXT;
    }
    private static final int VK_LAYER_SETTING_TYPE_INT32_EXT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkLayerSettingTypeEXT.VK_LAYER_SETTING_TYPE_INT32_EXT = 1
     * }
     */
    public static int VK_LAYER_SETTING_TYPE_INT32_EXT() {
        return VK_LAYER_SETTING_TYPE_INT32_EXT;
    }
    private static final int VK_LAYER_SETTING_TYPE_INT64_EXT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkLayerSettingTypeEXT.VK_LAYER_SETTING_TYPE_INT64_EXT = 2
     * }
     */
    public static int VK_LAYER_SETTING_TYPE_INT64_EXT() {
        return VK_LAYER_SETTING_TYPE_INT64_EXT;
    }
    private static final int VK_LAYER_SETTING_TYPE_UINT32_EXT = (int)3L;
    /**
     * {@snippet lang=c :
     * enum VkLayerSettingTypeEXT.VK_LAYER_SETTING_TYPE_UINT32_EXT = 3
     * }
     */
    public static int VK_LAYER_SETTING_TYPE_UINT32_EXT() {
        return VK_LAYER_SETTING_TYPE_UINT32_EXT;
    }
    private static final int VK_LAYER_SETTING_TYPE_UINT64_EXT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkLayerSettingTypeEXT.VK_LAYER_SETTING_TYPE_UINT64_EXT = 4
     * }
     */
    public static int VK_LAYER_SETTING_TYPE_UINT64_EXT() {
        return VK_LAYER_SETTING_TYPE_UINT64_EXT;
    }
    private static final int VK_LAYER_SETTING_TYPE_FLOAT32_EXT = (int)5L;
    /**
     * {@snippet lang=c :
     * enum VkLayerSettingTypeEXT.VK_LAYER_SETTING_TYPE_FLOAT32_EXT = 5
     * }
     */
    public static int VK_LAYER_SETTING_TYPE_FLOAT32_EXT() {
        return VK_LAYER_SETTING_TYPE_FLOAT32_EXT;
    }
    private static final int VK_LAYER_SETTING_TYPE_FLOAT64_EXT = (int)6L;
    /**
     * {@snippet lang=c :
     * enum VkLayerSettingTypeEXT.VK_LAYER_SETTING_TYPE_FLOAT64_EXT = 6
     * }
     */
    public static int VK_LAYER_SETTING_TYPE_FLOAT64_EXT() {
        return VK_LAYER_SETTING_TYPE_FLOAT64_EXT;
    }
    private static final int VK_LAYER_SETTING_TYPE_STRING_EXT = (int)7L;
    /**
     * {@snippet lang=c :
     * enum VkLayerSettingTypeEXT.VK_LAYER_SETTING_TYPE_STRING_EXT = 7
     * }
     */
    public static int VK_LAYER_SETTING_TYPE_STRING_EXT() {
        return VK_LAYER_SETTING_TYPE_STRING_EXT;
    }
    private static final int VK_LAYER_SETTING_TYPE_MAX_ENUM_EXT = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkLayerSettingTypeEXT.VK_LAYER_SETTING_TYPE_MAX_ENUM_EXT = 2147483647
     * }
     */
    public static int VK_LAYER_SETTING_TYPE_MAX_ENUM_EXT() {
        return VK_LAYER_SETTING_TYPE_MAX_ENUM_EXT;
    }
    private static final int VK_LATENCY_MARKER_SIMULATION_START_NV = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkLatencyMarkerNV.VK_LATENCY_MARKER_SIMULATION_START_NV = 0
     * }
     */
    public static int VK_LATENCY_MARKER_SIMULATION_START_NV() {
        return VK_LATENCY_MARKER_SIMULATION_START_NV;
    }
    private static final int VK_LATENCY_MARKER_SIMULATION_END_NV = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkLatencyMarkerNV.VK_LATENCY_MARKER_SIMULATION_END_NV = 1
     * }
     */
    public static int VK_LATENCY_MARKER_SIMULATION_END_NV() {
        return VK_LATENCY_MARKER_SIMULATION_END_NV;
    }
    private static final int VK_LATENCY_MARKER_RENDERSUBMIT_START_NV = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkLatencyMarkerNV.VK_LATENCY_MARKER_RENDERSUBMIT_START_NV = 2
     * }
     */
    public static int VK_LATENCY_MARKER_RENDERSUBMIT_START_NV() {
        return VK_LATENCY_MARKER_RENDERSUBMIT_START_NV;
    }
    private static final int VK_LATENCY_MARKER_RENDERSUBMIT_END_NV = (int)3L;
    /**
     * {@snippet lang=c :
     * enum VkLatencyMarkerNV.VK_LATENCY_MARKER_RENDERSUBMIT_END_NV = 3
     * }
     */
    public static int VK_LATENCY_MARKER_RENDERSUBMIT_END_NV() {
        return VK_LATENCY_MARKER_RENDERSUBMIT_END_NV;
    }
    private static final int VK_LATENCY_MARKER_PRESENT_START_NV = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkLatencyMarkerNV.VK_LATENCY_MARKER_PRESENT_START_NV = 4
     * }
     */
    public static int VK_LATENCY_MARKER_PRESENT_START_NV() {
        return VK_LATENCY_MARKER_PRESENT_START_NV;
    }
    private static final int VK_LATENCY_MARKER_PRESENT_END_NV = (int)5L;
    /**
     * {@snippet lang=c :
     * enum VkLatencyMarkerNV.VK_LATENCY_MARKER_PRESENT_END_NV = 5
     * }
     */
    public static int VK_LATENCY_MARKER_PRESENT_END_NV() {
        return VK_LATENCY_MARKER_PRESENT_END_NV;
    }
    private static final int VK_LATENCY_MARKER_INPUT_SAMPLE_NV = (int)6L;
    /**
     * {@snippet lang=c :
     * enum VkLatencyMarkerNV.VK_LATENCY_MARKER_INPUT_SAMPLE_NV = 6
     * }
     */
    public static int VK_LATENCY_MARKER_INPUT_SAMPLE_NV() {
        return VK_LATENCY_MARKER_INPUT_SAMPLE_NV;
    }
    private static final int VK_LATENCY_MARKER_TRIGGER_FLASH_NV = (int)7L;
    /**
     * {@snippet lang=c :
     * enum VkLatencyMarkerNV.VK_LATENCY_MARKER_TRIGGER_FLASH_NV = 7
     * }
     */
    public static int VK_LATENCY_MARKER_TRIGGER_FLASH_NV() {
        return VK_LATENCY_MARKER_TRIGGER_FLASH_NV;
    }
    private static final int VK_LATENCY_MARKER_OUT_OF_BAND_RENDERSUBMIT_START_NV = (int)8L;
    /**
     * {@snippet lang=c :
     * enum VkLatencyMarkerNV.VK_LATENCY_MARKER_OUT_OF_BAND_RENDERSUBMIT_START_NV = 8
     * }
     */
    public static int VK_LATENCY_MARKER_OUT_OF_BAND_RENDERSUBMIT_START_NV() {
        return VK_LATENCY_MARKER_OUT_OF_BAND_RENDERSUBMIT_START_NV;
    }
    private static final int VK_LATENCY_MARKER_OUT_OF_BAND_RENDERSUBMIT_END_NV = (int)9L;
    /**
     * {@snippet lang=c :
     * enum VkLatencyMarkerNV.VK_LATENCY_MARKER_OUT_OF_BAND_RENDERSUBMIT_END_NV = 9
     * }
     */
    public static int VK_LATENCY_MARKER_OUT_OF_BAND_RENDERSUBMIT_END_NV() {
        return VK_LATENCY_MARKER_OUT_OF_BAND_RENDERSUBMIT_END_NV;
    }
    private static final int VK_LATENCY_MARKER_OUT_OF_BAND_PRESENT_START_NV = (int)10L;
    /**
     * {@snippet lang=c :
     * enum VkLatencyMarkerNV.VK_LATENCY_MARKER_OUT_OF_BAND_PRESENT_START_NV = 10
     * }
     */
    public static int VK_LATENCY_MARKER_OUT_OF_BAND_PRESENT_START_NV() {
        return VK_LATENCY_MARKER_OUT_OF_BAND_PRESENT_START_NV;
    }
    private static final int VK_LATENCY_MARKER_OUT_OF_BAND_PRESENT_END_NV = (int)11L;
    /**
     * {@snippet lang=c :
     * enum VkLatencyMarkerNV.VK_LATENCY_MARKER_OUT_OF_BAND_PRESENT_END_NV = 11
     * }
     */
    public static int VK_LATENCY_MARKER_OUT_OF_BAND_PRESENT_END_NV() {
        return VK_LATENCY_MARKER_OUT_OF_BAND_PRESENT_END_NV;
    }
    private static final int VK_LATENCY_MARKER_MAX_ENUM_NV = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkLatencyMarkerNV.VK_LATENCY_MARKER_MAX_ENUM_NV = 2147483647
     * }
     */
    public static int VK_LATENCY_MARKER_MAX_ENUM_NV() {
        return VK_LATENCY_MARKER_MAX_ENUM_NV;
    }
    private static final int VK_OUT_OF_BAND_QUEUE_TYPE_RENDER_NV = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkOutOfBandQueueTypeNV.VK_OUT_OF_BAND_QUEUE_TYPE_RENDER_NV = 0
     * }
     */
    public static int VK_OUT_OF_BAND_QUEUE_TYPE_RENDER_NV() {
        return VK_OUT_OF_BAND_QUEUE_TYPE_RENDER_NV;
    }
    private static final int VK_OUT_OF_BAND_QUEUE_TYPE_PRESENT_NV = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkOutOfBandQueueTypeNV.VK_OUT_OF_BAND_QUEUE_TYPE_PRESENT_NV = 1
     * }
     */
    public static int VK_OUT_OF_BAND_QUEUE_TYPE_PRESENT_NV() {
        return VK_OUT_OF_BAND_QUEUE_TYPE_PRESENT_NV;
    }
    private static final int VK_OUT_OF_BAND_QUEUE_TYPE_MAX_ENUM_NV = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkOutOfBandQueueTypeNV.VK_OUT_OF_BAND_QUEUE_TYPE_MAX_ENUM_NV = 2147483647
     * }
     */
    public static int VK_OUT_OF_BAND_QUEUE_TYPE_MAX_ENUM_NV() {
        return VK_OUT_OF_BAND_QUEUE_TYPE_MAX_ENUM_NV;
    }

    private static class vkSetLatencySleepModeNV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkSetLatencySleepModeNV"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkSetLatencySleepModeNV(VkDevice device, VkSwapchainKHR swapchain, const VkLatencySleepModeInfoNV *pSleepModeInfo)
     * }
     */
    public static FunctionDescriptor vkSetLatencySleepModeNV$descriptor() {
        return vkSetLatencySleepModeNV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkSetLatencySleepModeNV(VkDevice device, VkSwapchainKHR swapchain, const VkLatencySleepModeInfoNV *pSleepModeInfo)
     * }
     */
    public static MethodHandle vkSetLatencySleepModeNV$handle() {
        return vkSetLatencySleepModeNV.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * VkResult vkSetLatencySleepModeNV(VkDevice device, VkSwapchainKHR swapchain, const VkLatencySleepModeInfoNV *pSleepModeInfo)
     * }
     */
    public static int vkSetLatencySleepModeNV(MemorySegment device, MemorySegment swapchain, MemorySegment pSleepModeInfo) {
        var mh$ = vkSetLatencySleepModeNV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkSetLatencySleepModeNV", device, swapchain, pSleepModeInfo);
            }
            return (int)mh$.invokeExact(device, swapchain, pSleepModeInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkLatencySleepNV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkLatencySleepNV"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkLatencySleepNV(VkDevice device, VkSwapchainKHR swapchain, const VkLatencySleepInfoNV *pSleepInfo)
     * }
     */
    public static FunctionDescriptor vkLatencySleepNV$descriptor() {
        return vkLatencySleepNV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkLatencySleepNV(VkDevice device, VkSwapchainKHR swapchain, const VkLatencySleepInfoNV *pSleepInfo)
     * }
     */
    public static MethodHandle vkLatencySleepNV$handle() {
        return vkLatencySleepNV.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * VkResult vkLatencySleepNV(VkDevice device, VkSwapchainKHR swapchain, const VkLatencySleepInfoNV *pSleepInfo)
     * }
     */
    public static int vkLatencySleepNV(MemorySegment device, MemorySegment swapchain, MemorySegment pSleepInfo) {
        var mh$ = vkLatencySleepNV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkLatencySleepNV", device, swapchain, pSleepInfo);
            }
            return (int)mh$.invokeExact(device, swapchain, pSleepInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkSetLatencyMarkerNV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkSetLatencyMarkerNV"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkSetLatencyMarkerNV(VkDevice device, VkSwapchainKHR swapchain, const VkSetLatencyMarkerInfoNV *pLatencyMarkerInfo)
     * }
     */
    public static FunctionDescriptor vkSetLatencyMarkerNV$descriptor() {
        return vkSetLatencyMarkerNV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkSetLatencyMarkerNV(VkDevice device, VkSwapchainKHR swapchain, const VkSetLatencyMarkerInfoNV *pLatencyMarkerInfo)
     * }
     */
    public static MethodHandle vkSetLatencyMarkerNV$handle() {
        return vkSetLatencyMarkerNV.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkSetLatencyMarkerNV(VkDevice device, VkSwapchainKHR swapchain, const VkSetLatencyMarkerInfoNV *pLatencyMarkerInfo)
     * }
     */
    public static void vkSetLatencyMarkerNV(MemorySegment device, MemorySegment swapchain, MemorySegment pLatencyMarkerInfo) {
        var mh$ = vkSetLatencyMarkerNV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkSetLatencyMarkerNV", device, swapchain, pLatencyMarkerInfo);
            }
            mh$.invokeExact(device, swapchain, pLatencyMarkerInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetLatencyTimingsNV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkGetLatencyTimingsNV"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkGetLatencyTimingsNV(VkDevice device, VkSwapchainKHR swapchain, VkGetLatencyMarkerInfoNV *pLatencyMarkerInfo)
     * }
     */
    public static FunctionDescriptor vkGetLatencyTimingsNV$descriptor() {
        return vkGetLatencyTimingsNV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkGetLatencyTimingsNV(VkDevice device, VkSwapchainKHR swapchain, VkGetLatencyMarkerInfoNV *pLatencyMarkerInfo)
     * }
     */
    public static MethodHandle vkGetLatencyTimingsNV$handle() {
        return vkGetLatencyTimingsNV.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkGetLatencyTimingsNV(VkDevice device, VkSwapchainKHR swapchain, VkGetLatencyMarkerInfoNV *pLatencyMarkerInfo)
     * }
     */
    public static void vkGetLatencyTimingsNV(MemorySegment device, MemorySegment swapchain, MemorySegment pLatencyMarkerInfo) {
        var mh$ = vkGetLatencyTimingsNV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetLatencyTimingsNV", device, swapchain, pLatencyMarkerInfo);
            }
            mh$.invokeExact(device, swapchain, pLatencyMarkerInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkQueueNotifyOutOfBandNV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkQueueNotifyOutOfBandNV"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkQueueNotifyOutOfBandNV(VkQueue queue, const VkOutOfBandQueueTypeInfoNV *pQueueTypeInfo)
     * }
     */
    public static FunctionDescriptor vkQueueNotifyOutOfBandNV$descriptor() {
        return vkQueueNotifyOutOfBandNV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkQueueNotifyOutOfBandNV(VkQueue queue, const VkOutOfBandQueueTypeInfoNV *pQueueTypeInfo)
     * }
     */
    public static MethodHandle vkQueueNotifyOutOfBandNV$handle() {
        return vkQueueNotifyOutOfBandNV.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkQueueNotifyOutOfBandNV(VkQueue queue, const VkOutOfBandQueueTypeInfoNV *pQueueTypeInfo)
     * }
     */
    public static void vkQueueNotifyOutOfBandNV(MemorySegment queue, MemorySegment pQueueTypeInfo) {
        var mh$ = vkQueueNotifyOutOfBandNV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkQueueNotifyOutOfBandNV", queue, pQueueTypeInfo);
            }
            mh$.invokeExact(queue, pQueueTypeInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int VK_BLOCK_MATCH_WINDOW_COMPARE_MODE_MIN_QCOM = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkBlockMatchWindowCompareModeQCOM.VK_BLOCK_MATCH_WINDOW_COMPARE_MODE_MIN_QCOM = 0
     * }
     */
    public static int VK_BLOCK_MATCH_WINDOW_COMPARE_MODE_MIN_QCOM() {
        return VK_BLOCK_MATCH_WINDOW_COMPARE_MODE_MIN_QCOM;
    }
    private static final int VK_BLOCK_MATCH_WINDOW_COMPARE_MODE_MAX_QCOM = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkBlockMatchWindowCompareModeQCOM.VK_BLOCK_MATCH_WINDOW_COMPARE_MODE_MAX_QCOM = 1
     * }
     */
    public static int VK_BLOCK_MATCH_WINDOW_COMPARE_MODE_MAX_QCOM() {
        return VK_BLOCK_MATCH_WINDOW_COMPARE_MODE_MAX_QCOM;
    }
    private static final int VK_BLOCK_MATCH_WINDOW_COMPARE_MODE_MAX_ENUM_QCOM = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkBlockMatchWindowCompareModeQCOM.VK_BLOCK_MATCH_WINDOW_COMPARE_MODE_MAX_ENUM_QCOM = 2147483647
     * }
     */
    public static int VK_BLOCK_MATCH_WINDOW_COMPARE_MODE_MAX_ENUM_QCOM() {
        return VK_BLOCK_MATCH_WINDOW_COMPARE_MODE_MAX_ENUM_QCOM;
    }
    private static final int VK_CUBIC_FILTER_WEIGHTS_CATMULL_ROM_QCOM = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkCubicFilterWeightsQCOM.VK_CUBIC_FILTER_WEIGHTS_CATMULL_ROM_QCOM = 0
     * }
     */
    public static int VK_CUBIC_FILTER_WEIGHTS_CATMULL_ROM_QCOM() {
        return VK_CUBIC_FILTER_WEIGHTS_CATMULL_ROM_QCOM;
    }
    private static final int VK_CUBIC_FILTER_WEIGHTS_ZERO_TANGENT_CARDINAL_QCOM = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkCubicFilterWeightsQCOM.VK_CUBIC_FILTER_WEIGHTS_ZERO_TANGENT_CARDINAL_QCOM = 1
     * }
     */
    public static int VK_CUBIC_FILTER_WEIGHTS_ZERO_TANGENT_CARDINAL_QCOM() {
        return VK_CUBIC_FILTER_WEIGHTS_ZERO_TANGENT_CARDINAL_QCOM;
    }
    private static final int VK_CUBIC_FILTER_WEIGHTS_B_SPLINE_QCOM = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkCubicFilterWeightsQCOM.VK_CUBIC_FILTER_WEIGHTS_B_SPLINE_QCOM = 2
     * }
     */
    public static int VK_CUBIC_FILTER_WEIGHTS_B_SPLINE_QCOM() {
        return VK_CUBIC_FILTER_WEIGHTS_B_SPLINE_QCOM;
    }
    private static final int VK_CUBIC_FILTER_WEIGHTS_MITCHELL_NETRAVALI_QCOM = (int)3L;
    /**
     * {@snippet lang=c :
     * enum VkCubicFilterWeightsQCOM.VK_CUBIC_FILTER_WEIGHTS_MITCHELL_NETRAVALI_QCOM = 3
     * }
     */
    public static int VK_CUBIC_FILTER_WEIGHTS_MITCHELL_NETRAVALI_QCOM() {
        return VK_CUBIC_FILTER_WEIGHTS_MITCHELL_NETRAVALI_QCOM;
    }
    private static final int VK_CUBIC_FILTER_WEIGHTS_MAX_ENUM_QCOM = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkCubicFilterWeightsQCOM.VK_CUBIC_FILTER_WEIGHTS_MAX_ENUM_QCOM = 2147483647
     * }
     */
    public static int VK_CUBIC_FILTER_WEIGHTS_MAX_ENUM_QCOM() {
        return VK_CUBIC_FILTER_WEIGHTS_MAX_ENUM_QCOM;
    }

    private static class vkCmdSetAttachmentFeedbackLoopEnableEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdSetAttachmentFeedbackLoopEnableEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdSetAttachmentFeedbackLoopEnableEXT(VkCommandBuffer commandBuffer, VkImageAspectFlags aspectMask)
     * }
     */
    public static FunctionDescriptor vkCmdSetAttachmentFeedbackLoopEnableEXT$descriptor() {
        return vkCmdSetAttachmentFeedbackLoopEnableEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdSetAttachmentFeedbackLoopEnableEXT(VkCommandBuffer commandBuffer, VkImageAspectFlags aspectMask)
     * }
     */
    public static MethodHandle vkCmdSetAttachmentFeedbackLoopEnableEXT$handle() {
        return vkCmdSetAttachmentFeedbackLoopEnableEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdSetAttachmentFeedbackLoopEnableEXT(VkCommandBuffer commandBuffer, VkImageAspectFlags aspectMask)
     * }
     */
    public static void vkCmdSetAttachmentFeedbackLoopEnableEXT(MemorySegment commandBuffer, int aspectMask) {
        var mh$ = vkCmdSetAttachmentFeedbackLoopEnableEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetAttachmentFeedbackLoopEnableEXT", commandBuffer, aspectMask);
            }
            mh$.invokeExact(commandBuffer, aspectMask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int VK_LAYERED_DRIVER_UNDERLYING_API_NONE_MSFT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkLayeredDriverUnderlyingApiMSFT.VK_LAYERED_DRIVER_UNDERLYING_API_NONE_MSFT = 0
     * }
     */
    public static int VK_LAYERED_DRIVER_UNDERLYING_API_NONE_MSFT() {
        return VK_LAYERED_DRIVER_UNDERLYING_API_NONE_MSFT;
    }
    private static final int VK_LAYERED_DRIVER_UNDERLYING_API_D3D12_MSFT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkLayeredDriverUnderlyingApiMSFT.VK_LAYERED_DRIVER_UNDERLYING_API_D3D12_MSFT = 1
     * }
     */
    public static int VK_LAYERED_DRIVER_UNDERLYING_API_D3D12_MSFT() {
        return VK_LAYERED_DRIVER_UNDERLYING_API_D3D12_MSFT;
    }
    private static final int VK_LAYERED_DRIVER_UNDERLYING_API_MAX_ENUM_MSFT = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkLayeredDriverUnderlyingApiMSFT.VK_LAYERED_DRIVER_UNDERLYING_API_MAX_ENUM_MSFT = 2147483647
     * }
     */
    public static int VK_LAYERED_DRIVER_UNDERLYING_API_MAX_ENUM_MSFT() {
        return VK_LAYERED_DRIVER_UNDERLYING_API_MAX_ENUM_MSFT;
    }
    private static final int VK_BUILD_ACCELERATION_STRUCTURE_MODE_BUILD_KHR = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkBuildAccelerationStructureModeKHR.VK_BUILD_ACCELERATION_STRUCTURE_MODE_BUILD_KHR = 0
     * }
     */
    public static int VK_BUILD_ACCELERATION_STRUCTURE_MODE_BUILD_KHR() {
        return VK_BUILD_ACCELERATION_STRUCTURE_MODE_BUILD_KHR;
    }
    private static final int VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkBuildAccelerationStructureModeKHR.VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR = 1
     * }
     */
    public static int VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR() {
        return VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR;
    }
    private static final int VK_BUILD_ACCELERATION_STRUCTURE_MODE_MAX_ENUM_KHR = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkBuildAccelerationStructureModeKHR.VK_BUILD_ACCELERATION_STRUCTURE_MODE_MAX_ENUM_KHR = 2147483647
     * }
     */
    public static int VK_BUILD_ACCELERATION_STRUCTURE_MODE_MAX_ENUM_KHR() {
        return VK_BUILD_ACCELERATION_STRUCTURE_MODE_MAX_ENUM_KHR;
    }
    private static final int VK_ACCELERATION_STRUCTURE_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkAccelerationStructureCreateFlagBitsKHR.VK_ACCELERATION_STRUCTURE_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR = 1
     * }
     */
    public static int VK_ACCELERATION_STRUCTURE_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR() {
        return VK_ACCELERATION_STRUCTURE_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR;
    }
    private static final int VK_ACCELERATION_STRUCTURE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT = (int)8L;
    /**
     * {@snippet lang=c :
     * enum VkAccelerationStructureCreateFlagBitsKHR.VK_ACCELERATION_STRUCTURE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT = 8
     * }
     */
    public static int VK_ACCELERATION_STRUCTURE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT() {
        return VK_ACCELERATION_STRUCTURE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT;
    }
    private static final int VK_ACCELERATION_STRUCTURE_CREATE_MOTION_BIT_NV = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkAccelerationStructureCreateFlagBitsKHR.VK_ACCELERATION_STRUCTURE_CREATE_MOTION_BIT_NV = 4
     * }
     */
    public static int VK_ACCELERATION_STRUCTURE_CREATE_MOTION_BIT_NV() {
        return VK_ACCELERATION_STRUCTURE_CREATE_MOTION_BIT_NV;
    }
    private static final int VK_ACCELERATION_STRUCTURE_CREATE_FLAG_BITS_MAX_ENUM_KHR = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkAccelerationStructureCreateFlagBitsKHR.VK_ACCELERATION_STRUCTURE_CREATE_FLAG_BITS_MAX_ENUM_KHR = 2147483647
     * }
     */
    public static int VK_ACCELERATION_STRUCTURE_CREATE_FLAG_BITS_MAX_ENUM_KHR() {
        return VK_ACCELERATION_STRUCTURE_CREATE_FLAG_BITS_MAX_ENUM_KHR;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkAccelerationStructureCreateFlagsKHR
     * }
     */
    public static final OfInt VkAccelerationStructureCreateFlagsKHR = vulkan_h.C_INT;

    private static class vkCreateAccelerationStructureKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCreateAccelerationStructureKHR"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkCreateAccelerationStructureKHR(VkDevice device, const VkAccelerationStructureCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkAccelerationStructureKHR *pAccelerationStructure)
     * }
     */
    public static FunctionDescriptor vkCreateAccelerationStructureKHR$descriptor() {
        return vkCreateAccelerationStructureKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkCreateAccelerationStructureKHR(VkDevice device, const VkAccelerationStructureCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkAccelerationStructureKHR *pAccelerationStructure)
     * }
     */
    public static MethodHandle vkCreateAccelerationStructureKHR$handle() {
        return vkCreateAccelerationStructureKHR.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * VkResult vkCreateAccelerationStructureKHR(VkDevice device, const VkAccelerationStructureCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkAccelerationStructureKHR *pAccelerationStructure)
     * }
     */
    public static int vkCreateAccelerationStructureKHR(MemorySegment device, MemorySegment pCreateInfo, MemorySegment pAllocator, MemorySegment pAccelerationStructure) {
        var mh$ = vkCreateAccelerationStructureKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCreateAccelerationStructureKHR", device, pCreateInfo, pAllocator, pAccelerationStructure);
            }
            return (int)mh$.invokeExact(device, pCreateInfo, pAllocator, pAccelerationStructure);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkDestroyAccelerationStructureKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkDestroyAccelerationStructureKHR"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkDestroyAccelerationStructureKHR(VkDevice device, VkAccelerationStructureKHR accelerationStructure, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static FunctionDescriptor vkDestroyAccelerationStructureKHR$descriptor() {
        return vkDestroyAccelerationStructureKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkDestroyAccelerationStructureKHR(VkDevice device, VkAccelerationStructureKHR accelerationStructure, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static MethodHandle vkDestroyAccelerationStructureKHR$handle() {
        return vkDestroyAccelerationStructureKHR.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkDestroyAccelerationStructureKHR(VkDevice device, VkAccelerationStructureKHR accelerationStructure, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static void vkDestroyAccelerationStructureKHR(MemorySegment device, MemorySegment accelerationStructure, MemorySegment pAllocator) {
        var mh$ = vkDestroyAccelerationStructureKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkDestroyAccelerationStructureKHR", device, accelerationStructure, pAllocator);
            }
            mh$.invokeExact(device, accelerationStructure, pAllocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdBuildAccelerationStructuresKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdBuildAccelerationStructuresKHR"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdBuildAccelerationStructuresKHR(VkCommandBuffer commandBuffer, uint32_t infoCount, const VkAccelerationStructureBuildGeometryInfoKHR *pInfos, const VkAccelerationStructureBuildRangeInfoKHR *const *ppBuildRangeInfos)
     * }
     */
    public static FunctionDescriptor vkCmdBuildAccelerationStructuresKHR$descriptor() {
        return vkCmdBuildAccelerationStructuresKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdBuildAccelerationStructuresKHR(VkCommandBuffer commandBuffer, uint32_t infoCount, const VkAccelerationStructureBuildGeometryInfoKHR *pInfos, const VkAccelerationStructureBuildRangeInfoKHR *const *ppBuildRangeInfos)
     * }
     */
    public static MethodHandle vkCmdBuildAccelerationStructuresKHR$handle() {
        return vkCmdBuildAccelerationStructuresKHR.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdBuildAccelerationStructuresKHR(VkCommandBuffer commandBuffer, uint32_t infoCount, const VkAccelerationStructureBuildGeometryInfoKHR *pInfos, const VkAccelerationStructureBuildRangeInfoKHR *const *ppBuildRangeInfos)
     * }
     */
    public static void vkCmdBuildAccelerationStructuresKHR(MemorySegment commandBuffer, int infoCount, MemorySegment pInfos, MemorySegment ppBuildRangeInfos) {
        var mh$ = vkCmdBuildAccelerationStructuresKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdBuildAccelerationStructuresKHR", commandBuffer, infoCount, pInfos, ppBuildRangeInfos);
            }
            mh$.invokeExact(commandBuffer, infoCount, pInfos, ppBuildRangeInfos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdBuildAccelerationStructuresIndirectKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdBuildAccelerationStructuresIndirectKHR"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdBuildAccelerationStructuresIndirectKHR(VkCommandBuffer commandBuffer, uint32_t infoCount, const VkAccelerationStructureBuildGeometryInfoKHR *pInfos, const VkDeviceAddress *pIndirectDeviceAddresses, const uint32_t *pIndirectStrides, const uint32_t *const *ppMaxPrimitiveCounts)
     * }
     */
    public static FunctionDescriptor vkCmdBuildAccelerationStructuresIndirectKHR$descriptor() {
        return vkCmdBuildAccelerationStructuresIndirectKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdBuildAccelerationStructuresIndirectKHR(VkCommandBuffer commandBuffer, uint32_t infoCount, const VkAccelerationStructureBuildGeometryInfoKHR *pInfos, const VkDeviceAddress *pIndirectDeviceAddresses, const uint32_t *pIndirectStrides, const uint32_t *const *ppMaxPrimitiveCounts)
     * }
     */
    public static MethodHandle vkCmdBuildAccelerationStructuresIndirectKHR$handle() {
        return vkCmdBuildAccelerationStructuresIndirectKHR.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdBuildAccelerationStructuresIndirectKHR(VkCommandBuffer commandBuffer, uint32_t infoCount, const VkAccelerationStructureBuildGeometryInfoKHR *pInfos, const VkDeviceAddress *pIndirectDeviceAddresses, const uint32_t *pIndirectStrides, const uint32_t *const *ppMaxPrimitiveCounts)
     * }
     */
    public static void vkCmdBuildAccelerationStructuresIndirectKHR(MemorySegment commandBuffer, int infoCount, MemorySegment pInfos, MemorySegment pIndirectDeviceAddresses, MemorySegment pIndirectStrides, MemorySegment ppMaxPrimitiveCounts) {
        var mh$ = vkCmdBuildAccelerationStructuresIndirectKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdBuildAccelerationStructuresIndirectKHR", commandBuffer, infoCount, pInfos, pIndirectDeviceAddresses, pIndirectStrides, ppMaxPrimitiveCounts);
            }
            mh$.invokeExact(commandBuffer, infoCount, pInfos, pIndirectDeviceAddresses, pIndirectStrides, ppMaxPrimitiveCounts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkBuildAccelerationStructuresKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkBuildAccelerationStructuresKHR"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkBuildAccelerationStructuresKHR(VkDevice device, VkDeferredOperationKHR deferredOperation, uint32_t infoCount, const VkAccelerationStructureBuildGeometryInfoKHR *pInfos, const VkAccelerationStructureBuildRangeInfoKHR *const *ppBuildRangeInfos)
     * }
     */
    public static FunctionDescriptor vkBuildAccelerationStructuresKHR$descriptor() {
        return vkBuildAccelerationStructuresKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkBuildAccelerationStructuresKHR(VkDevice device, VkDeferredOperationKHR deferredOperation, uint32_t infoCount, const VkAccelerationStructureBuildGeometryInfoKHR *pInfos, const VkAccelerationStructureBuildRangeInfoKHR *const *ppBuildRangeInfos)
     * }
     */
    public static MethodHandle vkBuildAccelerationStructuresKHR$handle() {
        return vkBuildAccelerationStructuresKHR.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * VkResult vkBuildAccelerationStructuresKHR(VkDevice device, VkDeferredOperationKHR deferredOperation, uint32_t infoCount, const VkAccelerationStructureBuildGeometryInfoKHR *pInfos, const VkAccelerationStructureBuildRangeInfoKHR *const *ppBuildRangeInfos)
     * }
     */
    public static int vkBuildAccelerationStructuresKHR(MemorySegment device, MemorySegment deferredOperation, int infoCount, MemorySegment pInfos, MemorySegment ppBuildRangeInfos) {
        var mh$ = vkBuildAccelerationStructuresKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkBuildAccelerationStructuresKHR", device, deferredOperation, infoCount, pInfos, ppBuildRangeInfos);
            }
            return (int)mh$.invokeExact(device, deferredOperation, infoCount, pInfos, ppBuildRangeInfos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCopyAccelerationStructureKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCopyAccelerationStructureKHR"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkCopyAccelerationStructureKHR(VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyAccelerationStructureInfoKHR *pInfo)
     * }
     */
    public static FunctionDescriptor vkCopyAccelerationStructureKHR$descriptor() {
        return vkCopyAccelerationStructureKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkCopyAccelerationStructureKHR(VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyAccelerationStructureInfoKHR *pInfo)
     * }
     */
    public static MethodHandle vkCopyAccelerationStructureKHR$handle() {
        return vkCopyAccelerationStructureKHR.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * VkResult vkCopyAccelerationStructureKHR(VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyAccelerationStructureInfoKHR *pInfo)
     * }
     */
    public static int vkCopyAccelerationStructureKHR(MemorySegment device, MemorySegment deferredOperation, MemorySegment pInfo) {
        var mh$ = vkCopyAccelerationStructureKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCopyAccelerationStructureKHR", device, deferredOperation, pInfo);
            }
            return (int)mh$.invokeExact(device, deferredOperation, pInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCopyAccelerationStructureToMemoryKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCopyAccelerationStructureToMemoryKHR"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkCopyAccelerationStructureToMemoryKHR(VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyAccelerationStructureToMemoryInfoKHR *pInfo)
     * }
     */
    public static FunctionDescriptor vkCopyAccelerationStructureToMemoryKHR$descriptor() {
        return vkCopyAccelerationStructureToMemoryKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkCopyAccelerationStructureToMemoryKHR(VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyAccelerationStructureToMemoryInfoKHR *pInfo)
     * }
     */
    public static MethodHandle vkCopyAccelerationStructureToMemoryKHR$handle() {
        return vkCopyAccelerationStructureToMemoryKHR.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * VkResult vkCopyAccelerationStructureToMemoryKHR(VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyAccelerationStructureToMemoryInfoKHR *pInfo)
     * }
     */
    public static int vkCopyAccelerationStructureToMemoryKHR(MemorySegment device, MemorySegment deferredOperation, MemorySegment pInfo) {
        var mh$ = vkCopyAccelerationStructureToMemoryKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCopyAccelerationStructureToMemoryKHR", device, deferredOperation, pInfo);
            }
            return (int)mh$.invokeExact(device, deferredOperation, pInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCopyMemoryToAccelerationStructureKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCopyMemoryToAccelerationStructureKHR"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkCopyMemoryToAccelerationStructureKHR(VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyMemoryToAccelerationStructureInfoKHR *pInfo)
     * }
     */
    public static FunctionDescriptor vkCopyMemoryToAccelerationStructureKHR$descriptor() {
        return vkCopyMemoryToAccelerationStructureKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkCopyMemoryToAccelerationStructureKHR(VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyMemoryToAccelerationStructureInfoKHR *pInfo)
     * }
     */
    public static MethodHandle vkCopyMemoryToAccelerationStructureKHR$handle() {
        return vkCopyMemoryToAccelerationStructureKHR.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * VkResult vkCopyMemoryToAccelerationStructureKHR(VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyMemoryToAccelerationStructureInfoKHR *pInfo)
     * }
     */
    public static int vkCopyMemoryToAccelerationStructureKHR(MemorySegment device, MemorySegment deferredOperation, MemorySegment pInfo) {
        var mh$ = vkCopyMemoryToAccelerationStructureKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCopyMemoryToAccelerationStructureKHR", device, deferredOperation, pInfo);
            }
            return (int)mh$.invokeExact(device, deferredOperation, pInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkWriteAccelerationStructuresPropertiesKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_LONG,
            vulkan_h.C_POINTER,
            vulkan_h.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkWriteAccelerationStructuresPropertiesKHR"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkWriteAccelerationStructuresPropertiesKHR(VkDevice device, uint32_t accelerationStructureCount, const VkAccelerationStructureKHR *pAccelerationStructures, VkQueryType queryType, size_t dataSize, void *pData, size_t stride)
     * }
     */
    public static FunctionDescriptor vkWriteAccelerationStructuresPropertiesKHR$descriptor() {
        return vkWriteAccelerationStructuresPropertiesKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkWriteAccelerationStructuresPropertiesKHR(VkDevice device, uint32_t accelerationStructureCount, const VkAccelerationStructureKHR *pAccelerationStructures, VkQueryType queryType, size_t dataSize, void *pData, size_t stride)
     * }
     */
    public static MethodHandle vkWriteAccelerationStructuresPropertiesKHR$handle() {
        return vkWriteAccelerationStructuresPropertiesKHR.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * VkResult vkWriteAccelerationStructuresPropertiesKHR(VkDevice device, uint32_t accelerationStructureCount, const VkAccelerationStructureKHR *pAccelerationStructures, VkQueryType queryType, size_t dataSize, void *pData, size_t stride)
     * }
     */
    public static int vkWriteAccelerationStructuresPropertiesKHR(MemorySegment device, int accelerationStructureCount, MemorySegment pAccelerationStructures, int queryType, long dataSize, MemorySegment pData, long stride) {
        var mh$ = vkWriteAccelerationStructuresPropertiesKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkWriteAccelerationStructuresPropertiesKHR", device, accelerationStructureCount, pAccelerationStructures, queryType, dataSize, pData, stride);
            }
            return (int)mh$.invokeExact(device, accelerationStructureCount, pAccelerationStructures, queryType, dataSize, pData, stride);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdCopyAccelerationStructureKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdCopyAccelerationStructureKHR"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdCopyAccelerationStructureKHR(VkCommandBuffer commandBuffer, const VkCopyAccelerationStructureInfoKHR *pInfo)
     * }
     */
    public static FunctionDescriptor vkCmdCopyAccelerationStructureKHR$descriptor() {
        return vkCmdCopyAccelerationStructureKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdCopyAccelerationStructureKHR(VkCommandBuffer commandBuffer, const VkCopyAccelerationStructureInfoKHR *pInfo)
     * }
     */
    public static MethodHandle vkCmdCopyAccelerationStructureKHR$handle() {
        return vkCmdCopyAccelerationStructureKHR.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdCopyAccelerationStructureKHR(VkCommandBuffer commandBuffer, const VkCopyAccelerationStructureInfoKHR *pInfo)
     * }
     */
    public static void vkCmdCopyAccelerationStructureKHR(MemorySegment commandBuffer, MemorySegment pInfo) {
        var mh$ = vkCmdCopyAccelerationStructureKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdCopyAccelerationStructureKHR", commandBuffer, pInfo);
            }
            mh$.invokeExact(commandBuffer, pInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdCopyAccelerationStructureToMemoryKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdCopyAccelerationStructureToMemoryKHR"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdCopyAccelerationStructureToMemoryKHR(VkCommandBuffer commandBuffer, const VkCopyAccelerationStructureToMemoryInfoKHR *pInfo)
     * }
     */
    public static FunctionDescriptor vkCmdCopyAccelerationStructureToMemoryKHR$descriptor() {
        return vkCmdCopyAccelerationStructureToMemoryKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdCopyAccelerationStructureToMemoryKHR(VkCommandBuffer commandBuffer, const VkCopyAccelerationStructureToMemoryInfoKHR *pInfo)
     * }
     */
    public static MethodHandle vkCmdCopyAccelerationStructureToMemoryKHR$handle() {
        return vkCmdCopyAccelerationStructureToMemoryKHR.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdCopyAccelerationStructureToMemoryKHR(VkCommandBuffer commandBuffer, const VkCopyAccelerationStructureToMemoryInfoKHR *pInfo)
     * }
     */
    public static void vkCmdCopyAccelerationStructureToMemoryKHR(MemorySegment commandBuffer, MemorySegment pInfo) {
        var mh$ = vkCmdCopyAccelerationStructureToMemoryKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdCopyAccelerationStructureToMemoryKHR", commandBuffer, pInfo);
            }
            mh$.invokeExact(commandBuffer, pInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdCopyMemoryToAccelerationStructureKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdCopyMemoryToAccelerationStructureKHR"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdCopyMemoryToAccelerationStructureKHR(VkCommandBuffer commandBuffer, const VkCopyMemoryToAccelerationStructureInfoKHR *pInfo)
     * }
     */
    public static FunctionDescriptor vkCmdCopyMemoryToAccelerationStructureKHR$descriptor() {
        return vkCmdCopyMemoryToAccelerationStructureKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdCopyMemoryToAccelerationStructureKHR(VkCommandBuffer commandBuffer, const VkCopyMemoryToAccelerationStructureInfoKHR *pInfo)
     * }
     */
    public static MethodHandle vkCmdCopyMemoryToAccelerationStructureKHR$handle() {
        return vkCmdCopyMemoryToAccelerationStructureKHR.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdCopyMemoryToAccelerationStructureKHR(VkCommandBuffer commandBuffer, const VkCopyMemoryToAccelerationStructureInfoKHR *pInfo)
     * }
     */
    public static void vkCmdCopyMemoryToAccelerationStructureKHR(MemorySegment commandBuffer, MemorySegment pInfo) {
        var mh$ = vkCmdCopyMemoryToAccelerationStructureKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdCopyMemoryToAccelerationStructureKHR", commandBuffer, pInfo);
            }
            mh$.invokeExact(commandBuffer, pInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetAccelerationStructureDeviceAddressKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_LONG_LONG,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkGetAccelerationStructureDeviceAddressKHR"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkDeviceAddress vkGetAccelerationStructureDeviceAddressKHR(VkDevice device, const VkAccelerationStructureDeviceAddressInfoKHR *pInfo)
     * }
     */
    public static FunctionDescriptor vkGetAccelerationStructureDeviceAddressKHR$descriptor() {
        return vkGetAccelerationStructureDeviceAddressKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkDeviceAddress vkGetAccelerationStructureDeviceAddressKHR(VkDevice device, const VkAccelerationStructureDeviceAddressInfoKHR *pInfo)
     * }
     */
    public static MethodHandle vkGetAccelerationStructureDeviceAddressKHR$handle() {
        return vkGetAccelerationStructureDeviceAddressKHR.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * VkDeviceAddress vkGetAccelerationStructureDeviceAddressKHR(VkDevice device, const VkAccelerationStructureDeviceAddressInfoKHR *pInfo)
     * }
     */
    public static long vkGetAccelerationStructureDeviceAddressKHR(MemorySegment device, MemorySegment pInfo) {
        var mh$ = vkGetAccelerationStructureDeviceAddressKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetAccelerationStructureDeviceAddressKHR", device, pInfo);
            }
            return (long)mh$.invokeExact(device, pInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdWriteAccelerationStructuresPropertiesKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdWriteAccelerationStructuresPropertiesKHR"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdWriteAccelerationStructuresPropertiesKHR(VkCommandBuffer commandBuffer, uint32_t accelerationStructureCount, const VkAccelerationStructureKHR *pAccelerationStructures, VkQueryType queryType, VkQueryPool queryPool, uint32_t firstQuery)
     * }
     */
    public static FunctionDescriptor vkCmdWriteAccelerationStructuresPropertiesKHR$descriptor() {
        return vkCmdWriteAccelerationStructuresPropertiesKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdWriteAccelerationStructuresPropertiesKHR(VkCommandBuffer commandBuffer, uint32_t accelerationStructureCount, const VkAccelerationStructureKHR *pAccelerationStructures, VkQueryType queryType, VkQueryPool queryPool, uint32_t firstQuery)
     * }
     */
    public static MethodHandle vkCmdWriteAccelerationStructuresPropertiesKHR$handle() {
        return vkCmdWriteAccelerationStructuresPropertiesKHR.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdWriteAccelerationStructuresPropertiesKHR(VkCommandBuffer commandBuffer, uint32_t accelerationStructureCount, const VkAccelerationStructureKHR *pAccelerationStructures, VkQueryType queryType, VkQueryPool queryPool, uint32_t firstQuery)
     * }
     */
    public static void vkCmdWriteAccelerationStructuresPropertiesKHR(MemorySegment commandBuffer, int accelerationStructureCount, MemorySegment pAccelerationStructures, int queryType, MemorySegment queryPool, int firstQuery) {
        var mh$ = vkCmdWriteAccelerationStructuresPropertiesKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdWriteAccelerationStructuresPropertiesKHR", commandBuffer, accelerationStructureCount, pAccelerationStructures, queryType, queryPool, firstQuery);
            }
            mh$.invokeExact(commandBuffer, accelerationStructureCount, pAccelerationStructures, queryType, queryPool, firstQuery);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetDeviceAccelerationStructureCompatibilityKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkGetDeviceAccelerationStructureCompatibilityKHR"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkGetDeviceAccelerationStructureCompatibilityKHR(VkDevice device, const VkAccelerationStructureVersionInfoKHR *pVersionInfo, VkAccelerationStructureCompatibilityKHR *pCompatibility)
     * }
     */
    public static FunctionDescriptor vkGetDeviceAccelerationStructureCompatibilityKHR$descriptor() {
        return vkGetDeviceAccelerationStructureCompatibilityKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkGetDeviceAccelerationStructureCompatibilityKHR(VkDevice device, const VkAccelerationStructureVersionInfoKHR *pVersionInfo, VkAccelerationStructureCompatibilityKHR *pCompatibility)
     * }
     */
    public static MethodHandle vkGetDeviceAccelerationStructureCompatibilityKHR$handle() {
        return vkGetDeviceAccelerationStructureCompatibilityKHR.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkGetDeviceAccelerationStructureCompatibilityKHR(VkDevice device, const VkAccelerationStructureVersionInfoKHR *pVersionInfo, VkAccelerationStructureCompatibilityKHR *pCompatibility)
     * }
     */
    public static void vkGetDeviceAccelerationStructureCompatibilityKHR(MemorySegment device, MemorySegment pVersionInfo, MemorySegment pCompatibility) {
        var mh$ = vkGetDeviceAccelerationStructureCompatibilityKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetDeviceAccelerationStructureCompatibilityKHR", device, pVersionInfo, pCompatibility);
            }
            mh$.invokeExact(device, pVersionInfo, pCompatibility);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetAccelerationStructureBuildSizesKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkGetAccelerationStructureBuildSizesKHR"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkGetAccelerationStructureBuildSizesKHR(VkDevice device, VkAccelerationStructureBuildTypeKHR buildType, const VkAccelerationStructureBuildGeometryInfoKHR *pBuildInfo, const uint32_t *pMaxPrimitiveCounts, VkAccelerationStructureBuildSizesInfoKHR *pSizeInfo)
     * }
     */
    public static FunctionDescriptor vkGetAccelerationStructureBuildSizesKHR$descriptor() {
        return vkGetAccelerationStructureBuildSizesKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkGetAccelerationStructureBuildSizesKHR(VkDevice device, VkAccelerationStructureBuildTypeKHR buildType, const VkAccelerationStructureBuildGeometryInfoKHR *pBuildInfo, const uint32_t *pMaxPrimitiveCounts, VkAccelerationStructureBuildSizesInfoKHR *pSizeInfo)
     * }
     */
    public static MethodHandle vkGetAccelerationStructureBuildSizesKHR$handle() {
        return vkGetAccelerationStructureBuildSizesKHR.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkGetAccelerationStructureBuildSizesKHR(VkDevice device, VkAccelerationStructureBuildTypeKHR buildType, const VkAccelerationStructureBuildGeometryInfoKHR *pBuildInfo, const uint32_t *pMaxPrimitiveCounts, VkAccelerationStructureBuildSizesInfoKHR *pSizeInfo)
     * }
     */
    public static void vkGetAccelerationStructureBuildSizesKHR(MemorySegment device, int buildType, MemorySegment pBuildInfo, MemorySegment pMaxPrimitiveCounts, MemorySegment pSizeInfo) {
        var mh$ = vkGetAccelerationStructureBuildSizesKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetAccelerationStructureBuildSizesKHR", device, buildType, pBuildInfo, pMaxPrimitiveCounts, pSizeInfo);
            }
            mh$.invokeExact(device, buildType, pBuildInfo, pMaxPrimitiveCounts, pSizeInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int VK_SHADER_GROUP_SHADER_GENERAL_KHR = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkShaderGroupShaderKHR.VK_SHADER_GROUP_SHADER_GENERAL_KHR = 0
     * }
     */
    public static int VK_SHADER_GROUP_SHADER_GENERAL_KHR() {
        return VK_SHADER_GROUP_SHADER_GENERAL_KHR;
    }
    private static final int VK_SHADER_GROUP_SHADER_CLOSEST_HIT_KHR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkShaderGroupShaderKHR.VK_SHADER_GROUP_SHADER_CLOSEST_HIT_KHR = 1
     * }
     */
    public static int VK_SHADER_GROUP_SHADER_CLOSEST_HIT_KHR() {
        return VK_SHADER_GROUP_SHADER_CLOSEST_HIT_KHR;
    }
    private static final int VK_SHADER_GROUP_SHADER_ANY_HIT_KHR = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkShaderGroupShaderKHR.VK_SHADER_GROUP_SHADER_ANY_HIT_KHR = 2
     * }
     */
    public static int VK_SHADER_GROUP_SHADER_ANY_HIT_KHR() {
        return VK_SHADER_GROUP_SHADER_ANY_HIT_KHR;
    }
    private static final int VK_SHADER_GROUP_SHADER_INTERSECTION_KHR = (int)3L;
    /**
     * {@snippet lang=c :
     * enum VkShaderGroupShaderKHR.VK_SHADER_GROUP_SHADER_INTERSECTION_KHR = 3
     * }
     */
    public static int VK_SHADER_GROUP_SHADER_INTERSECTION_KHR() {
        return VK_SHADER_GROUP_SHADER_INTERSECTION_KHR;
    }
    private static final int VK_SHADER_GROUP_SHADER_MAX_ENUM_KHR = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkShaderGroupShaderKHR.VK_SHADER_GROUP_SHADER_MAX_ENUM_KHR = 2147483647
     * }
     */
    public static int VK_SHADER_GROUP_SHADER_MAX_ENUM_KHR() {
        return VK_SHADER_GROUP_SHADER_MAX_ENUM_KHR;
    }

    private static class vkCmdTraceRaysKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdTraceRaysKHR"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdTraceRaysKHR(VkCommandBuffer commandBuffer, const VkStridedDeviceAddressRegionKHR *pRaygenShaderBindingTable, const VkStridedDeviceAddressRegionKHR *pMissShaderBindingTable, const VkStridedDeviceAddressRegionKHR *pHitShaderBindingTable, const VkStridedDeviceAddressRegionKHR *pCallableShaderBindingTable, uint32_t width, uint32_t height, uint32_t depth)
     * }
     */
    public static FunctionDescriptor vkCmdTraceRaysKHR$descriptor() {
        return vkCmdTraceRaysKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdTraceRaysKHR(VkCommandBuffer commandBuffer, const VkStridedDeviceAddressRegionKHR *pRaygenShaderBindingTable, const VkStridedDeviceAddressRegionKHR *pMissShaderBindingTable, const VkStridedDeviceAddressRegionKHR *pHitShaderBindingTable, const VkStridedDeviceAddressRegionKHR *pCallableShaderBindingTable, uint32_t width, uint32_t height, uint32_t depth)
     * }
     */
    public static MethodHandle vkCmdTraceRaysKHR$handle() {
        return vkCmdTraceRaysKHR.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdTraceRaysKHR(VkCommandBuffer commandBuffer, const VkStridedDeviceAddressRegionKHR *pRaygenShaderBindingTable, const VkStridedDeviceAddressRegionKHR *pMissShaderBindingTable, const VkStridedDeviceAddressRegionKHR *pHitShaderBindingTable, const VkStridedDeviceAddressRegionKHR *pCallableShaderBindingTable, uint32_t width, uint32_t height, uint32_t depth)
     * }
     */
    public static void vkCmdTraceRaysKHR(MemorySegment commandBuffer, MemorySegment pRaygenShaderBindingTable, MemorySegment pMissShaderBindingTable, MemorySegment pHitShaderBindingTable, MemorySegment pCallableShaderBindingTable, int width, int height, int depth) {
        var mh$ = vkCmdTraceRaysKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdTraceRaysKHR", commandBuffer, pRaygenShaderBindingTable, pMissShaderBindingTable, pHitShaderBindingTable, pCallableShaderBindingTable, width, height, depth);
            }
            mh$.invokeExact(commandBuffer, pRaygenShaderBindingTable, pMissShaderBindingTable, pHitShaderBindingTable, pCallableShaderBindingTable, width, height, depth);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCreateRayTracingPipelinesKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCreateRayTracingPipelinesKHR"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkCreateRayTracingPipelinesKHR(VkDevice device, VkDeferredOperationKHR deferredOperation, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkRayTracingPipelineCreateInfoKHR *pCreateInfos, const VkAllocationCallbacks *pAllocator, VkPipeline *pPipelines)
     * }
     */
    public static FunctionDescriptor vkCreateRayTracingPipelinesKHR$descriptor() {
        return vkCreateRayTracingPipelinesKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkCreateRayTracingPipelinesKHR(VkDevice device, VkDeferredOperationKHR deferredOperation, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkRayTracingPipelineCreateInfoKHR *pCreateInfos, const VkAllocationCallbacks *pAllocator, VkPipeline *pPipelines)
     * }
     */
    public static MethodHandle vkCreateRayTracingPipelinesKHR$handle() {
        return vkCreateRayTracingPipelinesKHR.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * VkResult vkCreateRayTracingPipelinesKHR(VkDevice device, VkDeferredOperationKHR deferredOperation, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkRayTracingPipelineCreateInfoKHR *pCreateInfos, const VkAllocationCallbacks *pAllocator, VkPipeline *pPipelines)
     * }
     */
    public static int vkCreateRayTracingPipelinesKHR(MemorySegment device, MemorySegment deferredOperation, MemorySegment pipelineCache, int createInfoCount, MemorySegment pCreateInfos, MemorySegment pAllocator, MemorySegment pPipelines) {
        var mh$ = vkCreateRayTracingPipelinesKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCreateRayTracingPipelinesKHR", device, deferredOperation, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
            }
            return (int)mh$.invokeExact(device, deferredOperation, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetRayTracingCaptureReplayShaderGroupHandlesKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_LONG,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkGetRayTracingCaptureReplayShaderGroupHandlesKHR"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkGetRayTracingCaptureReplayShaderGroupHandlesKHR(VkDevice device, VkPipeline pipeline, uint32_t firstGroup, uint32_t groupCount, size_t dataSize, void *pData)
     * }
     */
    public static FunctionDescriptor vkGetRayTracingCaptureReplayShaderGroupHandlesKHR$descriptor() {
        return vkGetRayTracingCaptureReplayShaderGroupHandlesKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkGetRayTracingCaptureReplayShaderGroupHandlesKHR(VkDevice device, VkPipeline pipeline, uint32_t firstGroup, uint32_t groupCount, size_t dataSize, void *pData)
     * }
     */
    public static MethodHandle vkGetRayTracingCaptureReplayShaderGroupHandlesKHR$handle() {
        return vkGetRayTracingCaptureReplayShaderGroupHandlesKHR.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * VkResult vkGetRayTracingCaptureReplayShaderGroupHandlesKHR(VkDevice device, VkPipeline pipeline, uint32_t firstGroup, uint32_t groupCount, size_t dataSize, void *pData)
     * }
     */
    public static int vkGetRayTracingCaptureReplayShaderGroupHandlesKHR(MemorySegment device, MemorySegment pipeline, int firstGroup, int groupCount, long dataSize, MemorySegment pData) {
        var mh$ = vkGetRayTracingCaptureReplayShaderGroupHandlesKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetRayTracingCaptureReplayShaderGroupHandlesKHR", device, pipeline, firstGroup, groupCount, dataSize, pData);
            }
            return (int)mh$.invokeExact(device, pipeline, firstGroup, groupCount, dataSize, pData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdTraceRaysIndirectKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdTraceRaysIndirectKHR"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdTraceRaysIndirectKHR(VkCommandBuffer commandBuffer, const VkStridedDeviceAddressRegionKHR *pRaygenShaderBindingTable, const VkStridedDeviceAddressRegionKHR *pMissShaderBindingTable, const VkStridedDeviceAddressRegionKHR *pHitShaderBindingTable, const VkStridedDeviceAddressRegionKHR *pCallableShaderBindingTable, VkDeviceAddress indirectDeviceAddress)
     * }
     */
    public static FunctionDescriptor vkCmdTraceRaysIndirectKHR$descriptor() {
        return vkCmdTraceRaysIndirectKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdTraceRaysIndirectKHR(VkCommandBuffer commandBuffer, const VkStridedDeviceAddressRegionKHR *pRaygenShaderBindingTable, const VkStridedDeviceAddressRegionKHR *pMissShaderBindingTable, const VkStridedDeviceAddressRegionKHR *pHitShaderBindingTable, const VkStridedDeviceAddressRegionKHR *pCallableShaderBindingTable, VkDeviceAddress indirectDeviceAddress)
     * }
     */
    public static MethodHandle vkCmdTraceRaysIndirectKHR$handle() {
        return vkCmdTraceRaysIndirectKHR.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdTraceRaysIndirectKHR(VkCommandBuffer commandBuffer, const VkStridedDeviceAddressRegionKHR *pRaygenShaderBindingTable, const VkStridedDeviceAddressRegionKHR *pMissShaderBindingTable, const VkStridedDeviceAddressRegionKHR *pHitShaderBindingTable, const VkStridedDeviceAddressRegionKHR *pCallableShaderBindingTable, VkDeviceAddress indirectDeviceAddress)
     * }
     */
    public static void vkCmdTraceRaysIndirectKHR(MemorySegment commandBuffer, MemorySegment pRaygenShaderBindingTable, MemorySegment pMissShaderBindingTable, MemorySegment pHitShaderBindingTable, MemorySegment pCallableShaderBindingTable, long indirectDeviceAddress) {
        var mh$ = vkCmdTraceRaysIndirectKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdTraceRaysIndirectKHR", commandBuffer, pRaygenShaderBindingTable, pMissShaderBindingTable, pHitShaderBindingTable, pCallableShaderBindingTable, indirectDeviceAddress);
            }
            mh$.invokeExact(commandBuffer, pRaygenShaderBindingTable, pMissShaderBindingTable, pHitShaderBindingTable, pCallableShaderBindingTable, indirectDeviceAddress);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetRayTracingShaderGroupStackSizeKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_LONG_LONG,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkGetRayTracingShaderGroupStackSizeKHR"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkDeviceSize vkGetRayTracingShaderGroupStackSizeKHR(VkDevice device, VkPipeline pipeline, uint32_t group, VkShaderGroupShaderKHR groupShader)
     * }
     */
    public static FunctionDescriptor vkGetRayTracingShaderGroupStackSizeKHR$descriptor() {
        return vkGetRayTracingShaderGroupStackSizeKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkDeviceSize vkGetRayTracingShaderGroupStackSizeKHR(VkDevice device, VkPipeline pipeline, uint32_t group, VkShaderGroupShaderKHR groupShader)
     * }
     */
    public static MethodHandle vkGetRayTracingShaderGroupStackSizeKHR$handle() {
        return vkGetRayTracingShaderGroupStackSizeKHR.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * VkDeviceSize vkGetRayTracingShaderGroupStackSizeKHR(VkDevice device, VkPipeline pipeline, uint32_t group, VkShaderGroupShaderKHR groupShader)
     * }
     */
    public static long vkGetRayTracingShaderGroupStackSizeKHR(MemorySegment device, MemorySegment pipeline, int group, int groupShader) {
        var mh$ = vkGetRayTracingShaderGroupStackSizeKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetRayTracingShaderGroupStackSizeKHR", device, pipeline, group, groupShader);
            }
            return (long)mh$.invokeExact(device, pipeline, group, groupShader);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdSetRayTracingPipelineStackSizeKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdSetRayTracingPipelineStackSizeKHR"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdSetRayTracingPipelineStackSizeKHR(VkCommandBuffer commandBuffer, uint32_t pipelineStackSize)
     * }
     */
    public static FunctionDescriptor vkCmdSetRayTracingPipelineStackSizeKHR$descriptor() {
        return vkCmdSetRayTracingPipelineStackSizeKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdSetRayTracingPipelineStackSizeKHR(VkCommandBuffer commandBuffer, uint32_t pipelineStackSize)
     * }
     */
    public static MethodHandle vkCmdSetRayTracingPipelineStackSizeKHR$handle() {
        return vkCmdSetRayTracingPipelineStackSizeKHR.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdSetRayTracingPipelineStackSizeKHR(VkCommandBuffer commandBuffer, uint32_t pipelineStackSize)
     * }
     */
    public static void vkCmdSetRayTracingPipelineStackSizeKHR(MemorySegment commandBuffer, int pipelineStackSize) {
        var mh$ = vkCmdSetRayTracingPipelineStackSizeKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetRayTracingPipelineStackSizeKHR", commandBuffer, pipelineStackSize);
            }
            mh$.invokeExact(commandBuffer, pipelineStackSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdDrawMeshTasksEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdDrawMeshTasksEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdDrawMeshTasksEXT(VkCommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ)
     * }
     */
    public static FunctionDescriptor vkCmdDrawMeshTasksEXT$descriptor() {
        return vkCmdDrawMeshTasksEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdDrawMeshTasksEXT(VkCommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ)
     * }
     */
    public static MethodHandle vkCmdDrawMeshTasksEXT$handle() {
        return vkCmdDrawMeshTasksEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdDrawMeshTasksEXT(VkCommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ)
     * }
     */
    public static void vkCmdDrawMeshTasksEXT(MemorySegment commandBuffer, int groupCountX, int groupCountY, int groupCountZ) {
        var mh$ = vkCmdDrawMeshTasksEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdDrawMeshTasksEXT", commandBuffer, groupCountX, groupCountY, groupCountZ);
            }
            mh$.invokeExact(commandBuffer, groupCountX, groupCountY, groupCountZ);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdDrawMeshTasksIndirectEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_LONG_LONG,
            vulkan_h.C_INT,
            vulkan_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdDrawMeshTasksIndirectEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdDrawMeshTasksIndirectEXT(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride)
     * }
     */
    public static FunctionDescriptor vkCmdDrawMeshTasksIndirectEXT$descriptor() {
        return vkCmdDrawMeshTasksIndirectEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdDrawMeshTasksIndirectEXT(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride)
     * }
     */
    public static MethodHandle vkCmdDrawMeshTasksIndirectEXT$handle() {
        return vkCmdDrawMeshTasksIndirectEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdDrawMeshTasksIndirectEXT(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride)
     * }
     */
    public static void vkCmdDrawMeshTasksIndirectEXT(MemorySegment commandBuffer, MemorySegment buffer, long offset, int drawCount, int stride) {
        var mh$ = vkCmdDrawMeshTasksIndirectEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdDrawMeshTasksIndirectEXT", commandBuffer, buffer, offset, drawCount, stride);
            }
            mh$.invokeExact(commandBuffer, buffer, offset, drawCount, stride);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdDrawMeshTasksIndirectCountEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_LONG_LONG,
            vulkan_h.C_POINTER,
            vulkan_h.C_LONG_LONG,
            vulkan_h.C_INT,
            vulkan_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCmdDrawMeshTasksIndirectCountEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdDrawMeshTasksIndirectCountEXT(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride)
     * }
     */
    public static FunctionDescriptor vkCmdDrawMeshTasksIndirectCountEXT$descriptor() {
        return vkCmdDrawMeshTasksIndirectCountEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdDrawMeshTasksIndirectCountEXT(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride)
     * }
     */
    public static MethodHandle vkCmdDrawMeshTasksIndirectCountEXT$handle() {
        return vkCmdDrawMeshTasksIndirectCountEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkCmdDrawMeshTasksIndirectCountEXT(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride)
     * }
     */
    public static void vkCmdDrawMeshTasksIndirectCountEXT(MemorySegment commandBuffer, MemorySegment buffer, long offset, MemorySegment countBuffer, long countBufferOffset, int maxDrawCount, int stride) {
        var mh$ = vkCmdDrawMeshTasksIndirectCountEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdDrawMeshTasksIndirectCountEXT", commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
            }
            mh$.invokeExact(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkMacOSSurfaceCreateFlagsMVK
     * }
     */
    public static final OfInt VkMacOSSurfaceCreateFlagsMVK = vulkan_h.C_INT;

    private static class vkCreateMacOSSurfaceMVK {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCreateMacOSSurfaceMVK"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkCreateMacOSSurfaceMVK(VkInstance instance, const VkMacOSSurfaceCreateInfoMVK *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface)
     * }
     */
    public static FunctionDescriptor vkCreateMacOSSurfaceMVK$descriptor() {
        return vkCreateMacOSSurfaceMVK.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkCreateMacOSSurfaceMVK(VkInstance instance, const VkMacOSSurfaceCreateInfoMVK *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface)
     * }
     */
    public static MethodHandle vkCreateMacOSSurfaceMVK$handle() {
        return vkCreateMacOSSurfaceMVK.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * VkResult vkCreateMacOSSurfaceMVK(VkInstance instance, const VkMacOSSurfaceCreateInfoMVK *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface)
     * }
     */
    public static int vkCreateMacOSSurfaceMVK(MemorySegment instance, MemorySegment pCreateInfo, MemorySegment pAllocator, MemorySegment pSurface) {
        var mh$ = vkCreateMacOSSurfaceMVK.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCreateMacOSSurfaceMVK", instance, pCreateInfo, pAllocator, pSurface);
            }
            return (int)mh$.invokeExact(instance, pCreateInfo, pAllocator, pSurface);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkMetalSurfaceCreateFlagsEXT
     * }
     */
    public static final OfInt VkMetalSurfaceCreateFlagsEXT = vulkan_h.C_INT;

    private static class vkCreateMetalSurfaceEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkCreateMetalSurfaceEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkCreateMetalSurfaceEXT(VkInstance instance, const VkMetalSurfaceCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface)
     * }
     */
    public static FunctionDescriptor vkCreateMetalSurfaceEXT$descriptor() {
        return vkCreateMetalSurfaceEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkCreateMetalSurfaceEXT(VkInstance instance, const VkMetalSurfaceCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface)
     * }
     */
    public static MethodHandle vkCreateMetalSurfaceEXT$handle() {
        return vkCreateMetalSurfaceEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * VkResult vkCreateMetalSurfaceEXT(VkInstance instance, const VkMetalSurfaceCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface)
     * }
     */
    public static int vkCreateMetalSurfaceEXT(MemorySegment instance, MemorySegment pCreateInfo, MemorySegment pAllocator, MemorySegment pSurface) {
        var mh$ = vkCreateMetalSurfaceEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCreateMetalSurfaceEXT", instance, pCreateInfo, pAllocator, pSurface);
            }
            return (int)mh$.invokeExact(instance, pCreateInfo, pAllocator, pSurface);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef void *MTLDevice_id
     * }
     */
    public static final AddressLayout MTLDevice_id = vulkan_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef void *MTLCommandQueue_id
     * }
     */
    public static final AddressLayout MTLCommandQueue_id = vulkan_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef void *MTLBuffer_id
     * }
     */
    public static final AddressLayout MTLBuffer_id = vulkan_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef void *MTLTexture_id
     * }
     */
    public static final AddressLayout MTLTexture_id = vulkan_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct __IOSurface *IOSurfaceRef
     * }
     */
    public static final AddressLayout IOSurfaceRef = vulkan_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef void *MTLSharedEvent_id
     * }
     */
    public static final AddressLayout MTLSharedEvent_id = vulkan_h.C_POINTER;
    private static final int VK_EXPORT_METAL_OBJECT_TYPE_METAL_DEVICE_BIT_EXT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkExportMetalObjectTypeFlagBitsEXT.VK_EXPORT_METAL_OBJECT_TYPE_METAL_DEVICE_BIT_EXT = 1
     * }
     */
    public static int VK_EXPORT_METAL_OBJECT_TYPE_METAL_DEVICE_BIT_EXT() {
        return VK_EXPORT_METAL_OBJECT_TYPE_METAL_DEVICE_BIT_EXT;
    }
    private static final int VK_EXPORT_METAL_OBJECT_TYPE_METAL_COMMAND_QUEUE_BIT_EXT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkExportMetalObjectTypeFlagBitsEXT.VK_EXPORT_METAL_OBJECT_TYPE_METAL_COMMAND_QUEUE_BIT_EXT = 2
     * }
     */
    public static int VK_EXPORT_METAL_OBJECT_TYPE_METAL_COMMAND_QUEUE_BIT_EXT() {
        return VK_EXPORT_METAL_OBJECT_TYPE_METAL_COMMAND_QUEUE_BIT_EXT;
    }
    private static final int VK_EXPORT_METAL_OBJECT_TYPE_METAL_BUFFER_BIT_EXT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkExportMetalObjectTypeFlagBitsEXT.VK_EXPORT_METAL_OBJECT_TYPE_METAL_BUFFER_BIT_EXT = 4
     * }
     */
    public static int VK_EXPORT_METAL_OBJECT_TYPE_METAL_BUFFER_BIT_EXT() {
        return VK_EXPORT_METAL_OBJECT_TYPE_METAL_BUFFER_BIT_EXT;
    }
    private static final int VK_EXPORT_METAL_OBJECT_TYPE_METAL_TEXTURE_BIT_EXT = (int)8L;
    /**
     * {@snippet lang=c :
     * enum VkExportMetalObjectTypeFlagBitsEXT.VK_EXPORT_METAL_OBJECT_TYPE_METAL_TEXTURE_BIT_EXT = 8
     * }
     */
    public static int VK_EXPORT_METAL_OBJECT_TYPE_METAL_TEXTURE_BIT_EXT() {
        return VK_EXPORT_METAL_OBJECT_TYPE_METAL_TEXTURE_BIT_EXT;
    }
    private static final int VK_EXPORT_METAL_OBJECT_TYPE_METAL_IOSURFACE_BIT_EXT = (int)16L;
    /**
     * {@snippet lang=c :
     * enum VkExportMetalObjectTypeFlagBitsEXT.VK_EXPORT_METAL_OBJECT_TYPE_METAL_IOSURFACE_BIT_EXT = 16
     * }
     */
    public static int VK_EXPORT_METAL_OBJECT_TYPE_METAL_IOSURFACE_BIT_EXT() {
        return VK_EXPORT_METAL_OBJECT_TYPE_METAL_IOSURFACE_BIT_EXT;
    }
    private static final int VK_EXPORT_METAL_OBJECT_TYPE_METAL_SHARED_EVENT_BIT_EXT = (int)32L;
    /**
     * {@snippet lang=c :
     * enum VkExportMetalObjectTypeFlagBitsEXT.VK_EXPORT_METAL_OBJECT_TYPE_METAL_SHARED_EVENT_BIT_EXT = 32
     * }
     */
    public static int VK_EXPORT_METAL_OBJECT_TYPE_METAL_SHARED_EVENT_BIT_EXT() {
        return VK_EXPORT_METAL_OBJECT_TYPE_METAL_SHARED_EVENT_BIT_EXT;
    }
    private static final int VK_EXPORT_METAL_OBJECT_TYPE_FLAG_BITS_MAX_ENUM_EXT = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkExportMetalObjectTypeFlagBitsEXT.VK_EXPORT_METAL_OBJECT_TYPE_FLAG_BITS_MAX_ENUM_EXT = 2147483647
     * }
     */
    public static int VK_EXPORT_METAL_OBJECT_TYPE_FLAG_BITS_MAX_ENUM_EXT() {
        return VK_EXPORT_METAL_OBJECT_TYPE_FLAG_BITS_MAX_ENUM_EXT;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkExportMetalObjectTypeFlagsEXT
     * }
     */
    public static final OfInt VkExportMetalObjectTypeFlagsEXT = vulkan_h.C_INT;

    private static class vkExportMetalObjectsEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    vulkan_h.findOrThrow("vkExportMetalObjectsEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkExportMetalObjectsEXT(VkDevice device, VkExportMetalObjectsInfoEXT *pMetalObjectsInfo)
     * }
     */
    public static FunctionDescriptor vkExportMetalObjectsEXT$descriptor() {
        return vkExportMetalObjectsEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkExportMetalObjectsEXT(VkDevice device, VkExportMetalObjectsInfoEXT *pMetalObjectsInfo)
     * }
     */
    public static MethodHandle vkExportMetalObjectsEXT$handle() {
        return vkExportMetalObjectsEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void vkExportMetalObjectsEXT(VkDevice device, VkExportMetalObjectsInfoEXT *pMetalObjectsInfo)
     * }
     */
    public static void vkExportMetalObjectsEXT(MemorySegment device, MemorySegment pMetalObjectsInfo) {
        var mh$ = vkExportMetalObjectsEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkExportMetalObjectsEXT", device, pMetalObjectsInfo);
            }
            mh$.invokeExact(device, pMetalObjectsInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final MemorySegment NULL = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define NULL (void*) 0
     * }
     */
    public static MemorySegment NULL() {
        return NULL;
    }
    /**
     * {@snippet lang=c :
     * #define __DARWIN_SUF_EXTSN "$DARWIN_EXTSN"
     * }
     */
    public static MemorySegment __DARWIN_SUF_EXTSN() {
        class Holder {
            static final MemorySegment __DARWIN_SUF_EXTSN
                = vulkan_h.LIBRARY_ARENA.allocateFrom("$DARWIN_EXTSN");
        }
        return Holder.__DARWIN_SUF_EXTSN;
    }
    private static final long __DARWIN_C_ANSI = 4096L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_C_ANSI 4096
     * }
     */
    public static long __DARWIN_C_ANSI() {
        return __DARWIN_C_ANSI;
    }
    private static final long __DARWIN_C_FULL = 900000L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_C_FULL 900000
     * }
     */
    public static long __DARWIN_C_FULL() {
        return __DARWIN_C_FULL;
    }
    private static final long __DARWIN_C_LEVEL = 900000L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_C_LEVEL 900000
     * }
     */
    public static long __DARWIN_C_LEVEL() {
        return __DARWIN_C_LEVEL;
    }
    private static final MemorySegment __DARWIN_NULL = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define __DARWIN_NULL (void*) 0
     * }
     */
    public static MemorySegment __DARWIN_NULL() {
        return __DARWIN_NULL;
    }
    private static final long USER_ADDR_NULL = 0L;
    /**
     * {@snippet lang=c :
     * #define USER_ADDR_NULL 0
     * }
     */
    public static long USER_ADDR_NULL() {
        return USER_ADDR_NULL;
    }
    private static final long INT64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT64_MAX 9223372036854775807
     * }
     */
    public static long INT64_MAX() {
        return INT64_MAX;
    }
    private static final int INT8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT8_MIN -128
     * }
     */
    public static int INT8_MIN() {
        return INT8_MIN;
    }
    private static final int INT16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define INT16_MIN -32768
     * }
     */
    public static int INT16_MIN() {
        return INT16_MIN;
    }
    private static final int INT32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT32_MIN -2147483648
     * }
     */
    public static int INT32_MIN() {
        return INT32_MIN;
    }
    private static final long INT64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT64_MIN -9223372036854775808
     * }
     */
    public static long INT64_MIN() {
        return INT64_MIN;
    }
    private static final int UINT32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT32_MAX 4294967295
     * }
     */
    public static int UINT32_MAX() {
        return UINT32_MAX;
    }
    private static final long UINT64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT64_MAX -1
     * }
     */
    public static long UINT64_MAX() {
        return UINT64_MAX;
    }
    private static final int INT_LEAST8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST8_MIN -128
     * }
     */
    public static int INT_LEAST8_MIN() {
        return INT_LEAST8_MIN;
    }
    private static final int INT_LEAST16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST16_MIN -32768
     * }
     */
    public static int INT_LEAST16_MIN() {
        return INT_LEAST16_MIN;
    }
    private static final int INT_LEAST32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST32_MIN -2147483648
     * }
     */
    public static int INT_LEAST32_MIN() {
        return INT_LEAST32_MIN;
    }
    private static final long INT_LEAST64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST64_MIN -9223372036854775808
     * }
     */
    public static long INT_LEAST64_MIN() {
        return INT_LEAST64_MIN;
    }
    private static final int INT_LEAST8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST8_MAX 127
     * }
     */
    public static int INT_LEAST8_MAX() {
        return INT_LEAST8_MAX;
    }
    private static final int INT_LEAST16_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST16_MAX 32767
     * }
     */
    public static int INT_LEAST16_MAX() {
        return INT_LEAST16_MAX;
    }
    private static final int INT_LEAST32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST32_MAX 2147483647
     * }
     */
    public static int INT_LEAST32_MAX() {
        return INT_LEAST32_MAX;
    }
    private static final long INT_LEAST64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST64_MAX 9223372036854775807
     * }
     */
    public static long INT_LEAST64_MAX() {
        return INT_LEAST64_MAX;
    }
    private static final int UINT_LEAST8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST8_MAX 255
     * }
     */
    public static int UINT_LEAST8_MAX() {
        return UINT_LEAST8_MAX;
    }
    private static final int UINT_LEAST16_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST16_MAX 65535
     * }
     */
    public static int UINT_LEAST16_MAX() {
        return UINT_LEAST16_MAX;
    }
    private static final int UINT_LEAST32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST32_MAX 4294967295
     * }
     */
    public static int UINT_LEAST32_MAX() {
        return UINT_LEAST32_MAX;
    }
    private static final long UINT_LEAST64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST64_MAX -1
     * }
     */
    public static long UINT_LEAST64_MAX() {
        return UINT_LEAST64_MAX;
    }
    private static final int INT_FAST8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST8_MIN -128
     * }
     */
    public static int INT_FAST8_MIN() {
        return INT_FAST8_MIN;
    }
    private static final int INT_FAST16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST16_MIN -32768
     * }
     */
    public static int INT_FAST16_MIN() {
        return INT_FAST16_MIN;
    }
    private static final int INT_FAST32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST32_MIN -2147483648
     * }
     */
    public static int INT_FAST32_MIN() {
        return INT_FAST32_MIN;
    }
    private static final long INT_FAST64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST64_MIN -9223372036854775808
     * }
     */
    public static long INT_FAST64_MIN() {
        return INT_FAST64_MIN;
    }
    private static final int INT_FAST8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST8_MAX 127
     * }
     */
    public static int INT_FAST8_MAX() {
        return INT_FAST8_MAX;
    }
    private static final int INT_FAST16_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST16_MAX 32767
     * }
     */
    public static int INT_FAST16_MAX() {
        return INT_FAST16_MAX;
    }
    private static final int INT_FAST32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST32_MAX 2147483647
     * }
     */
    public static int INT_FAST32_MAX() {
        return INT_FAST32_MAX;
    }
    private static final long INT_FAST64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST64_MAX 9223372036854775807
     * }
     */
    public static long INT_FAST64_MAX() {
        return INT_FAST64_MAX;
    }
    private static final int UINT_FAST8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST8_MAX 255
     * }
     */
    public static int UINT_FAST8_MAX() {
        return UINT_FAST8_MAX;
    }
    private static final int UINT_FAST16_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST16_MAX 65535
     * }
     */
    public static int UINT_FAST16_MAX() {
        return UINT_FAST16_MAX;
    }
    private static final int UINT_FAST32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST32_MAX 4294967295
     * }
     */
    public static int UINT_FAST32_MAX() {
        return UINT_FAST32_MAX;
    }
    private static final long UINT_FAST64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST64_MAX -1
     * }
     */
    public static long UINT_FAST64_MAX() {
        return UINT_FAST64_MAX;
    }
    private static final long INTPTR_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INTPTR_MAX 9223372036854775807
     * }
     */
    public static long INTPTR_MAX() {
        return INTPTR_MAX;
    }
    private static final long INTPTR_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INTPTR_MIN -9223372036854775808
     * }
     */
    public static long INTPTR_MIN() {
        return INTPTR_MIN;
    }
    private static final long UINTPTR_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINTPTR_MAX -1
     * }
     */
    public static long UINTPTR_MAX() {
        return UINTPTR_MAX;
    }
    private static final long INTMAX_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INTMAX_MAX 9223372036854775807
     * }
     */
    public static long INTMAX_MAX() {
        return INTMAX_MAX;
    }
    private static final long UINTMAX_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINTMAX_MAX -1
     * }
     */
    public static long UINTMAX_MAX() {
        return UINTMAX_MAX;
    }
    private static final long INTMAX_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INTMAX_MIN -9223372036854775808
     * }
     */
    public static long INTMAX_MIN() {
        return INTMAX_MIN;
    }
    private static final long PTRDIFF_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define PTRDIFF_MIN -9223372036854775808
     * }
     */
    public static long PTRDIFF_MIN() {
        return PTRDIFF_MIN;
    }
    private static final long PTRDIFF_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define PTRDIFF_MAX 9223372036854775807
     * }
     */
    public static long PTRDIFF_MAX() {
        return PTRDIFF_MAX;
    }
    private static final long SIZE_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define SIZE_MAX -1
     * }
     */
    public static long SIZE_MAX() {
        return SIZE_MAX;
    }
    private static final long RSIZE_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define RSIZE_MAX 9223372036854775807
     * }
     */
    public static long RSIZE_MAX() {
        return RSIZE_MAX;
    }
    private static final int WCHAR_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define WCHAR_MAX 2147483647
     * }
     */
    public static int WCHAR_MAX() {
        return WCHAR_MAX;
    }
    private static final int WCHAR_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define WCHAR_MIN -2147483648
     * }
     */
    public static int WCHAR_MIN() {
        return WCHAR_MIN;
    }
    private static final int WINT_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define WINT_MIN -2147483648
     * }
     */
    public static int WINT_MIN() {
        return WINT_MIN;
    }
    private static final int WINT_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define WINT_MAX 2147483647
     * }
     */
    public static int WINT_MAX() {
        return WINT_MAX;
    }
    private static final int SIG_ATOMIC_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define SIG_ATOMIC_MIN -2147483648
     * }
     */
    public static int SIG_ATOMIC_MIN() {
        return SIG_ATOMIC_MIN;
    }
    private static final int SIG_ATOMIC_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define SIG_ATOMIC_MAX 2147483647
     * }
     */
    public static int SIG_ATOMIC_MAX() {
        return SIG_ATOMIC_MAX;
    }
    private static final MemorySegment VK_NULL_HANDLE = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define VK_NULL_HANDLE (void*) 0
     * }
     */
    public static MemorySegment VK_NULL_HANDLE() {
        return VK_NULL_HANDLE;
    }
    private static final int VK_API_VERSION_1_0 = (int)4194304L;
    /**
     * {@snippet lang=c :
     * #define VK_API_VERSION_1_0 4194304
     * }
     */
    public static int VK_API_VERSION_1_0() {
        return VK_API_VERSION_1_0;
    }
    private static final int VK_HEADER_VERSION_COMPLETE = (int)4206872L;
    /**
     * {@snippet lang=c :
     * #define VK_HEADER_VERSION_COMPLETE 4206872
     * }
     */
    public static int VK_HEADER_VERSION_COMPLETE() {
        return VK_HEADER_VERSION_COMPLETE;
    }
    private static final int VK_ATTACHMENT_UNUSED = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define VK_ATTACHMENT_UNUSED 4294967295
     * }
     */
    public static int VK_ATTACHMENT_UNUSED() {
        return VK_ATTACHMENT_UNUSED;
    }
    private static final int VK_FALSE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define VK_FALSE 0
     * }
     */
    public static int VK_FALSE() {
        return VK_FALSE;
    }
    private static final float VK_LOD_CLAMP_NONE = 1000.0f;
    /**
     * {@snippet lang=c :
     * #define VK_LOD_CLAMP_NONE 1000.0
     * }
     */
    public static float VK_LOD_CLAMP_NONE() {
        return VK_LOD_CLAMP_NONE;
    }
    private static final int VK_QUEUE_FAMILY_IGNORED = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define VK_QUEUE_FAMILY_IGNORED 4294967295
     * }
     */
    public static int VK_QUEUE_FAMILY_IGNORED() {
        return VK_QUEUE_FAMILY_IGNORED;
    }
    private static final int VK_REMAINING_ARRAY_LAYERS = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define VK_REMAINING_ARRAY_LAYERS 4294967295
     * }
     */
    public static int VK_REMAINING_ARRAY_LAYERS() {
        return VK_REMAINING_ARRAY_LAYERS;
    }
    private static final int VK_REMAINING_MIP_LEVELS = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define VK_REMAINING_MIP_LEVELS 4294967295
     * }
     */
    public static int VK_REMAINING_MIP_LEVELS() {
        return VK_REMAINING_MIP_LEVELS;
    }
    private static final int VK_SUBPASS_EXTERNAL = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define VK_SUBPASS_EXTERNAL 4294967295
     * }
     */
    public static int VK_SUBPASS_EXTERNAL() {
        return VK_SUBPASS_EXTERNAL;
    }
    private static final int VK_TRUE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define VK_TRUE 1
     * }
     */
    public static int VK_TRUE() {
        return VK_TRUE;
    }
    private static final long VK_WHOLE_SIZE = -1L;
    /**
     * {@snippet lang=c :
     * #define VK_WHOLE_SIZE -1
     * }
     */
    public static long VK_WHOLE_SIZE() {
        return VK_WHOLE_SIZE;
    }
    private static final int VK_MAX_MEMORY_TYPES = (int)32L;
    /**
     * {@snippet lang=c :
     * #define VK_MAX_MEMORY_TYPES 32
     * }
     */
    public static int VK_MAX_MEMORY_TYPES() {
        return VK_MAX_MEMORY_TYPES;
    }
    private static final int VK_MAX_PHYSICAL_DEVICE_NAME_SIZE = (int)256L;
    /**
     * {@snippet lang=c :
     * #define VK_MAX_PHYSICAL_DEVICE_NAME_SIZE 256
     * }
     */
    public static int VK_MAX_PHYSICAL_DEVICE_NAME_SIZE() {
        return VK_MAX_PHYSICAL_DEVICE_NAME_SIZE;
    }
    private static final int VK_UUID_SIZE = (int)16L;
    /**
     * {@snippet lang=c :
     * #define VK_UUID_SIZE 16
     * }
     */
    public static int VK_UUID_SIZE() {
        return VK_UUID_SIZE;
    }
    private static final int VK_MAX_EXTENSION_NAME_SIZE = (int)256L;
    /**
     * {@snippet lang=c :
     * #define VK_MAX_EXTENSION_NAME_SIZE 256
     * }
     */
    public static int VK_MAX_EXTENSION_NAME_SIZE() {
        return VK_MAX_EXTENSION_NAME_SIZE;
    }
    private static final int VK_MAX_DESCRIPTION_SIZE = (int)256L;
    /**
     * {@snippet lang=c :
     * #define VK_MAX_DESCRIPTION_SIZE 256
     * }
     */
    public static int VK_MAX_DESCRIPTION_SIZE() {
        return VK_MAX_DESCRIPTION_SIZE;
    }
    private static final int VK_MAX_MEMORY_HEAPS = (int)16L;
    /**
     * {@snippet lang=c :
     * #define VK_MAX_MEMORY_HEAPS 16
     * }
     */
    public static int VK_MAX_MEMORY_HEAPS() {
        return VK_MAX_MEMORY_HEAPS;
    }
    private static final int VK_API_VERSION_1_1 = (int)4198400L;
    /**
     * {@snippet lang=c :
     * #define VK_API_VERSION_1_1 4198400
     * }
     */
    public static int VK_API_VERSION_1_1() {
        return VK_API_VERSION_1_1;
    }
    private static final int VK_MAX_DEVICE_GROUP_SIZE = (int)32L;
    /**
     * {@snippet lang=c :
     * #define VK_MAX_DEVICE_GROUP_SIZE 32
     * }
     */
    public static int VK_MAX_DEVICE_GROUP_SIZE() {
        return VK_MAX_DEVICE_GROUP_SIZE;
    }
    private static final int VK_LUID_SIZE = (int)8L;
    /**
     * {@snippet lang=c :
     * #define VK_LUID_SIZE 8
     * }
     */
    public static int VK_LUID_SIZE() {
        return VK_LUID_SIZE;
    }
    private static final int VK_QUEUE_FAMILY_EXTERNAL = (int)4294967294L;
    /**
     * {@snippet lang=c :
     * #define VK_QUEUE_FAMILY_EXTERNAL 4294967294
     * }
     */
    public static int VK_QUEUE_FAMILY_EXTERNAL() {
        return VK_QUEUE_FAMILY_EXTERNAL;
    }
    private static final int VK_API_VERSION_1_2 = (int)4202496L;
    /**
     * {@snippet lang=c :
     * #define VK_API_VERSION_1_2 4202496
     * }
     */
    public static int VK_API_VERSION_1_2() {
        return VK_API_VERSION_1_2;
    }
    private static final int VK_MAX_DRIVER_NAME_SIZE = (int)256L;
    /**
     * {@snippet lang=c :
     * #define VK_MAX_DRIVER_NAME_SIZE 256
     * }
     */
    public static int VK_MAX_DRIVER_NAME_SIZE() {
        return VK_MAX_DRIVER_NAME_SIZE;
    }
    private static final int VK_MAX_DRIVER_INFO_SIZE = (int)256L;
    /**
     * {@snippet lang=c :
     * #define VK_MAX_DRIVER_INFO_SIZE 256
     * }
     */
    public static int VK_MAX_DRIVER_INFO_SIZE() {
        return VK_MAX_DRIVER_INFO_SIZE;
    }
    private static final int VK_API_VERSION_1_3 = (int)4206592L;
    /**
     * {@snippet lang=c :
     * #define VK_API_VERSION_1_3 4206592
     * }
     */
    public static int VK_API_VERSION_1_3() {
        return VK_API_VERSION_1_3;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_SURFACE_EXTENSION_NAME "VK_KHR_surface"
     * }
     */
    public static MemorySegment VK_KHR_SURFACE_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_SURFACE_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_surface");
        }
        return Holder.VK_KHR_SURFACE_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_SWAPCHAIN_EXTENSION_NAME "VK_KHR_swapchain"
     * }
     */
    public static MemorySegment VK_KHR_SWAPCHAIN_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_SWAPCHAIN_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_swapchain");
        }
        return Holder.VK_KHR_SWAPCHAIN_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_DISPLAY_EXTENSION_NAME "VK_KHR_display"
     * }
     */
    public static MemorySegment VK_KHR_DISPLAY_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_DISPLAY_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_display");
        }
        return Holder.VK_KHR_DISPLAY_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_DISPLAY_SWAPCHAIN_EXTENSION_NAME "VK_KHR_display_swapchain"
     * }
     */
    public static MemorySegment VK_KHR_DISPLAY_SWAPCHAIN_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_DISPLAY_SWAPCHAIN_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_display_swapchain");
        }
        return Holder.VK_KHR_DISPLAY_SWAPCHAIN_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_EXTENSION_NAME "VK_KHR_sampler_mirror_clamp_to_edge"
     * }
     */
    public static MemorySegment VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_sampler_mirror_clamp_to_edge");
        }
        return Holder.VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_VIDEO_QUEUE_EXTENSION_NAME "VK_KHR_video_queue"
     * }
     */
    public static MemorySegment VK_KHR_VIDEO_QUEUE_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_VIDEO_QUEUE_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_video_queue");
        }
        return Holder.VK_KHR_VIDEO_QUEUE_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_VIDEO_DECODE_QUEUE_EXTENSION_NAME "VK_KHR_video_decode_queue"
     * }
     */
    public static MemorySegment VK_KHR_VIDEO_DECODE_QUEUE_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_VIDEO_DECODE_QUEUE_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_video_decode_queue");
        }
        return Holder.VK_KHR_VIDEO_DECODE_QUEUE_EXTENSION_NAME;
    }
    private static final int VK_STD_VULKAN_VIDEO_CODEC_H264_ENCODE_API_VERSION_1_0_0 = (int)4194304L;
    /**
     * {@snippet lang=c :
     * #define VK_STD_VULKAN_VIDEO_CODEC_H264_ENCODE_API_VERSION_1_0_0 4194304
     * }
     */
    public static int VK_STD_VULKAN_VIDEO_CODEC_H264_ENCODE_API_VERSION_1_0_0() {
        return VK_STD_VULKAN_VIDEO_CODEC_H264_ENCODE_API_VERSION_1_0_0;
    }
    private static final int VK_STD_VULKAN_VIDEO_CODEC_H264_ENCODE_SPEC_VERSION = (int)4194304L;
    /**
     * {@snippet lang=c :
     * #define VK_STD_VULKAN_VIDEO_CODEC_H264_ENCODE_SPEC_VERSION 4194304
     * }
     */
    public static int VK_STD_VULKAN_VIDEO_CODEC_H264_ENCODE_SPEC_VERSION() {
        return VK_STD_VULKAN_VIDEO_CODEC_H264_ENCODE_SPEC_VERSION;
    }
    /**
     * {@snippet lang=c :
     * #define VK_STD_VULKAN_VIDEO_CODEC_H264_ENCODE_EXTENSION_NAME "VK_STD_vulkan_video_codec_h264_encode"
     * }
     */
    public static MemorySegment VK_STD_VULKAN_VIDEO_CODEC_H264_ENCODE_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_STD_VULKAN_VIDEO_CODEC_H264_ENCODE_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_STD_vulkan_video_codec_h264_encode");
        }
        return Holder.VK_STD_VULKAN_VIDEO_CODEC_H264_ENCODE_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_VIDEO_ENCODE_H264_EXTENSION_NAME "VK_KHR_video_encode_h264"
     * }
     */
    public static MemorySegment VK_KHR_VIDEO_ENCODE_H264_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_VIDEO_ENCODE_H264_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_video_encode_h264");
        }
        return Holder.VK_KHR_VIDEO_ENCODE_H264_EXTENSION_NAME;
    }
    private static final int VK_STD_VULKAN_VIDEO_CODEC_H265_ENCODE_API_VERSION_1_0_0 = (int)4194304L;
    /**
     * {@snippet lang=c :
     * #define VK_STD_VULKAN_VIDEO_CODEC_H265_ENCODE_API_VERSION_1_0_0 4194304
     * }
     */
    public static int VK_STD_VULKAN_VIDEO_CODEC_H265_ENCODE_API_VERSION_1_0_0() {
        return VK_STD_VULKAN_VIDEO_CODEC_H265_ENCODE_API_VERSION_1_0_0;
    }
    private static final int VK_STD_VULKAN_VIDEO_CODEC_H265_ENCODE_SPEC_VERSION = (int)4194304L;
    /**
     * {@snippet lang=c :
     * #define VK_STD_VULKAN_VIDEO_CODEC_H265_ENCODE_SPEC_VERSION 4194304
     * }
     */
    public static int VK_STD_VULKAN_VIDEO_CODEC_H265_ENCODE_SPEC_VERSION() {
        return VK_STD_VULKAN_VIDEO_CODEC_H265_ENCODE_SPEC_VERSION;
    }
    /**
     * {@snippet lang=c :
     * #define VK_STD_VULKAN_VIDEO_CODEC_H265_ENCODE_EXTENSION_NAME "VK_STD_vulkan_video_codec_h265_encode"
     * }
     */
    public static MemorySegment VK_STD_VULKAN_VIDEO_CODEC_H265_ENCODE_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_STD_VULKAN_VIDEO_CODEC_H265_ENCODE_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_STD_vulkan_video_codec_h265_encode");
        }
        return Holder.VK_STD_VULKAN_VIDEO_CODEC_H265_ENCODE_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_VIDEO_ENCODE_H265_EXTENSION_NAME "VK_KHR_video_encode_h265"
     * }
     */
    public static MemorySegment VK_KHR_VIDEO_ENCODE_H265_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_VIDEO_ENCODE_H265_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_video_encode_h265");
        }
        return Holder.VK_KHR_VIDEO_ENCODE_H265_EXTENSION_NAME;
    }
    private static final int VK_STD_VULKAN_VIDEO_CODEC_H264_DECODE_API_VERSION_1_0_0 = (int)4194304L;
    /**
     * {@snippet lang=c :
     * #define VK_STD_VULKAN_VIDEO_CODEC_H264_DECODE_API_VERSION_1_0_0 4194304
     * }
     */
    public static int VK_STD_VULKAN_VIDEO_CODEC_H264_DECODE_API_VERSION_1_0_0() {
        return VK_STD_VULKAN_VIDEO_CODEC_H264_DECODE_API_VERSION_1_0_0;
    }
    private static final int VK_STD_VULKAN_VIDEO_CODEC_H264_DECODE_SPEC_VERSION = (int)4194304L;
    /**
     * {@snippet lang=c :
     * #define VK_STD_VULKAN_VIDEO_CODEC_H264_DECODE_SPEC_VERSION 4194304
     * }
     */
    public static int VK_STD_VULKAN_VIDEO_CODEC_H264_DECODE_SPEC_VERSION() {
        return VK_STD_VULKAN_VIDEO_CODEC_H264_DECODE_SPEC_VERSION;
    }
    /**
     * {@snippet lang=c :
     * #define VK_STD_VULKAN_VIDEO_CODEC_H264_DECODE_EXTENSION_NAME "VK_STD_vulkan_video_codec_h264_decode"
     * }
     */
    public static MemorySegment VK_STD_VULKAN_VIDEO_CODEC_H264_DECODE_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_STD_VULKAN_VIDEO_CODEC_H264_DECODE_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_STD_vulkan_video_codec_h264_decode");
        }
        return Holder.VK_STD_VULKAN_VIDEO_CODEC_H264_DECODE_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_VIDEO_DECODE_H264_EXTENSION_NAME "VK_KHR_video_decode_h264"
     * }
     */
    public static MemorySegment VK_KHR_VIDEO_DECODE_H264_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_VIDEO_DECODE_H264_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_video_decode_h264");
        }
        return Holder.VK_KHR_VIDEO_DECODE_H264_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_DYNAMIC_RENDERING_EXTENSION_NAME "VK_KHR_dynamic_rendering"
     * }
     */
    public static MemorySegment VK_KHR_DYNAMIC_RENDERING_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_DYNAMIC_RENDERING_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_dynamic_rendering");
        }
        return Holder.VK_KHR_DYNAMIC_RENDERING_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_MULTIVIEW_EXTENSION_NAME "VK_KHR_multiview"
     * }
     */
    public static MemorySegment VK_KHR_MULTIVIEW_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_MULTIVIEW_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_multiview");
        }
        return Holder.VK_KHR_MULTIVIEW_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME "VK_KHR_get_physical_device_properties2"
     * }
     */
    public static MemorySegment VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_get_physical_device_properties2");
        }
        return Holder.VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_DEVICE_GROUP_EXTENSION_NAME "VK_KHR_device_group"
     * }
     */
    public static MemorySegment VK_KHR_DEVICE_GROUP_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_DEVICE_GROUP_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_device_group");
        }
        return Holder.VK_KHR_DEVICE_GROUP_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_SHADER_DRAW_PARAMETERS_EXTENSION_NAME "VK_KHR_shader_draw_parameters"
     * }
     */
    public static MemorySegment VK_KHR_SHADER_DRAW_PARAMETERS_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_SHADER_DRAW_PARAMETERS_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_shader_draw_parameters");
        }
        return Holder.VK_KHR_SHADER_DRAW_PARAMETERS_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_MAINTENANCE_1_EXTENSION_NAME "VK_KHR_maintenance1"
     * }
     */
    public static MemorySegment VK_KHR_MAINTENANCE_1_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_MAINTENANCE_1_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_maintenance1");
        }
        return Holder.VK_KHR_MAINTENANCE_1_EXTENSION_NAME;
    }
    private static final int VK_KHR_MAINTENANCE1_SPEC_VERSION = (int)2L;
    /**
     * {@snippet lang=c :
     * #define VK_KHR_MAINTENANCE1_SPEC_VERSION 2
     * }
     */
    public static int VK_KHR_MAINTENANCE1_SPEC_VERSION() {
        return VK_KHR_MAINTENANCE1_SPEC_VERSION;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_MAINTENANCE1_EXTENSION_NAME "VK_KHR_maintenance1"
     * }
     */
    public static MemorySegment VK_KHR_MAINTENANCE1_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_MAINTENANCE1_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_maintenance1");
        }
        return Holder.VK_KHR_MAINTENANCE1_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_DEVICE_GROUP_CREATION_EXTENSION_NAME "VK_KHR_device_group_creation"
     * }
     */
    public static MemorySegment VK_KHR_DEVICE_GROUP_CREATION_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_DEVICE_GROUP_CREATION_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_device_group_creation");
        }
        return Holder.VK_KHR_DEVICE_GROUP_CREATION_EXTENSION_NAME;
    }
    private static final int VK_MAX_DEVICE_GROUP_SIZE_KHR = (int)32L;
    /**
     * {@snippet lang=c :
     * #define VK_MAX_DEVICE_GROUP_SIZE_KHR 32
     * }
     */
    public static int VK_MAX_DEVICE_GROUP_SIZE_KHR() {
        return VK_MAX_DEVICE_GROUP_SIZE_KHR;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME "VK_KHR_external_memory_capabilities"
     * }
     */
    public static MemorySegment VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_external_memory_capabilities");
        }
        return Holder.VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME;
    }
    private static final int VK_LUID_SIZE_KHR = (int)8L;
    /**
     * {@snippet lang=c :
     * #define VK_LUID_SIZE_KHR 8
     * }
     */
    public static int VK_LUID_SIZE_KHR() {
        return VK_LUID_SIZE_KHR;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_EXTERNAL_MEMORY_EXTENSION_NAME "VK_KHR_external_memory"
     * }
     */
    public static MemorySegment VK_KHR_EXTERNAL_MEMORY_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_EXTERNAL_MEMORY_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_external_memory");
        }
        return Holder.VK_KHR_EXTERNAL_MEMORY_EXTENSION_NAME;
    }
    private static final int VK_QUEUE_FAMILY_EXTERNAL_KHR = (int)4294967294L;
    /**
     * {@snippet lang=c :
     * #define VK_QUEUE_FAMILY_EXTERNAL_KHR 4294967294
     * }
     */
    public static int VK_QUEUE_FAMILY_EXTERNAL_KHR() {
        return VK_QUEUE_FAMILY_EXTERNAL_KHR;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_EXTERNAL_MEMORY_FD_EXTENSION_NAME "VK_KHR_external_memory_fd"
     * }
     */
    public static MemorySegment VK_KHR_EXTERNAL_MEMORY_FD_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_EXTERNAL_MEMORY_FD_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_external_memory_fd");
        }
        return Holder.VK_KHR_EXTERNAL_MEMORY_FD_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_EXTENSION_NAME "VK_KHR_external_semaphore_capabilities"
     * }
     */
    public static MemorySegment VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_external_semaphore_capabilities");
        }
        return Holder.VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_EXTERNAL_SEMAPHORE_EXTENSION_NAME "VK_KHR_external_semaphore"
     * }
     */
    public static MemorySegment VK_KHR_EXTERNAL_SEMAPHORE_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_EXTERNAL_SEMAPHORE_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_external_semaphore");
        }
        return Holder.VK_KHR_EXTERNAL_SEMAPHORE_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_EXTERNAL_SEMAPHORE_FD_EXTENSION_NAME "VK_KHR_external_semaphore_fd"
     * }
     */
    public static MemorySegment VK_KHR_EXTERNAL_SEMAPHORE_FD_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_EXTERNAL_SEMAPHORE_FD_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_external_semaphore_fd");
        }
        return Holder.VK_KHR_EXTERNAL_SEMAPHORE_FD_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_PUSH_DESCRIPTOR_EXTENSION_NAME "VK_KHR_push_descriptor"
     * }
     */
    public static MemorySegment VK_KHR_PUSH_DESCRIPTOR_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_PUSH_DESCRIPTOR_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_push_descriptor");
        }
        return Holder.VK_KHR_PUSH_DESCRIPTOR_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_SHADER_FLOAT16_INT8_EXTENSION_NAME "VK_KHR_shader_float16_int8"
     * }
     */
    public static MemorySegment VK_KHR_SHADER_FLOAT16_INT8_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_SHADER_FLOAT16_INT8_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_shader_float16_int8");
        }
        return Holder.VK_KHR_SHADER_FLOAT16_INT8_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_16BIT_STORAGE_EXTENSION_NAME "VK_KHR_16bit_storage"
     * }
     */
    public static MemorySegment VK_KHR_16BIT_STORAGE_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_16BIT_STORAGE_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_16bit_storage");
        }
        return Holder.VK_KHR_16BIT_STORAGE_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_INCREMENTAL_PRESENT_EXTENSION_NAME "VK_KHR_incremental_present"
     * }
     */
    public static MemorySegment VK_KHR_INCREMENTAL_PRESENT_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_INCREMENTAL_PRESENT_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_incremental_present");
        }
        return Holder.VK_KHR_INCREMENTAL_PRESENT_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_DESCRIPTOR_UPDATE_TEMPLATE_EXTENSION_NAME "VK_KHR_descriptor_update_template"
     * }
     */
    public static MemorySegment VK_KHR_DESCRIPTOR_UPDATE_TEMPLATE_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_DESCRIPTOR_UPDATE_TEMPLATE_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_descriptor_update_template");
        }
        return Holder.VK_KHR_DESCRIPTOR_UPDATE_TEMPLATE_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_IMAGELESS_FRAMEBUFFER_EXTENSION_NAME "VK_KHR_imageless_framebuffer"
     * }
     */
    public static MemorySegment VK_KHR_IMAGELESS_FRAMEBUFFER_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_IMAGELESS_FRAMEBUFFER_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_imageless_framebuffer");
        }
        return Holder.VK_KHR_IMAGELESS_FRAMEBUFFER_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_CREATE_RENDERPASS_2_EXTENSION_NAME "VK_KHR_create_renderpass2"
     * }
     */
    public static MemorySegment VK_KHR_CREATE_RENDERPASS_2_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_CREATE_RENDERPASS_2_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_create_renderpass2");
        }
        return Holder.VK_KHR_CREATE_RENDERPASS_2_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_SHARED_PRESENTABLE_IMAGE_EXTENSION_NAME "VK_KHR_shared_presentable_image"
     * }
     */
    public static MemorySegment VK_KHR_SHARED_PRESENTABLE_IMAGE_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_SHARED_PRESENTABLE_IMAGE_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_shared_presentable_image");
        }
        return Holder.VK_KHR_SHARED_PRESENTABLE_IMAGE_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_EXTERNAL_FENCE_CAPABILITIES_EXTENSION_NAME "VK_KHR_external_fence_capabilities"
     * }
     */
    public static MemorySegment VK_KHR_EXTERNAL_FENCE_CAPABILITIES_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_EXTERNAL_FENCE_CAPABILITIES_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_external_fence_capabilities");
        }
        return Holder.VK_KHR_EXTERNAL_FENCE_CAPABILITIES_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_EXTERNAL_FENCE_EXTENSION_NAME "VK_KHR_external_fence"
     * }
     */
    public static MemorySegment VK_KHR_EXTERNAL_FENCE_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_EXTERNAL_FENCE_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_external_fence");
        }
        return Holder.VK_KHR_EXTERNAL_FENCE_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_EXTERNAL_FENCE_FD_EXTENSION_NAME "VK_KHR_external_fence_fd"
     * }
     */
    public static MemorySegment VK_KHR_EXTERNAL_FENCE_FD_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_EXTERNAL_FENCE_FD_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_external_fence_fd");
        }
        return Holder.VK_KHR_EXTERNAL_FENCE_FD_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_PERFORMANCE_QUERY_EXTENSION_NAME "VK_KHR_performance_query"
     * }
     */
    public static MemorySegment VK_KHR_PERFORMANCE_QUERY_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_PERFORMANCE_QUERY_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_performance_query");
        }
        return Holder.VK_KHR_PERFORMANCE_QUERY_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_MAINTENANCE_2_EXTENSION_NAME "VK_KHR_maintenance2"
     * }
     */
    public static MemorySegment VK_KHR_MAINTENANCE_2_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_MAINTENANCE_2_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_maintenance2");
        }
        return Holder.VK_KHR_MAINTENANCE_2_EXTENSION_NAME;
    }
    private static final int VK_KHR_MAINTENANCE2_SPEC_VERSION = (int)1L;
    /**
     * {@snippet lang=c :
     * #define VK_KHR_MAINTENANCE2_SPEC_VERSION 1
     * }
     */
    public static int VK_KHR_MAINTENANCE2_SPEC_VERSION() {
        return VK_KHR_MAINTENANCE2_SPEC_VERSION;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_MAINTENANCE2_EXTENSION_NAME "VK_KHR_maintenance2"
     * }
     */
    public static MemorySegment VK_KHR_MAINTENANCE2_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_MAINTENANCE2_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_maintenance2");
        }
        return Holder.VK_KHR_MAINTENANCE2_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_GET_SURFACE_CAPABILITIES_2_EXTENSION_NAME "VK_KHR_get_surface_capabilities2"
     * }
     */
    public static MemorySegment VK_KHR_GET_SURFACE_CAPABILITIES_2_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_GET_SURFACE_CAPABILITIES_2_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_get_surface_capabilities2");
        }
        return Holder.VK_KHR_GET_SURFACE_CAPABILITIES_2_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_VARIABLE_POINTERS_EXTENSION_NAME "VK_KHR_variable_pointers"
     * }
     */
    public static MemorySegment VK_KHR_VARIABLE_POINTERS_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_VARIABLE_POINTERS_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_variable_pointers");
        }
        return Holder.VK_KHR_VARIABLE_POINTERS_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_GET_DISPLAY_PROPERTIES_2_EXTENSION_NAME "VK_KHR_get_display_properties2"
     * }
     */
    public static MemorySegment VK_KHR_GET_DISPLAY_PROPERTIES_2_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_GET_DISPLAY_PROPERTIES_2_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_get_display_properties2");
        }
        return Holder.VK_KHR_GET_DISPLAY_PROPERTIES_2_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_DEDICATED_ALLOCATION_EXTENSION_NAME "VK_KHR_dedicated_allocation"
     * }
     */
    public static MemorySegment VK_KHR_DEDICATED_ALLOCATION_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_DEDICATED_ALLOCATION_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_dedicated_allocation");
        }
        return Holder.VK_KHR_DEDICATED_ALLOCATION_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_STORAGE_BUFFER_STORAGE_CLASS_EXTENSION_NAME "VK_KHR_storage_buffer_storage_class"
     * }
     */
    public static MemorySegment VK_KHR_STORAGE_BUFFER_STORAGE_CLASS_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_STORAGE_BUFFER_STORAGE_CLASS_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_storage_buffer_storage_class");
        }
        return Holder.VK_KHR_STORAGE_BUFFER_STORAGE_CLASS_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_RELAXED_BLOCK_LAYOUT_EXTENSION_NAME "VK_KHR_relaxed_block_layout"
     * }
     */
    public static MemorySegment VK_KHR_RELAXED_BLOCK_LAYOUT_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_RELAXED_BLOCK_LAYOUT_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_relaxed_block_layout");
        }
        return Holder.VK_KHR_RELAXED_BLOCK_LAYOUT_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_GET_MEMORY_REQUIREMENTS_2_EXTENSION_NAME "VK_KHR_get_memory_requirements2"
     * }
     */
    public static MemorySegment VK_KHR_GET_MEMORY_REQUIREMENTS_2_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_GET_MEMORY_REQUIREMENTS_2_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_get_memory_requirements2");
        }
        return Holder.VK_KHR_GET_MEMORY_REQUIREMENTS_2_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_IMAGE_FORMAT_LIST_EXTENSION_NAME "VK_KHR_image_format_list"
     * }
     */
    public static MemorySegment VK_KHR_IMAGE_FORMAT_LIST_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_IMAGE_FORMAT_LIST_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_image_format_list");
        }
        return Holder.VK_KHR_IMAGE_FORMAT_LIST_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_SAMPLER_YCBCR_CONVERSION_EXTENSION_NAME "VK_KHR_sampler_ycbcr_conversion"
     * }
     */
    public static MemorySegment VK_KHR_SAMPLER_YCBCR_CONVERSION_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_SAMPLER_YCBCR_CONVERSION_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_sampler_ycbcr_conversion");
        }
        return Holder.VK_KHR_SAMPLER_YCBCR_CONVERSION_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_BIND_MEMORY_2_EXTENSION_NAME "VK_KHR_bind_memory2"
     * }
     */
    public static MemorySegment VK_KHR_BIND_MEMORY_2_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_BIND_MEMORY_2_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_bind_memory2");
        }
        return Holder.VK_KHR_BIND_MEMORY_2_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_MAINTENANCE_3_EXTENSION_NAME "VK_KHR_maintenance3"
     * }
     */
    public static MemorySegment VK_KHR_MAINTENANCE_3_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_MAINTENANCE_3_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_maintenance3");
        }
        return Holder.VK_KHR_MAINTENANCE_3_EXTENSION_NAME;
    }
    private static final int VK_KHR_MAINTENANCE3_SPEC_VERSION = (int)1L;
    /**
     * {@snippet lang=c :
     * #define VK_KHR_MAINTENANCE3_SPEC_VERSION 1
     * }
     */
    public static int VK_KHR_MAINTENANCE3_SPEC_VERSION() {
        return VK_KHR_MAINTENANCE3_SPEC_VERSION;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_MAINTENANCE3_EXTENSION_NAME "VK_KHR_maintenance3"
     * }
     */
    public static MemorySegment VK_KHR_MAINTENANCE3_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_MAINTENANCE3_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_maintenance3");
        }
        return Holder.VK_KHR_MAINTENANCE3_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_DRAW_INDIRECT_COUNT_EXTENSION_NAME "VK_KHR_draw_indirect_count"
     * }
     */
    public static MemorySegment VK_KHR_DRAW_INDIRECT_COUNT_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_DRAW_INDIRECT_COUNT_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_draw_indirect_count");
        }
        return Holder.VK_KHR_DRAW_INDIRECT_COUNT_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_SHADER_SUBGROUP_EXTENDED_TYPES_EXTENSION_NAME "VK_KHR_shader_subgroup_extended_types"
     * }
     */
    public static MemorySegment VK_KHR_SHADER_SUBGROUP_EXTENDED_TYPES_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_SHADER_SUBGROUP_EXTENDED_TYPES_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_shader_subgroup_extended_types");
        }
        return Holder.VK_KHR_SHADER_SUBGROUP_EXTENDED_TYPES_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_8BIT_STORAGE_EXTENSION_NAME "VK_KHR_8bit_storage"
     * }
     */
    public static MemorySegment VK_KHR_8BIT_STORAGE_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_8BIT_STORAGE_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_8bit_storage");
        }
        return Holder.VK_KHR_8BIT_STORAGE_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_SHADER_ATOMIC_INT64_EXTENSION_NAME "VK_KHR_shader_atomic_int64"
     * }
     */
    public static MemorySegment VK_KHR_SHADER_ATOMIC_INT64_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_SHADER_ATOMIC_INT64_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_shader_atomic_int64");
        }
        return Holder.VK_KHR_SHADER_ATOMIC_INT64_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_SHADER_CLOCK_EXTENSION_NAME "VK_KHR_shader_clock"
     * }
     */
    public static MemorySegment VK_KHR_SHADER_CLOCK_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_SHADER_CLOCK_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_shader_clock");
        }
        return Holder.VK_KHR_SHADER_CLOCK_EXTENSION_NAME;
    }
    private static final int VK_STD_VULKAN_VIDEO_CODEC_H265_DECODE_API_VERSION_1_0_0 = (int)4194304L;
    /**
     * {@snippet lang=c :
     * #define VK_STD_VULKAN_VIDEO_CODEC_H265_DECODE_API_VERSION_1_0_0 4194304
     * }
     */
    public static int VK_STD_VULKAN_VIDEO_CODEC_H265_DECODE_API_VERSION_1_0_0() {
        return VK_STD_VULKAN_VIDEO_CODEC_H265_DECODE_API_VERSION_1_0_0;
    }
    private static final int VK_STD_VULKAN_VIDEO_CODEC_H265_DECODE_SPEC_VERSION = (int)4194304L;
    /**
     * {@snippet lang=c :
     * #define VK_STD_VULKAN_VIDEO_CODEC_H265_DECODE_SPEC_VERSION 4194304
     * }
     */
    public static int VK_STD_VULKAN_VIDEO_CODEC_H265_DECODE_SPEC_VERSION() {
        return VK_STD_VULKAN_VIDEO_CODEC_H265_DECODE_SPEC_VERSION;
    }
    /**
     * {@snippet lang=c :
     * #define VK_STD_VULKAN_VIDEO_CODEC_H265_DECODE_EXTENSION_NAME "VK_STD_vulkan_video_codec_h265_decode"
     * }
     */
    public static MemorySegment VK_STD_VULKAN_VIDEO_CODEC_H265_DECODE_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_STD_VULKAN_VIDEO_CODEC_H265_DECODE_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_STD_vulkan_video_codec_h265_decode");
        }
        return Holder.VK_STD_VULKAN_VIDEO_CODEC_H265_DECODE_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_VIDEO_DECODE_H265_EXTENSION_NAME "VK_KHR_video_decode_h265"
     * }
     */
    public static MemorySegment VK_KHR_VIDEO_DECODE_H265_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_VIDEO_DECODE_H265_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_video_decode_h265");
        }
        return Holder.VK_KHR_VIDEO_DECODE_H265_EXTENSION_NAME;
    }
    private static final int VK_MAX_GLOBAL_PRIORITY_SIZE_KHR = (int)16L;
    /**
     * {@snippet lang=c :
     * #define VK_MAX_GLOBAL_PRIORITY_SIZE_KHR 16
     * }
     */
    public static int VK_MAX_GLOBAL_PRIORITY_SIZE_KHR() {
        return VK_MAX_GLOBAL_PRIORITY_SIZE_KHR;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_GLOBAL_PRIORITY_EXTENSION_NAME "VK_KHR_global_priority"
     * }
     */
    public static MemorySegment VK_KHR_GLOBAL_PRIORITY_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_GLOBAL_PRIORITY_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_global_priority");
        }
        return Holder.VK_KHR_GLOBAL_PRIORITY_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_DRIVER_PROPERTIES_EXTENSION_NAME "VK_KHR_driver_properties"
     * }
     */
    public static MemorySegment VK_KHR_DRIVER_PROPERTIES_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_DRIVER_PROPERTIES_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_driver_properties");
        }
        return Holder.VK_KHR_DRIVER_PROPERTIES_EXTENSION_NAME;
    }
    private static final int VK_MAX_DRIVER_NAME_SIZE_KHR = (int)256L;
    /**
     * {@snippet lang=c :
     * #define VK_MAX_DRIVER_NAME_SIZE_KHR 256
     * }
     */
    public static int VK_MAX_DRIVER_NAME_SIZE_KHR() {
        return VK_MAX_DRIVER_NAME_SIZE_KHR;
    }
    private static final int VK_MAX_DRIVER_INFO_SIZE_KHR = (int)256L;
    /**
     * {@snippet lang=c :
     * #define VK_MAX_DRIVER_INFO_SIZE_KHR 256
     * }
     */
    public static int VK_MAX_DRIVER_INFO_SIZE_KHR() {
        return VK_MAX_DRIVER_INFO_SIZE_KHR;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_SHADER_FLOAT_CONTROLS_EXTENSION_NAME "VK_KHR_shader_float_controls"
     * }
     */
    public static MemorySegment VK_KHR_SHADER_FLOAT_CONTROLS_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_SHADER_FLOAT_CONTROLS_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_shader_float_controls");
        }
        return Holder.VK_KHR_SHADER_FLOAT_CONTROLS_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_DEPTH_STENCIL_RESOLVE_EXTENSION_NAME "VK_KHR_depth_stencil_resolve"
     * }
     */
    public static MemorySegment VK_KHR_DEPTH_STENCIL_RESOLVE_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_DEPTH_STENCIL_RESOLVE_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_depth_stencil_resolve");
        }
        return Holder.VK_KHR_DEPTH_STENCIL_RESOLVE_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_SWAPCHAIN_MUTABLE_FORMAT_EXTENSION_NAME "VK_KHR_swapchain_mutable_format"
     * }
     */
    public static MemorySegment VK_KHR_SWAPCHAIN_MUTABLE_FORMAT_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_SWAPCHAIN_MUTABLE_FORMAT_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_swapchain_mutable_format");
        }
        return Holder.VK_KHR_SWAPCHAIN_MUTABLE_FORMAT_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_TIMELINE_SEMAPHORE_EXTENSION_NAME "VK_KHR_timeline_semaphore"
     * }
     */
    public static MemorySegment VK_KHR_TIMELINE_SEMAPHORE_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_TIMELINE_SEMAPHORE_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_timeline_semaphore");
        }
        return Holder.VK_KHR_TIMELINE_SEMAPHORE_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_VULKAN_MEMORY_MODEL_EXTENSION_NAME "VK_KHR_vulkan_memory_model"
     * }
     */
    public static MemorySegment VK_KHR_VULKAN_MEMORY_MODEL_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_VULKAN_MEMORY_MODEL_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_vulkan_memory_model");
        }
        return Holder.VK_KHR_VULKAN_MEMORY_MODEL_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_SHADER_TERMINATE_INVOCATION_EXTENSION_NAME "VK_KHR_shader_terminate_invocation"
     * }
     */
    public static MemorySegment VK_KHR_SHADER_TERMINATE_INVOCATION_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_SHADER_TERMINATE_INVOCATION_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_shader_terminate_invocation");
        }
        return Holder.VK_KHR_SHADER_TERMINATE_INVOCATION_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_FRAGMENT_SHADING_RATE_EXTENSION_NAME "VK_KHR_fragment_shading_rate"
     * }
     */
    public static MemorySegment VK_KHR_FRAGMENT_SHADING_RATE_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_FRAGMENT_SHADING_RATE_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_fragment_shading_rate");
        }
        return Holder.VK_KHR_FRAGMENT_SHADING_RATE_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_DYNAMIC_RENDERING_LOCAL_READ_EXTENSION_NAME "VK_KHR_dynamic_rendering_local_read"
     * }
     */
    public static MemorySegment VK_KHR_DYNAMIC_RENDERING_LOCAL_READ_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_DYNAMIC_RENDERING_LOCAL_READ_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_dynamic_rendering_local_read");
        }
        return Holder.VK_KHR_DYNAMIC_RENDERING_LOCAL_READ_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_SHADER_QUAD_CONTROL_EXTENSION_NAME "VK_KHR_shader_quad_control"
     * }
     */
    public static MemorySegment VK_KHR_SHADER_QUAD_CONTROL_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_SHADER_QUAD_CONTROL_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_shader_quad_control");
        }
        return Holder.VK_KHR_SHADER_QUAD_CONTROL_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_SPIRV_1_4_EXTENSION_NAME "VK_KHR_spirv_1_4"
     * }
     */
    public static MemorySegment VK_KHR_SPIRV_1_4_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_SPIRV_1_4_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_spirv_1_4");
        }
        return Holder.VK_KHR_SPIRV_1_4_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_SURFACE_PROTECTED_CAPABILITIES_EXTENSION_NAME "VK_KHR_surface_protected_capabilities"
     * }
     */
    public static MemorySegment VK_KHR_SURFACE_PROTECTED_CAPABILITIES_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_SURFACE_PROTECTED_CAPABILITIES_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_surface_protected_capabilities");
        }
        return Holder.VK_KHR_SURFACE_PROTECTED_CAPABILITIES_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_SEPARATE_DEPTH_STENCIL_LAYOUTS_EXTENSION_NAME "VK_KHR_separate_depth_stencil_layouts"
     * }
     */
    public static MemorySegment VK_KHR_SEPARATE_DEPTH_STENCIL_LAYOUTS_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_SEPARATE_DEPTH_STENCIL_LAYOUTS_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_separate_depth_stencil_layouts");
        }
        return Holder.VK_KHR_SEPARATE_DEPTH_STENCIL_LAYOUTS_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_PRESENT_WAIT_EXTENSION_NAME "VK_KHR_present_wait"
     * }
     */
    public static MemorySegment VK_KHR_PRESENT_WAIT_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_PRESENT_WAIT_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_present_wait");
        }
        return Holder.VK_KHR_PRESENT_WAIT_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_UNIFORM_BUFFER_STANDARD_LAYOUT_EXTENSION_NAME "VK_KHR_uniform_buffer_standard_layout"
     * }
     */
    public static MemorySegment VK_KHR_UNIFORM_BUFFER_STANDARD_LAYOUT_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_UNIFORM_BUFFER_STANDARD_LAYOUT_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_uniform_buffer_standard_layout");
        }
        return Holder.VK_KHR_UNIFORM_BUFFER_STANDARD_LAYOUT_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME "VK_KHR_buffer_device_address"
     * }
     */
    public static MemorySegment VK_KHR_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_buffer_device_address");
        }
        return Holder.VK_KHR_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_DEFERRED_HOST_OPERATIONS_EXTENSION_NAME "VK_KHR_deferred_host_operations"
     * }
     */
    public static MemorySegment VK_KHR_DEFERRED_HOST_OPERATIONS_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_DEFERRED_HOST_OPERATIONS_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_deferred_host_operations");
        }
        return Holder.VK_KHR_DEFERRED_HOST_OPERATIONS_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_PIPELINE_EXECUTABLE_PROPERTIES_EXTENSION_NAME "VK_KHR_pipeline_executable_properties"
     * }
     */
    public static MemorySegment VK_KHR_PIPELINE_EXECUTABLE_PROPERTIES_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_PIPELINE_EXECUTABLE_PROPERTIES_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_pipeline_executable_properties");
        }
        return Holder.VK_KHR_PIPELINE_EXECUTABLE_PROPERTIES_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_MAP_MEMORY_2_EXTENSION_NAME "VK_KHR_map_memory2"
     * }
     */
    public static MemorySegment VK_KHR_MAP_MEMORY_2_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_MAP_MEMORY_2_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_map_memory2");
        }
        return Holder.VK_KHR_MAP_MEMORY_2_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_SHADER_INTEGER_DOT_PRODUCT_EXTENSION_NAME "VK_KHR_shader_integer_dot_product"
     * }
     */
    public static MemorySegment VK_KHR_SHADER_INTEGER_DOT_PRODUCT_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_SHADER_INTEGER_DOT_PRODUCT_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_shader_integer_dot_product");
        }
        return Holder.VK_KHR_SHADER_INTEGER_DOT_PRODUCT_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_PIPELINE_LIBRARY_EXTENSION_NAME "VK_KHR_pipeline_library"
     * }
     */
    public static MemorySegment VK_KHR_PIPELINE_LIBRARY_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_PIPELINE_LIBRARY_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_pipeline_library");
        }
        return Holder.VK_KHR_PIPELINE_LIBRARY_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_SHADER_NON_SEMANTIC_INFO_EXTENSION_NAME "VK_KHR_shader_non_semantic_info"
     * }
     */
    public static MemorySegment VK_KHR_SHADER_NON_SEMANTIC_INFO_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_SHADER_NON_SEMANTIC_INFO_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_shader_non_semantic_info");
        }
        return Holder.VK_KHR_SHADER_NON_SEMANTIC_INFO_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_PRESENT_ID_EXTENSION_NAME "VK_KHR_present_id"
     * }
     */
    public static MemorySegment VK_KHR_PRESENT_ID_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_PRESENT_ID_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_present_id");
        }
        return Holder.VK_KHR_PRESENT_ID_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_VIDEO_ENCODE_QUEUE_EXTENSION_NAME "VK_KHR_video_encode_queue"
     * }
     */
    public static MemorySegment VK_KHR_VIDEO_ENCODE_QUEUE_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_VIDEO_ENCODE_QUEUE_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_video_encode_queue");
        }
        return Holder.VK_KHR_VIDEO_ENCODE_QUEUE_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_SYNCHRONIZATION_2_EXTENSION_NAME "VK_KHR_synchronization2"
     * }
     */
    public static MemorySegment VK_KHR_SYNCHRONIZATION_2_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_SYNCHRONIZATION_2_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_synchronization2");
        }
        return Holder.VK_KHR_SYNCHRONIZATION_2_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_FRAGMENT_SHADER_BARYCENTRIC_EXTENSION_NAME "VK_KHR_fragment_shader_barycentric"
     * }
     */
    public static MemorySegment VK_KHR_FRAGMENT_SHADER_BARYCENTRIC_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_FRAGMENT_SHADER_BARYCENTRIC_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_fragment_shader_barycentric");
        }
        return Holder.VK_KHR_FRAGMENT_SHADER_BARYCENTRIC_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_EXTENSION_NAME "VK_KHR_shader_subgroup_uniform_control_flow"
     * }
     */
    public static MemorySegment VK_KHR_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_shader_subgroup_uniform_control_flow");
        }
        return Holder.VK_KHR_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_ZERO_INITIALIZE_WORKGROUP_MEMORY_EXTENSION_NAME "VK_KHR_zero_initialize_workgroup_memory"
     * }
     */
    public static MemorySegment VK_KHR_ZERO_INITIALIZE_WORKGROUP_MEMORY_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_ZERO_INITIALIZE_WORKGROUP_MEMORY_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_zero_initialize_workgroup_memory");
        }
        return Holder.VK_KHR_ZERO_INITIALIZE_WORKGROUP_MEMORY_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_EXTENSION_NAME "VK_KHR_workgroup_memory_explicit_layout"
     * }
     */
    public static MemorySegment VK_KHR_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_workgroup_memory_explicit_layout");
        }
        return Holder.VK_KHR_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_COPY_COMMANDS_2_EXTENSION_NAME "VK_KHR_copy_commands2"
     * }
     */
    public static MemorySegment VK_KHR_COPY_COMMANDS_2_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_COPY_COMMANDS_2_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_copy_commands2");
        }
        return Holder.VK_KHR_COPY_COMMANDS_2_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_FORMAT_FEATURE_FLAGS_2_EXTENSION_NAME "VK_KHR_format_feature_flags2"
     * }
     */
    public static MemorySegment VK_KHR_FORMAT_FEATURE_FLAGS_2_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_FORMAT_FEATURE_FLAGS_2_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_format_feature_flags2");
        }
        return Holder.VK_KHR_FORMAT_FEATURE_FLAGS_2_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_RAY_TRACING_MAINTENANCE_1_EXTENSION_NAME "VK_KHR_ray_tracing_maintenance1"
     * }
     */
    public static MemorySegment VK_KHR_RAY_TRACING_MAINTENANCE_1_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_RAY_TRACING_MAINTENANCE_1_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_ray_tracing_maintenance1");
        }
        return Holder.VK_KHR_RAY_TRACING_MAINTENANCE_1_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_PORTABILITY_ENUMERATION_EXTENSION_NAME "VK_KHR_portability_enumeration"
     * }
     */
    public static MemorySegment VK_KHR_PORTABILITY_ENUMERATION_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_PORTABILITY_ENUMERATION_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_portability_enumeration");
        }
        return Holder.VK_KHR_PORTABILITY_ENUMERATION_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_MAINTENANCE_4_EXTENSION_NAME "VK_KHR_maintenance4"
     * }
     */
    public static MemorySegment VK_KHR_MAINTENANCE_4_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_MAINTENANCE_4_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_maintenance4");
        }
        return Holder.VK_KHR_MAINTENANCE_4_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_SHADER_SUBGROUP_ROTATE_EXTENSION_NAME "VK_KHR_shader_subgroup_rotate"
     * }
     */
    public static MemorySegment VK_KHR_SHADER_SUBGROUP_ROTATE_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_SHADER_SUBGROUP_ROTATE_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_shader_subgroup_rotate");
        }
        return Holder.VK_KHR_SHADER_SUBGROUP_ROTATE_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_SHADER_MAXIMAL_RECONVERGENCE_EXTENSION_NAME "VK_KHR_shader_maximal_reconvergence"
     * }
     */
    public static MemorySegment VK_KHR_SHADER_MAXIMAL_RECONVERGENCE_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_SHADER_MAXIMAL_RECONVERGENCE_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_shader_maximal_reconvergence");
        }
        return Holder.VK_KHR_SHADER_MAXIMAL_RECONVERGENCE_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_MAINTENANCE_5_EXTENSION_NAME "VK_KHR_maintenance5"
     * }
     */
    public static MemorySegment VK_KHR_MAINTENANCE_5_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_MAINTENANCE_5_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_maintenance5");
        }
        return Holder.VK_KHR_MAINTENANCE_5_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_RAY_TRACING_POSITION_FETCH_EXTENSION_NAME "VK_KHR_ray_tracing_position_fetch"
     * }
     */
    public static MemorySegment VK_KHR_RAY_TRACING_POSITION_FETCH_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_RAY_TRACING_POSITION_FETCH_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_ray_tracing_position_fetch");
        }
        return Holder.VK_KHR_RAY_TRACING_POSITION_FETCH_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_COOPERATIVE_MATRIX_EXTENSION_NAME "VK_KHR_cooperative_matrix"
     * }
     */
    public static MemorySegment VK_KHR_COOPERATIVE_MATRIX_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_COOPERATIVE_MATRIX_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_cooperative_matrix");
        }
        return Holder.VK_KHR_COOPERATIVE_MATRIX_EXTENSION_NAME;
    }
    private static final int VK_STD_VULKAN_VIDEO_CODEC_AV1_DECODE_API_VERSION_1_0_0 = (int)4194304L;
    /**
     * {@snippet lang=c :
     * #define VK_STD_VULKAN_VIDEO_CODEC_AV1_DECODE_API_VERSION_1_0_0 4194304
     * }
     */
    public static int VK_STD_VULKAN_VIDEO_CODEC_AV1_DECODE_API_VERSION_1_0_0() {
        return VK_STD_VULKAN_VIDEO_CODEC_AV1_DECODE_API_VERSION_1_0_0;
    }
    private static final int VK_STD_VULKAN_VIDEO_CODEC_AV1_DECODE_SPEC_VERSION = (int)4194304L;
    /**
     * {@snippet lang=c :
     * #define VK_STD_VULKAN_VIDEO_CODEC_AV1_DECODE_SPEC_VERSION 4194304
     * }
     */
    public static int VK_STD_VULKAN_VIDEO_CODEC_AV1_DECODE_SPEC_VERSION() {
        return VK_STD_VULKAN_VIDEO_CODEC_AV1_DECODE_SPEC_VERSION;
    }
    /**
     * {@snippet lang=c :
     * #define VK_STD_VULKAN_VIDEO_CODEC_AV1_DECODE_EXTENSION_NAME "VK_STD_vulkan_video_codec_av1_decode"
     * }
     */
    public static MemorySegment VK_STD_VULKAN_VIDEO_CODEC_AV1_DECODE_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_STD_VULKAN_VIDEO_CODEC_AV1_DECODE_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_STD_vulkan_video_codec_av1_decode");
        }
        return Holder.VK_STD_VULKAN_VIDEO_CODEC_AV1_DECODE_EXTENSION_NAME;
    }
    private static final int VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR = (int)7L;
    /**
     * {@snippet lang=c :
     * #define VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR 7
     * }
     */
    public static int VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR() {
        return VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_VIDEO_DECODE_AV1_EXTENSION_NAME "VK_KHR_video_decode_av1"
     * }
     */
    public static MemorySegment VK_KHR_VIDEO_DECODE_AV1_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_VIDEO_DECODE_AV1_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_video_decode_av1");
        }
        return Holder.VK_KHR_VIDEO_DECODE_AV1_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_VIDEO_MAINTENANCE_1_EXTENSION_NAME "VK_KHR_video_maintenance1"
     * }
     */
    public static MemorySegment VK_KHR_VIDEO_MAINTENANCE_1_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_VIDEO_MAINTENANCE_1_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_video_maintenance1");
        }
        return Holder.VK_KHR_VIDEO_MAINTENANCE_1_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_VERTEX_ATTRIBUTE_DIVISOR_EXTENSION_NAME "VK_KHR_vertex_attribute_divisor"
     * }
     */
    public static MemorySegment VK_KHR_VERTEX_ATTRIBUTE_DIVISOR_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_VERTEX_ATTRIBUTE_DIVISOR_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_vertex_attribute_divisor");
        }
        return Holder.VK_KHR_VERTEX_ATTRIBUTE_DIVISOR_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_LOAD_STORE_OP_NONE_EXTENSION_NAME "VK_KHR_load_store_op_none"
     * }
     */
    public static MemorySegment VK_KHR_LOAD_STORE_OP_NONE_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_LOAD_STORE_OP_NONE_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_load_store_op_none");
        }
        return Holder.VK_KHR_LOAD_STORE_OP_NONE_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_SHADER_FLOAT_CONTROLS_2_EXTENSION_NAME "VK_KHR_shader_float_controls2"
     * }
     */
    public static MemorySegment VK_KHR_SHADER_FLOAT_CONTROLS_2_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_SHADER_FLOAT_CONTROLS_2_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_shader_float_controls2");
        }
        return Holder.VK_KHR_SHADER_FLOAT_CONTROLS_2_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_INDEX_TYPE_UINT8_EXTENSION_NAME "VK_KHR_index_type_uint8"
     * }
     */
    public static MemorySegment VK_KHR_INDEX_TYPE_UINT8_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_INDEX_TYPE_UINT8_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_index_type_uint8");
        }
        return Holder.VK_KHR_INDEX_TYPE_UINT8_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_LINE_RASTERIZATION_EXTENSION_NAME "VK_KHR_line_rasterization"
     * }
     */
    public static MemorySegment VK_KHR_LINE_RASTERIZATION_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_LINE_RASTERIZATION_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_line_rasterization");
        }
        return Holder.VK_KHR_LINE_RASTERIZATION_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_CALIBRATED_TIMESTAMPS_EXTENSION_NAME "VK_KHR_calibrated_timestamps"
     * }
     */
    public static MemorySegment VK_KHR_CALIBRATED_TIMESTAMPS_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_CALIBRATED_TIMESTAMPS_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_calibrated_timestamps");
        }
        return Holder.VK_KHR_CALIBRATED_TIMESTAMPS_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_SHADER_EXPECT_ASSUME_EXTENSION_NAME "VK_KHR_shader_expect_assume"
     * }
     */
    public static MemorySegment VK_KHR_SHADER_EXPECT_ASSUME_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_SHADER_EXPECT_ASSUME_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_shader_expect_assume");
        }
        return Holder.VK_KHR_SHADER_EXPECT_ASSUME_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_MAINTENANCE_6_EXTENSION_NAME "VK_KHR_maintenance6"
     * }
     */
    public static MemorySegment VK_KHR_MAINTENANCE_6_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_MAINTENANCE_6_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_maintenance6");
        }
        return Holder.VK_KHR_MAINTENANCE_6_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_DEBUG_REPORT_EXTENSION_NAME "VK_EXT_debug_report"
     * }
     */
    public static MemorySegment VK_EXT_DEBUG_REPORT_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_DEBUG_REPORT_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_debug_report");
        }
        return Holder.VK_EXT_DEBUG_REPORT_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_NV_GLSL_SHADER_EXTENSION_NAME "VK_NV_glsl_shader"
     * }
     */
    public static MemorySegment VK_NV_GLSL_SHADER_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_NV_GLSL_SHADER_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_NV_glsl_shader");
        }
        return Holder.VK_NV_GLSL_SHADER_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_DEPTH_RANGE_UNRESTRICTED_EXTENSION_NAME "VK_EXT_depth_range_unrestricted"
     * }
     */
    public static MemorySegment VK_EXT_DEPTH_RANGE_UNRESTRICTED_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_DEPTH_RANGE_UNRESTRICTED_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_depth_range_unrestricted");
        }
        return Holder.VK_EXT_DEPTH_RANGE_UNRESTRICTED_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_IMG_FILTER_CUBIC_EXTENSION_NAME "VK_IMG_filter_cubic"
     * }
     */
    public static MemorySegment VK_IMG_FILTER_CUBIC_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_IMG_FILTER_CUBIC_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_IMG_filter_cubic");
        }
        return Holder.VK_IMG_FILTER_CUBIC_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_AMD_RASTERIZATION_ORDER_EXTENSION_NAME "VK_AMD_rasterization_order"
     * }
     */
    public static MemorySegment VK_AMD_RASTERIZATION_ORDER_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_AMD_RASTERIZATION_ORDER_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_AMD_rasterization_order");
        }
        return Holder.VK_AMD_RASTERIZATION_ORDER_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_AMD_SHADER_TRINARY_MINMAX_EXTENSION_NAME "VK_AMD_shader_trinary_minmax"
     * }
     */
    public static MemorySegment VK_AMD_SHADER_TRINARY_MINMAX_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_AMD_SHADER_TRINARY_MINMAX_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_AMD_shader_trinary_minmax");
        }
        return Holder.VK_AMD_SHADER_TRINARY_MINMAX_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_EXTENSION_NAME "VK_AMD_shader_explicit_vertex_parameter"
     * }
     */
    public static MemorySegment VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_AMD_shader_explicit_vertex_parameter");
        }
        return Holder.VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_DEBUG_MARKER_EXTENSION_NAME "VK_EXT_debug_marker"
     * }
     */
    public static MemorySegment VK_EXT_DEBUG_MARKER_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_DEBUG_MARKER_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_debug_marker");
        }
        return Holder.VK_EXT_DEBUG_MARKER_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_AMD_GCN_SHADER_EXTENSION_NAME "VK_AMD_gcn_shader"
     * }
     */
    public static MemorySegment VK_AMD_GCN_SHADER_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_AMD_GCN_SHADER_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_AMD_gcn_shader");
        }
        return Holder.VK_AMD_GCN_SHADER_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_NV_DEDICATED_ALLOCATION_EXTENSION_NAME "VK_NV_dedicated_allocation"
     * }
     */
    public static MemorySegment VK_NV_DEDICATED_ALLOCATION_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_NV_DEDICATED_ALLOCATION_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_NV_dedicated_allocation");
        }
        return Holder.VK_NV_DEDICATED_ALLOCATION_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_TRANSFORM_FEEDBACK_EXTENSION_NAME "VK_EXT_transform_feedback"
     * }
     */
    public static MemorySegment VK_EXT_TRANSFORM_FEEDBACK_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_TRANSFORM_FEEDBACK_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_transform_feedback");
        }
        return Holder.VK_EXT_TRANSFORM_FEEDBACK_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_NVX_BINARY_IMPORT_EXTENSION_NAME "VK_NVX_binary_import"
     * }
     */
    public static MemorySegment VK_NVX_BINARY_IMPORT_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_NVX_BINARY_IMPORT_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_NVX_binary_import");
        }
        return Holder.VK_NVX_BINARY_IMPORT_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_NVX_IMAGE_VIEW_HANDLE_EXTENSION_NAME "VK_NVX_image_view_handle"
     * }
     */
    public static MemorySegment VK_NVX_IMAGE_VIEW_HANDLE_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_NVX_IMAGE_VIEW_HANDLE_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_NVX_image_view_handle");
        }
        return Holder.VK_NVX_IMAGE_VIEW_HANDLE_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_AMD_DRAW_INDIRECT_COUNT_EXTENSION_NAME "VK_AMD_draw_indirect_count"
     * }
     */
    public static MemorySegment VK_AMD_DRAW_INDIRECT_COUNT_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_AMD_DRAW_INDIRECT_COUNT_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_AMD_draw_indirect_count");
        }
        return Holder.VK_AMD_DRAW_INDIRECT_COUNT_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_AMD_NEGATIVE_VIEWPORT_HEIGHT_EXTENSION_NAME "VK_AMD_negative_viewport_height"
     * }
     */
    public static MemorySegment VK_AMD_NEGATIVE_VIEWPORT_HEIGHT_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_AMD_NEGATIVE_VIEWPORT_HEIGHT_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_AMD_negative_viewport_height");
        }
        return Holder.VK_AMD_NEGATIVE_VIEWPORT_HEIGHT_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_AMD_GPU_SHADER_HALF_FLOAT_EXTENSION_NAME "VK_AMD_gpu_shader_half_float"
     * }
     */
    public static MemorySegment VK_AMD_GPU_SHADER_HALF_FLOAT_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_AMD_GPU_SHADER_HALF_FLOAT_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_AMD_gpu_shader_half_float");
        }
        return Holder.VK_AMD_GPU_SHADER_HALF_FLOAT_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_AMD_SHADER_BALLOT_EXTENSION_NAME "VK_AMD_shader_ballot"
     * }
     */
    public static MemorySegment VK_AMD_SHADER_BALLOT_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_AMD_SHADER_BALLOT_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_AMD_shader_ballot");
        }
        return Holder.VK_AMD_SHADER_BALLOT_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_AMD_TEXTURE_GATHER_BIAS_LOD_EXTENSION_NAME "VK_AMD_texture_gather_bias_lod"
     * }
     */
    public static MemorySegment VK_AMD_TEXTURE_GATHER_BIAS_LOD_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_AMD_TEXTURE_GATHER_BIAS_LOD_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_AMD_texture_gather_bias_lod");
        }
        return Holder.VK_AMD_TEXTURE_GATHER_BIAS_LOD_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_AMD_SHADER_INFO_EXTENSION_NAME "VK_AMD_shader_info"
     * }
     */
    public static MemorySegment VK_AMD_SHADER_INFO_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_AMD_SHADER_INFO_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_AMD_shader_info");
        }
        return Holder.VK_AMD_SHADER_INFO_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_AMD_SHADER_IMAGE_LOAD_STORE_LOD_EXTENSION_NAME "VK_AMD_shader_image_load_store_lod"
     * }
     */
    public static MemorySegment VK_AMD_SHADER_IMAGE_LOAD_STORE_LOD_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_AMD_SHADER_IMAGE_LOAD_STORE_LOD_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_AMD_shader_image_load_store_lod");
        }
        return Holder.VK_AMD_SHADER_IMAGE_LOAD_STORE_LOD_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_NV_CORNER_SAMPLED_IMAGE_EXTENSION_NAME "VK_NV_corner_sampled_image"
     * }
     */
    public static MemorySegment VK_NV_CORNER_SAMPLED_IMAGE_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_NV_CORNER_SAMPLED_IMAGE_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_NV_corner_sampled_image");
        }
        return Holder.VK_NV_CORNER_SAMPLED_IMAGE_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_IMG_FORMAT_PVRTC_EXTENSION_NAME "VK_IMG_format_pvrtc"
     * }
     */
    public static MemorySegment VK_IMG_FORMAT_PVRTC_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_IMG_FORMAT_PVRTC_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_IMG_format_pvrtc");
        }
        return Holder.VK_IMG_FORMAT_PVRTC_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_NV_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME "VK_NV_external_memory_capabilities"
     * }
     */
    public static MemorySegment VK_NV_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_NV_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_NV_external_memory_capabilities");
        }
        return Holder.VK_NV_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_NV_EXTERNAL_MEMORY_EXTENSION_NAME "VK_NV_external_memory"
     * }
     */
    public static MemorySegment VK_NV_EXTERNAL_MEMORY_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_NV_EXTERNAL_MEMORY_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_NV_external_memory");
        }
        return Holder.VK_NV_EXTERNAL_MEMORY_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_VALIDATION_FLAGS_EXTENSION_NAME "VK_EXT_validation_flags"
     * }
     */
    public static MemorySegment VK_EXT_VALIDATION_FLAGS_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_VALIDATION_FLAGS_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_validation_flags");
        }
        return Holder.VK_EXT_VALIDATION_FLAGS_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_SHADER_SUBGROUP_BALLOT_EXTENSION_NAME "VK_EXT_shader_subgroup_ballot"
     * }
     */
    public static MemorySegment VK_EXT_SHADER_SUBGROUP_BALLOT_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_SHADER_SUBGROUP_BALLOT_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_shader_subgroup_ballot");
        }
        return Holder.VK_EXT_SHADER_SUBGROUP_BALLOT_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_SHADER_SUBGROUP_VOTE_EXTENSION_NAME "VK_EXT_shader_subgroup_vote"
     * }
     */
    public static MemorySegment VK_EXT_SHADER_SUBGROUP_VOTE_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_SHADER_SUBGROUP_VOTE_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_shader_subgroup_vote");
        }
        return Holder.VK_EXT_SHADER_SUBGROUP_VOTE_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_TEXTURE_COMPRESSION_ASTC_HDR_EXTENSION_NAME "VK_EXT_texture_compression_astc_hdr"
     * }
     */
    public static MemorySegment VK_EXT_TEXTURE_COMPRESSION_ASTC_HDR_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_TEXTURE_COMPRESSION_ASTC_HDR_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_texture_compression_astc_hdr");
        }
        return Holder.VK_EXT_TEXTURE_COMPRESSION_ASTC_HDR_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_ASTC_DECODE_MODE_EXTENSION_NAME "VK_EXT_astc_decode_mode"
     * }
     */
    public static MemorySegment VK_EXT_ASTC_DECODE_MODE_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_ASTC_DECODE_MODE_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_astc_decode_mode");
        }
        return Holder.VK_EXT_ASTC_DECODE_MODE_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_PIPELINE_ROBUSTNESS_EXTENSION_NAME "VK_EXT_pipeline_robustness"
     * }
     */
    public static MemorySegment VK_EXT_PIPELINE_ROBUSTNESS_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_PIPELINE_ROBUSTNESS_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_pipeline_robustness");
        }
        return Holder.VK_EXT_PIPELINE_ROBUSTNESS_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_CONDITIONAL_RENDERING_EXTENSION_NAME "VK_EXT_conditional_rendering"
     * }
     */
    public static MemorySegment VK_EXT_CONDITIONAL_RENDERING_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_CONDITIONAL_RENDERING_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_conditional_rendering");
        }
        return Holder.VK_EXT_CONDITIONAL_RENDERING_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_NV_CLIP_SPACE_W_SCALING_EXTENSION_NAME "VK_NV_clip_space_w_scaling"
     * }
     */
    public static MemorySegment VK_NV_CLIP_SPACE_W_SCALING_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_NV_CLIP_SPACE_W_SCALING_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_NV_clip_space_w_scaling");
        }
        return Holder.VK_NV_CLIP_SPACE_W_SCALING_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_DIRECT_MODE_DISPLAY_EXTENSION_NAME "VK_EXT_direct_mode_display"
     * }
     */
    public static MemorySegment VK_EXT_DIRECT_MODE_DISPLAY_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_DIRECT_MODE_DISPLAY_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_direct_mode_display");
        }
        return Holder.VK_EXT_DIRECT_MODE_DISPLAY_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_DISPLAY_SURFACE_COUNTER_EXTENSION_NAME "VK_EXT_display_surface_counter"
     * }
     */
    public static MemorySegment VK_EXT_DISPLAY_SURFACE_COUNTER_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_DISPLAY_SURFACE_COUNTER_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_display_surface_counter");
        }
        return Holder.VK_EXT_DISPLAY_SURFACE_COUNTER_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_DISPLAY_CONTROL_EXTENSION_NAME "VK_EXT_display_control"
     * }
     */
    public static MemorySegment VK_EXT_DISPLAY_CONTROL_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_DISPLAY_CONTROL_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_display_control");
        }
        return Holder.VK_EXT_DISPLAY_CONTROL_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_GOOGLE_DISPLAY_TIMING_EXTENSION_NAME "VK_GOOGLE_display_timing"
     * }
     */
    public static MemorySegment VK_GOOGLE_DISPLAY_TIMING_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_GOOGLE_DISPLAY_TIMING_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_GOOGLE_display_timing");
        }
        return Holder.VK_GOOGLE_DISPLAY_TIMING_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_NV_SAMPLE_MASK_OVERRIDE_COVERAGE_EXTENSION_NAME "VK_NV_sample_mask_override_coverage"
     * }
     */
    public static MemorySegment VK_NV_SAMPLE_MASK_OVERRIDE_COVERAGE_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_NV_SAMPLE_MASK_OVERRIDE_COVERAGE_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_NV_sample_mask_override_coverage");
        }
        return Holder.VK_NV_SAMPLE_MASK_OVERRIDE_COVERAGE_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_NV_GEOMETRY_SHADER_PASSTHROUGH_EXTENSION_NAME "VK_NV_geometry_shader_passthrough"
     * }
     */
    public static MemorySegment VK_NV_GEOMETRY_SHADER_PASSTHROUGH_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_NV_GEOMETRY_SHADER_PASSTHROUGH_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_NV_geometry_shader_passthrough");
        }
        return Holder.VK_NV_GEOMETRY_SHADER_PASSTHROUGH_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_NV_VIEWPORT_ARRAY_2_EXTENSION_NAME "VK_NV_viewport_array2"
     * }
     */
    public static MemorySegment VK_NV_VIEWPORT_ARRAY_2_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_NV_VIEWPORT_ARRAY_2_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_NV_viewport_array2");
        }
        return Holder.VK_NV_VIEWPORT_ARRAY_2_EXTENSION_NAME;
    }
    private static final int VK_NV_VIEWPORT_ARRAY2_SPEC_VERSION = (int)1L;
    /**
     * {@snippet lang=c :
     * #define VK_NV_VIEWPORT_ARRAY2_SPEC_VERSION 1
     * }
     */
    public static int VK_NV_VIEWPORT_ARRAY2_SPEC_VERSION() {
        return VK_NV_VIEWPORT_ARRAY2_SPEC_VERSION;
    }
    /**
     * {@snippet lang=c :
     * #define VK_NV_VIEWPORT_ARRAY2_EXTENSION_NAME "VK_NV_viewport_array2"
     * }
     */
    public static MemorySegment VK_NV_VIEWPORT_ARRAY2_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_NV_VIEWPORT_ARRAY2_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_NV_viewport_array2");
        }
        return Holder.VK_NV_VIEWPORT_ARRAY2_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_EXTENSION_NAME "VK_NVX_multiview_per_view_attributes"
     * }
     */
    public static MemorySegment VK_NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_NVX_multiview_per_view_attributes");
        }
        return Holder.VK_NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_NV_VIEWPORT_SWIZZLE_EXTENSION_NAME "VK_NV_viewport_swizzle"
     * }
     */
    public static MemorySegment VK_NV_VIEWPORT_SWIZZLE_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_NV_VIEWPORT_SWIZZLE_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_NV_viewport_swizzle");
        }
        return Holder.VK_NV_VIEWPORT_SWIZZLE_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_DISCARD_RECTANGLES_EXTENSION_NAME "VK_EXT_discard_rectangles"
     * }
     */
    public static MemorySegment VK_EXT_DISCARD_RECTANGLES_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_DISCARD_RECTANGLES_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_discard_rectangles");
        }
        return Holder.VK_EXT_DISCARD_RECTANGLES_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_CONSERVATIVE_RASTERIZATION_EXTENSION_NAME "VK_EXT_conservative_rasterization"
     * }
     */
    public static MemorySegment VK_EXT_CONSERVATIVE_RASTERIZATION_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_CONSERVATIVE_RASTERIZATION_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_conservative_rasterization");
        }
        return Holder.VK_EXT_CONSERVATIVE_RASTERIZATION_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_DEPTH_CLIP_ENABLE_EXTENSION_NAME "VK_EXT_depth_clip_enable"
     * }
     */
    public static MemorySegment VK_EXT_DEPTH_CLIP_ENABLE_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_DEPTH_CLIP_ENABLE_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_depth_clip_enable");
        }
        return Holder.VK_EXT_DEPTH_CLIP_ENABLE_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_SWAPCHAIN_COLOR_SPACE_EXTENSION_NAME "VK_EXT_swapchain_colorspace"
     * }
     */
    public static MemorySegment VK_EXT_SWAPCHAIN_COLOR_SPACE_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_SWAPCHAIN_COLOR_SPACE_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_swapchain_colorspace");
        }
        return Holder.VK_EXT_SWAPCHAIN_COLOR_SPACE_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_HDR_METADATA_EXTENSION_NAME "VK_EXT_hdr_metadata"
     * }
     */
    public static MemorySegment VK_EXT_HDR_METADATA_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_HDR_METADATA_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_hdr_metadata");
        }
        return Holder.VK_EXT_HDR_METADATA_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_IMG_RELAXED_LINE_RASTERIZATION_EXTENSION_NAME "VK_IMG_relaxed_line_rasterization"
     * }
     */
    public static MemorySegment VK_IMG_RELAXED_LINE_RASTERIZATION_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_IMG_RELAXED_LINE_RASTERIZATION_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_IMG_relaxed_line_rasterization");
        }
        return Holder.VK_IMG_RELAXED_LINE_RASTERIZATION_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_EXTERNAL_MEMORY_DMA_BUF_EXTENSION_NAME "VK_EXT_external_memory_dma_buf"
     * }
     */
    public static MemorySegment VK_EXT_EXTERNAL_MEMORY_DMA_BUF_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_EXTERNAL_MEMORY_DMA_BUF_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_external_memory_dma_buf");
        }
        return Holder.VK_EXT_EXTERNAL_MEMORY_DMA_BUF_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_QUEUE_FAMILY_FOREIGN_EXTENSION_NAME "VK_EXT_queue_family_foreign"
     * }
     */
    public static MemorySegment VK_EXT_QUEUE_FAMILY_FOREIGN_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_QUEUE_FAMILY_FOREIGN_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_queue_family_foreign");
        }
        return Holder.VK_EXT_QUEUE_FAMILY_FOREIGN_EXTENSION_NAME;
    }
    private static final int VK_QUEUE_FAMILY_FOREIGN_EXT = (int)4294967293L;
    /**
     * {@snippet lang=c :
     * #define VK_QUEUE_FAMILY_FOREIGN_EXT 4294967293
     * }
     */
    public static int VK_QUEUE_FAMILY_FOREIGN_EXT() {
        return VK_QUEUE_FAMILY_FOREIGN_EXT;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_DEBUG_UTILS_EXTENSION_NAME "VK_EXT_debug_utils"
     * }
     */
    public static MemorySegment VK_EXT_DEBUG_UTILS_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_DEBUG_UTILS_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_debug_utils");
        }
        return Holder.VK_EXT_DEBUG_UTILS_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_SAMPLER_FILTER_MINMAX_EXTENSION_NAME "VK_EXT_sampler_filter_minmax"
     * }
     */
    public static MemorySegment VK_EXT_SAMPLER_FILTER_MINMAX_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_SAMPLER_FILTER_MINMAX_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_sampler_filter_minmax");
        }
        return Holder.VK_EXT_SAMPLER_FILTER_MINMAX_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_AMD_GPU_SHADER_INT16_EXTENSION_NAME "VK_AMD_gpu_shader_int16"
     * }
     */
    public static MemorySegment VK_AMD_GPU_SHADER_INT16_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_AMD_GPU_SHADER_INT16_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_AMD_gpu_shader_int16");
        }
        return Holder.VK_AMD_GPU_SHADER_INT16_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_AMD_MIXED_ATTACHMENT_SAMPLES_EXTENSION_NAME "VK_AMD_mixed_attachment_samples"
     * }
     */
    public static MemorySegment VK_AMD_MIXED_ATTACHMENT_SAMPLES_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_AMD_MIXED_ATTACHMENT_SAMPLES_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_AMD_mixed_attachment_samples");
        }
        return Holder.VK_AMD_MIXED_ATTACHMENT_SAMPLES_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_AMD_SHADER_FRAGMENT_MASK_EXTENSION_NAME "VK_AMD_shader_fragment_mask"
     * }
     */
    public static MemorySegment VK_AMD_SHADER_FRAGMENT_MASK_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_AMD_SHADER_FRAGMENT_MASK_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_AMD_shader_fragment_mask");
        }
        return Holder.VK_AMD_SHADER_FRAGMENT_MASK_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_INLINE_UNIFORM_BLOCK_EXTENSION_NAME "VK_EXT_inline_uniform_block"
     * }
     */
    public static MemorySegment VK_EXT_INLINE_UNIFORM_BLOCK_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_INLINE_UNIFORM_BLOCK_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_inline_uniform_block");
        }
        return Holder.VK_EXT_INLINE_UNIFORM_BLOCK_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_SHADER_STENCIL_EXPORT_EXTENSION_NAME "VK_EXT_shader_stencil_export"
     * }
     */
    public static MemorySegment VK_EXT_SHADER_STENCIL_EXPORT_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_SHADER_STENCIL_EXPORT_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_shader_stencil_export");
        }
        return Holder.VK_EXT_SHADER_STENCIL_EXPORT_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_SAMPLE_LOCATIONS_EXTENSION_NAME "VK_EXT_sample_locations"
     * }
     */
    public static MemorySegment VK_EXT_SAMPLE_LOCATIONS_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_SAMPLE_LOCATIONS_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_sample_locations");
        }
        return Holder.VK_EXT_SAMPLE_LOCATIONS_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_BLEND_OPERATION_ADVANCED_EXTENSION_NAME "VK_EXT_blend_operation_advanced"
     * }
     */
    public static MemorySegment VK_EXT_BLEND_OPERATION_ADVANCED_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_BLEND_OPERATION_ADVANCED_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_blend_operation_advanced");
        }
        return Holder.VK_EXT_BLEND_OPERATION_ADVANCED_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_NV_FRAGMENT_COVERAGE_TO_COLOR_EXTENSION_NAME "VK_NV_fragment_coverage_to_color"
     * }
     */
    public static MemorySegment VK_NV_FRAGMENT_COVERAGE_TO_COLOR_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_NV_FRAGMENT_COVERAGE_TO_COLOR_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_NV_fragment_coverage_to_color");
        }
        return Holder.VK_NV_FRAGMENT_COVERAGE_TO_COLOR_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_NV_FRAMEBUFFER_MIXED_SAMPLES_EXTENSION_NAME "VK_NV_framebuffer_mixed_samples"
     * }
     */
    public static MemorySegment VK_NV_FRAMEBUFFER_MIXED_SAMPLES_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_NV_FRAMEBUFFER_MIXED_SAMPLES_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_NV_framebuffer_mixed_samples");
        }
        return Holder.VK_NV_FRAMEBUFFER_MIXED_SAMPLES_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_NV_FILL_RECTANGLE_EXTENSION_NAME "VK_NV_fill_rectangle"
     * }
     */
    public static MemorySegment VK_NV_FILL_RECTANGLE_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_NV_FILL_RECTANGLE_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_NV_fill_rectangle");
        }
        return Holder.VK_NV_FILL_RECTANGLE_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_NV_SHADER_SM_BUILTINS_EXTENSION_NAME "VK_NV_shader_sm_builtins"
     * }
     */
    public static MemorySegment VK_NV_SHADER_SM_BUILTINS_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_NV_SHADER_SM_BUILTINS_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_NV_shader_sm_builtins");
        }
        return Holder.VK_NV_SHADER_SM_BUILTINS_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_POST_DEPTH_COVERAGE_EXTENSION_NAME "VK_EXT_post_depth_coverage"
     * }
     */
    public static MemorySegment VK_EXT_POST_DEPTH_COVERAGE_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_POST_DEPTH_COVERAGE_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_post_depth_coverage");
        }
        return Holder.VK_EXT_POST_DEPTH_COVERAGE_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_IMAGE_DRM_FORMAT_MODIFIER_EXTENSION_NAME "VK_EXT_image_drm_format_modifier"
     * }
     */
    public static MemorySegment VK_EXT_IMAGE_DRM_FORMAT_MODIFIER_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_IMAGE_DRM_FORMAT_MODIFIER_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_image_drm_format_modifier");
        }
        return Holder.VK_EXT_IMAGE_DRM_FORMAT_MODIFIER_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_VALIDATION_CACHE_EXTENSION_NAME "VK_EXT_validation_cache"
     * }
     */
    public static MemorySegment VK_EXT_VALIDATION_CACHE_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_VALIDATION_CACHE_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_validation_cache");
        }
        return Holder.VK_EXT_VALIDATION_CACHE_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME "VK_EXT_descriptor_indexing"
     * }
     */
    public static MemorySegment VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_descriptor_indexing");
        }
        return Holder.VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_SHADER_VIEWPORT_INDEX_LAYER_EXTENSION_NAME "VK_EXT_shader_viewport_index_layer"
     * }
     */
    public static MemorySegment VK_EXT_SHADER_VIEWPORT_INDEX_LAYER_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_SHADER_VIEWPORT_INDEX_LAYER_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_shader_viewport_index_layer");
        }
        return Holder.VK_EXT_SHADER_VIEWPORT_INDEX_LAYER_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_NV_SHADING_RATE_IMAGE_EXTENSION_NAME "VK_NV_shading_rate_image"
     * }
     */
    public static MemorySegment VK_NV_SHADING_RATE_IMAGE_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_NV_SHADING_RATE_IMAGE_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_NV_shading_rate_image");
        }
        return Holder.VK_NV_SHADING_RATE_IMAGE_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_NV_RAY_TRACING_EXTENSION_NAME "VK_NV_ray_tracing"
     * }
     */
    public static MemorySegment VK_NV_RAY_TRACING_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_NV_RAY_TRACING_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_NV_ray_tracing");
        }
        return Holder.VK_NV_RAY_TRACING_EXTENSION_NAME;
    }
    private static final int VK_SHADER_UNUSED_KHR = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define VK_SHADER_UNUSED_KHR 4294967295
     * }
     */
    public static int VK_SHADER_UNUSED_KHR() {
        return VK_SHADER_UNUSED_KHR;
    }
    private static final int VK_SHADER_UNUSED_NV = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define VK_SHADER_UNUSED_NV 4294967295
     * }
     */
    public static int VK_SHADER_UNUSED_NV() {
        return VK_SHADER_UNUSED_NV;
    }
    /**
     * {@snippet lang=c :
     * #define VK_NV_REPRESENTATIVE_FRAGMENT_TEST_EXTENSION_NAME "VK_NV_representative_fragment_test"
     * }
     */
    public static MemorySegment VK_NV_REPRESENTATIVE_FRAGMENT_TEST_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_NV_REPRESENTATIVE_FRAGMENT_TEST_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_NV_representative_fragment_test");
        }
        return Holder.VK_NV_REPRESENTATIVE_FRAGMENT_TEST_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_FILTER_CUBIC_EXTENSION_NAME "VK_EXT_filter_cubic"
     * }
     */
    public static MemorySegment VK_EXT_FILTER_CUBIC_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_FILTER_CUBIC_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_filter_cubic");
        }
        return Holder.VK_EXT_FILTER_CUBIC_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_QCOM_RENDER_PASS_SHADER_RESOLVE_EXTENSION_NAME "VK_QCOM_render_pass_shader_resolve"
     * }
     */
    public static MemorySegment VK_QCOM_RENDER_PASS_SHADER_RESOLVE_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_QCOM_RENDER_PASS_SHADER_RESOLVE_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_QCOM_render_pass_shader_resolve");
        }
        return Holder.VK_QCOM_RENDER_PASS_SHADER_RESOLVE_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_GLOBAL_PRIORITY_EXTENSION_NAME "VK_EXT_global_priority"
     * }
     */
    public static MemorySegment VK_EXT_GLOBAL_PRIORITY_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_GLOBAL_PRIORITY_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_global_priority");
        }
        return Holder.VK_EXT_GLOBAL_PRIORITY_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_EXTERNAL_MEMORY_HOST_EXTENSION_NAME "VK_EXT_external_memory_host"
     * }
     */
    public static MemorySegment VK_EXT_EXTERNAL_MEMORY_HOST_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_EXTERNAL_MEMORY_HOST_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_external_memory_host");
        }
        return Holder.VK_EXT_EXTERNAL_MEMORY_HOST_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_AMD_BUFFER_MARKER_EXTENSION_NAME "VK_AMD_buffer_marker"
     * }
     */
    public static MemorySegment VK_AMD_BUFFER_MARKER_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_AMD_BUFFER_MARKER_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_AMD_buffer_marker");
        }
        return Holder.VK_AMD_BUFFER_MARKER_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_AMD_PIPELINE_COMPILER_CONTROL_EXTENSION_NAME "VK_AMD_pipeline_compiler_control"
     * }
     */
    public static MemorySegment VK_AMD_PIPELINE_COMPILER_CONTROL_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_AMD_PIPELINE_COMPILER_CONTROL_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_AMD_pipeline_compiler_control");
        }
        return Holder.VK_AMD_PIPELINE_COMPILER_CONTROL_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_CALIBRATED_TIMESTAMPS_EXTENSION_NAME "VK_EXT_calibrated_timestamps"
     * }
     */
    public static MemorySegment VK_EXT_CALIBRATED_TIMESTAMPS_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_CALIBRATED_TIMESTAMPS_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_calibrated_timestamps");
        }
        return Holder.VK_EXT_CALIBRATED_TIMESTAMPS_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_AMD_SHADER_CORE_PROPERTIES_EXTENSION_NAME "VK_AMD_shader_core_properties"
     * }
     */
    public static MemorySegment VK_AMD_SHADER_CORE_PROPERTIES_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_AMD_SHADER_CORE_PROPERTIES_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_AMD_shader_core_properties");
        }
        return Holder.VK_AMD_SHADER_CORE_PROPERTIES_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_AMD_MEMORY_OVERALLOCATION_BEHAVIOR_EXTENSION_NAME "VK_AMD_memory_overallocation_behavior"
     * }
     */
    public static MemorySegment VK_AMD_MEMORY_OVERALLOCATION_BEHAVIOR_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_AMD_MEMORY_OVERALLOCATION_BEHAVIOR_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_AMD_memory_overallocation_behavior");
        }
        return Holder.VK_AMD_MEMORY_OVERALLOCATION_BEHAVIOR_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_VERTEX_ATTRIBUTE_DIVISOR_EXTENSION_NAME "VK_EXT_vertex_attribute_divisor"
     * }
     */
    public static MemorySegment VK_EXT_VERTEX_ATTRIBUTE_DIVISOR_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_VERTEX_ATTRIBUTE_DIVISOR_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_vertex_attribute_divisor");
        }
        return Holder.VK_EXT_VERTEX_ATTRIBUTE_DIVISOR_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_PIPELINE_CREATION_FEEDBACK_EXTENSION_NAME "VK_EXT_pipeline_creation_feedback"
     * }
     */
    public static MemorySegment VK_EXT_PIPELINE_CREATION_FEEDBACK_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_PIPELINE_CREATION_FEEDBACK_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_pipeline_creation_feedback");
        }
        return Holder.VK_EXT_PIPELINE_CREATION_FEEDBACK_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_NV_SHADER_SUBGROUP_PARTITIONED_EXTENSION_NAME "VK_NV_shader_subgroup_partitioned"
     * }
     */
    public static MemorySegment VK_NV_SHADER_SUBGROUP_PARTITIONED_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_NV_SHADER_SUBGROUP_PARTITIONED_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_NV_shader_subgroup_partitioned");
        }
        return Holder.VK_NV_SHADER_SUBGROUP_PARTITIONED_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_NV_COMPUTE_SHADER_DERIVATIVES_EXTENSION_NAME "VK_NV_compute_shader_derivatives"
     * }
     */
    public static MemorySegment VK_NV_COMPUTE_SHADER_DERIVATIVES_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_NV_COMPUTE_SHADER_DERIVATIVES_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_NV_compute_shader_derivatives");
        }
        return Holder.VK_NV_COMPUTE_SHADER_DERIVATIVES_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_NV_MESH_SHADER_EXTENSION_NAME "VK_NV_mesh_shader"
     * }
     */
    public static MemorySegment VK_NV_MESH_SHADER_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_NV_MESH_SHADER_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_NV_mesh_shader");
        }
        return Holder.VK_NV_MESH_SHADER_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_NV_FRAGMENT_SHADER_BARYCENTRIC_EXTENSION_NAME "VK_NV_fragment_shader_barycentric"
     * }
     */
    public static MemorySegment VK_NV_FRAGMENT_SHADER_BARYCENTRIC_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_NV_FRAGMENT_SHADER_BARYCENTRIC_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_NV_fragment_shader_barycentric");
        }
        return Holder.VK_NV_FRAGMENT_SHADER_BARYCENTRIC_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_NV_SHADER_IMAGE_FOOTPRINT_EXTENSION_NAME "VK_NV_shader_image_footprint"
     * }
     */
    public static MemorySegment VK_NV_SHADER_IMAGE_FOOTPRINT_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_NV_SHADER_IMAGE_FOOTPRINT_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_NV_shader_image_footprint");
        }
        return Holder.VK_NV_SHADER_IMAGE_FOOTPRINT_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_NV_SCISSOR_EXCLUSIVE_EXTENSION_NAME "VK_NV_scissor_exclusive"
     * }
     */
    public static MemorySegment VK_NV_SCISSOR_EXCLUSIVE_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_NV_SCISSOR_EXCLUSIVE_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_NV_scissor_exclusive");
        }
        return Holder.VK_NV_SCISSOR_EXCLUSIVE_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_NV_DEVICE_DIAGNOSTIC_CHECKPOINTS_EXTENSION_NAME "VK_NV_device_diagnostic_checkpoints"
     * }
     */
    public static MemorySegment VK_NV_DEVICE_DIAGNOSTIC_CHECKPOINTS_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_NV_DEVICE_DIAGNOSTIC_CHECKPOINTS_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_NV_device_diagnostic_checkpoints");
        }
        return Holder.VK_NV_DEVICE_DIAGNOSTIC_CHECKPOINTS_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_INTEL_SHADER_INTEGER_FUNCTIONS_2_EXTENSION_NAME "VK_INTEL_shader_integer_functions2"
     * }
     */
    public static MemorySegment VK_INTEL_SHADER_INTEGER_FUNCTIONS_2_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_INTEL_SHADER_INTEGER_FUNCTIONS_2_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_INTEL_shader_integer_functions2");
        }
        return Holder.VK_INTEL_SHADER_INTEGER_FUNCTIONS_2_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_INTEL_PERFORMANCE_QUERY_EXTENSION_NAME "VK_INTEL_performance_query"
     * }
     */
    public static MemorySegment VK_INTEL_PERFORMANCE_QUERY_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_INTEL_PERFORMANCE_QUERY_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_INTEL_performance_query");
        }
        return Holder.VK_INTEL_PERFORMANCE_QUERY_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_PCI_BUS_INFO_EXTENSION_NAME "VK_EXT_pci_bus_info"
     * }
     */
    public static MemorySegment VK_EXT_PCI_BUS_INFO_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_PCI_BUS_INFO_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_pci_bus_info");
        }
        return Holder.VK_EXT_PCI_BUS_INFO_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_AMD_DISPLAY_NATIVE_HDR_EXTENSION_NAME "VK_AMD_display_native_hdr"
     * }
     */
    public static MemorySegment VK_AMD_DISPLAY_NATIVE_HDR_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_AMD_DISPLAY_NATIVE_HDR_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_AMD_display_native_hdr");
        }
        return Holder.VK_AMD_DISPLAY_NATIVE_HDR_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_FRAGMENT_DENSITY_MAP_EXTENSION_NAME "VK_EXT_fragment_density_map"
     * }
     */
    public static MemorySegment VK_EXT_FRAGMENT_DENSITY_MAP_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_FRAGMENT_DENSITY_MAP_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_fragment_density_map");
        }
        return Holder.VK_EXT_FRAGMENT_DENSITY_MAP_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_SCALAR_BLOCK_LAYOUT_EXTENSION_NAME "VK_EXT_scalar_block_layout"
     * }
     */
    public static MemorySegment VK_EXT_SCALAR_BLOCK_LAYOUT_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_SCALAR_BLOCK_LAYOUT_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_scalar_block_layout");
        }
        return Holder.VK_EXT_SCALAR_BLOCK_LAYOUT_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_GOOGLE_HLSL_FUNCTIONALITY_1_EXTENSION_NAME "VK_GOOGLE_hlsl_functionality1"
     * }
     */
    public static MemorySegment VK_GOOGLE_HLSL_FUNCTIONALITY_1_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_GOOGLE_HLSL_FUNCTIONALITY_1_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_GOOGLE_hlsl_functionality1");
        }
        return Holder.VK_GOOGLE_HLSL_FUNCTIONALITY_1_EXTENSION_NAME;
    }
    private static final int VK_GOOGLE_HLSL_FUNCTIONALITY1_SPEC_VERSION = (int)1L;
    /**
     * {@snippet lang=c :
     * #define VK_GOOGLE_HLSL_FUNCTIONALITY1_SPEC_VERSION 1
     * }
     */
    public static int VK_GOOGLE_HLSL_FUNCTIONALITY1_SPEC_VERSION() {
        return VK_GOOGLE_HLSL_FUNCTIONALITY1_SPEC_VERSION;
    }
    /**
     * {@snippet lang=c :
     * #define VK_GOOGLE_HLSL_FUNCTIONALITY1_EXTENSION_NAME "VK_GOOGLE_hlsl_functionality1"
     * }
     */
    public static MemorySegment VK_GOOGLE_HLSL_FUNCTIONALITY1_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_GOOGLE_HLSL_FUNCTIONALITY1_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_GOOGLE_hlsl_functionality1");
        }
        return Holder.VK_GOOGLE_HLSL_FUNCTIONALITY1_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_GOOGLE_DECORATE_STRING_EXTENSION_NAME "VK_GOOGLE_decorate_string"
     * }
     */
    public static MemorySegment VK_GOOGLE_DECORATE_STRING_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_GOOGLE_DECORATE_STRING_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_GOOGLE_decorate_string");
        }
        return Holder.VK_GOOGLE_DECORATE_STRING_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_SUBGROUP_SIZE_CONTROL_EXTENSION_NAME "VK_EXT_subgroup_size_control"
     * }
     */
    public static MemorySegment VK_EXT_SUBGROUP_SIZE_CONTROL_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_SUBGROUP_SIZE_CONTROL_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_subgroup_size_control");
        }
        return Holder.VK_EXT_SUBGROUP_SIZE_CONTROL_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_AMD_SHADER_CORE_PROPERTIES_2_EXTENSION_NAME "VK_AMD_shader_core_properties2"
     * }
     */
    public static MemorySegment VK_AMD_SHADER_CORE_PROPERTIES_2_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_AMD_SHADER_CORE_PROPERTIES_2_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_AMD_shader_core_properties2");
        }
        return Holder.VK_AMD_SHADER_CORE_PROPERTIES_2_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_AMD_DEVICE_COHERENT_MEMORY_EXTENSION_NAME "VK_AMD_device_coherent_memory"
     * }
     */
    public static MemorySegment VK_AMD_DEVICE_COHERENT_MEMORY_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_AMD_DEVICE_COHERENT_MEMORY_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_AMD_device_coherent_memory");
        }
        return Holder.VK_AMD_DEVICE_COHERENT_MEMORY_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_SHADER_IMAGE_ATOMIC_INT64_EXTENSION_NAME "VK_EXT_shader_image_atomic_int64"
     * }
     */
    public static MemorySegment VK_EXT_SHADER_IMAGE_ATOMIC_INT64_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_SHADER_IMAGE_ATOMIC_INT64_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_shader_image_atomic_int64");
        }
        return Holder.VK_EXT_SHADER_IMAGE_ATOMIC_INT64_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_MEMORY_BUDGET_EXTENSION_NAME "VK_EXT_memory_budget"
     * }
     */
    public static MemorySegment VK_EXT_MEMORY_BUDGET_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_MEMORY_BUDGET_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_memory_budget");
        }
        return Holder.VK_EXT_MEMORY_BUDGET_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_MEMORY_PRIORITY_EXTENSION_NAME "VK_EXT_memory_priority"
     * }
     */
    public static MemorySegment VK_EXT_MEMORY_PRIORITY_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_MEMORY_PRIORITY_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_memory_priority");
        }
        return Holder.VK_EXT_MEMORY_PRIORITY_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_NV_DEDICATED_ALLOCATION_IMAGE_ALIASING_EXTENSION_NAME "VK_NV_dedicated_allocation_image_aliasing"
     * }
     */
    public static MemorySegment VK_NV_DEDICATED_ALLOCATION_IMAGE_ALIASING_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_NV_DEDICATED_ALLOCATION_IMAGE_ALIASING_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_NV_dedicated_allocation_image_aliasing");
        }
        return Holder.VK_NV_DEDICATED_ALLOCATION_IMAGE_ALIASING_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME "VK_EXT_buffer_device_address"
     * }
     */
    public static MemorySegment VK_EXT_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_buffer_device_address");
        }
        return Holder.VK_EXT_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_TOOLING_INFO_EXTENSION_NAME "VK_EXT_tooling_info"
     * }
     */
    public static MemorySegment VK_EXT_TOOLING_INFO_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_TOOLING_INFO_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_tooling_info");
        }
        return Holder.VK_EXT_TOOLING_INFO_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_SEPARATE_STENCIL_USAGE_EXTENSION_NAME "VK_EXT_separate_stencil_usage"
     * }
     */
    public static MemorySegment VK_EXT_SEPARATE_STENCIL_USAGE_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_SEPARATE_STENCIL_USAGE_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_separate_stencil_usage");
        }
        return Holder.VK_EXT_SEPARATE_STENCIL_USAGE_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_VALIDATION_FEATURES_EXTENSION_NAME "VK_EXT_validation_features"
     * }
     */
    public static MemorySegment VK_EXT_VALIDATION_FEATURES_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_VALIDATION_FEATURES_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_validation_features");
        }
        return Holder.VK_EXT_VALIDATION_FEATURES_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_NV_COOPERATIVE_MATRIX_EXTENSION_NAME "VK_NV_cooperative_matrix"
     * }
     */
    public static MemorySegment VK_NV_COOPERATIVE_MATRIX_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_NV_COOPERATIVE_MATRIX_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_NV_cooperative_matrix");
        }
        return Holder.VK_NV_COOPERATIVE_MATRIX_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_NV_COVERAGE_REDUCTION_MODE_EXTENSION_NAME "VK_NV_coverage_reduction_mode"
     * }
     */
    public static MemorySegment VK_NV_COVERAGE_REDUCTION_MODE_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_NV_COVERAGE_REDUCTION_MODE_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_NV_coverage_reduction_mode");
        }
        return Holder.VK_NV_COVERAGE_REDUCTION_MODE_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_FRAGMENT_SHADER_INTERLOCK_EXTENSION_NAME "VK_EXT_fragment_shader_interlock"
     * }
     */
    public static MemorySegment VK_EXT_FRAGMENT_SHADER_INTERLOCK_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_FRAGMENT_SHADER_INTERLOCK_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_fragment_shader_interlock");
        }
        return Holder.VK_EXT_FRAGMENT_SHADER_INTERLOCK_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_YCBCR_IMAGE_ARRAYS_EXTENSION_NAME "VK_EXT_ycbcr_image_arrays"
     * }
     */
    public static MemorySegment VK_EXT_YCBCR_IMAGE_ARRAYS_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_YCBCR_IMAGE_ARRAYS_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_ycbcr_image_arrays");
        }
        return Holder.VK_EXT_YCBCR_IMAGE_ARRAYS_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_PROVOKING_VERTEX_EXTENSION_NAME "VK_EXT_provoking_vertex"
     * }
     */
    public static MemorySegment VK_EXT_PROVOKING_VERTEX_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_PROVOKING_VERTEX_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_provoking_vertex");
        }
        return Holder.VK_EXT_PROVOKING_VERTEX_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_HEADLESS_SURFACE_EXTENSION_NAME "VK_EXT_headless_surface"
     * }
     */
    public static MemorySegment VK_EXT_HEADLESS_SURFACE_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_HEADLESS_SURFACE_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_headless_surface");
        }
        return Holder.VK_EXT_HEADLESS_SURFACE_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_LINE_RASTERIZATION_EXTENSION_NAME "VK_EXT_line_rasterization"
     * }
     */
    public static MemorySegment VK_EXT_LINE_RASTERIZATION_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_LINE_RASTERIZATION_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_line_rasterization");
        }
        return Holder.VK_EXT_LINE_RASTERIZATION_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_SHADER_ATOMIC_FLOAT_EXTENSION_NAME "VK_EXT_shader_atomic_float"
     * }
     */
    public static MemorySegment VK_EXT_SHADER_ATOMIC_FLOAT_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_SHADER_ATOMIC_FLOAT_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_shader_atomic_float");
        }
        return Holder.VK_EXT_SHADER_ATOMIC_FLOAT_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_HOST_QUERY_RESET_EXTENSION_NAME "VK_EXT_host_query_reset"
     * }
     */
    public static MemorySegment VK_EXT_HOST_QUERY_RESET_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_HOST_QUERY_RESET_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_host_query_reset");
        }
        return Holder.VK_EXT_HOST_QUERY_RESET_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_INDEX_TYPE_UINT8_EXTENSION_NAME "VK_EXT_index_type_uint8"
     * }
     */
    public static MemorySegment VK_EXT_INDEX_TYPE_UINT8_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_INDEX_TYPE_UINT8_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_index_type_uint8");
        }
        return Holder.VK_EXT_INDEX_TYPE_UINT8_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_EXTENDED_DYNAMIC_STATE_EXTENSION_NAME "VK_EXT_extended_dynamic_state"
     * }
     */
    public static MemorySegment VK_EXT_EXTENDED_DYNAMIC_STATE_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_EXTENDED_DYNAMIC_STATE_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_extended_dynamic_state");
        }
        return Holder.VK_EXT_EXTENDED_DYNAMIC_STATE_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_HOST_IMAGE_COPY_EXTENSION_NAME "VK_EXT_host_image_copy"
     * }
     */
    public static MemorySegment VK_EXT_HOST_IMAGE_COPY_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_HOST_IMAGE_COPY_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_host_image_copy");
        }
        return Holder.VK_EXT_HOST_IMAGE_COPY_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_MAP_MEMORY_PLACED_EXTENSION_NAME "VK_EXT_map_memory_placed"
     * }
     */
    public static MemorySegment VK_EXT_MAP_MEMORY_PLACED_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_MAP_MEMORY_PLACED_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_map_memory_placed");
        }
        return Holder.VK_EXT_MAP_MEMORY_PLACED_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_SHADER_ATOMIC_FLOAT_2_EXTENSION_NAME "VK_EXT_shader_atomic_float2"
     * }
     */
    public static MemorySegment VK_EXT_SHADER_ATOMIC_FLOAT_2_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_SHADER_ATOMIC_FLOAT_2_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_shader_atomic_float2");
        }
        return Holder.VK_EXT_SHADER_ATOMIC_FLOAT_2_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_SURFACE_MAINTENANCE_1_EXTENSION_NAME "VK_EXT_surface_maintenance1"
     * }
     */
    public static MemorySegment VK_EXT_SURFACE_MAINTENANCE_1_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_SURFACE_MAINTENANCE_1_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_surface_maintenance1");
        }
        return Holder.VK_EXT_SURFACE_MAINTENANCE_1_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_SWAPCHAIN_MAINTENANCE_1_EXTENSION_NAME "VK_EXT_swapchain_maintenance1"
     * }
     */
    public static MemorySegment VK_EXT_SWAPCHAIN_MAINTENANCE_1_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_SWAPCHAIN_MAINTENANCE_1_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_swapchain_maintenance1");
        }
        return Holder.VK_EXT_SWAPCHAIN_MAINTENANCE_1_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION_EXTENSION_NAME "VK_EXT_shader_demote_to_helper_invocation"
     * }
     */
    public static MemorySegment VK_EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_shader_demote_to_helper_invocation");
        }
        return Holder.VK_EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_NV_DEVICE_GENERATED_COMMANDS_EXTENSION_NAME "VK_NV_device_generated_commands"
     * }
     */
    public static MemorySegment VK_NV_DEVICE_GENERATED_COMMANDS_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_NV_DEVICE_GENERATED_COMMANDS_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_NV_device_generated_commands");
        }
        return Holder.VK_NV_DEVICE_GENERATED_COMMANDS_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_NV_INHERITED_VIEWPORT_SCISSOR_EXTENSION_NAME "VK_NV_inherited_viewport_scissor"
     * }
     */
    public static MemorySegment VK_NV_INHERITED_VIEWPORT_SCISSOR_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_NV_INHERITED_VIEWPORT_SCISSOR_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_NV_inherited_viewport_scissor");
        }
        return Holder.VK_NV_INHERITED_VIEWPORT_SCISSOR_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_TEXEL_BUFFER_ALIGNMENT_EXTENSION_NAME "VK_EXT_texel_buffer_alignment"
     * }
     */
    public static MemorySegment VK_EXT_TEXEL_BUFFER_ALIGNMENT_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_TEXEL_BUFFER_ALIGNMENT_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_texel_buffer_alignment");
        }
        return Holder.VK_EXT_TEXEL_BUFFER_ALIGNMENT_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_QCOM_RENDER_PASS_TRANSFORM_EXTENSION_NAME "VK_QCOM_render_pass_transform"
     * }
     */
    public static MemorySegment VK_QCOM_RENDER_PASS_TRANSFORM_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_QCOM_RENDER_PASS_TRANSFORM_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_QCOM_render_pass_transform");
        }
        return Holder.VK_QCOM_RENDER_PASS_TRANSFORM_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_DEPTH_BIAS_CONTROL_EXTENSION_NAME "VK_EXT_depth_bias_control"
     * }
     */
    public static MemorySegment VK_EXT_DEPTH_BIAS_CONTROL_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_DEPTH_BIAS_CONTROL_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_depth_bias_control");
        }
        return Holder.VK_EXT_DEPTH_BIAS_CONTROL_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_DEVICE_MEMORY_REPORT_EXTENSION_NAME "VK_EXT_device_memory_report"
     * }
     */
    public static MemorySegment VK_EXT_DEVICE_MEMORY_REPORT_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_DEVICE_MEMORY_REPORT_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_device_memory_report");
        }
        return Holder.VK_EXT_DEVICE_MEMORY_REPORT_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_ACQUIRE_DRM_DISPLAY_EXTENSION_NAME "VK_EXT_acquire_drm_display"
     * }
     */
    public static MemorySegment VK_EXT_ACQUIRE_DRM_DISPLAY_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_ACQUIRE_DRM_DISPLAY_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_acquire_drm_display");
        }
        return Holder.VK_EXT_ACQUIRE_DRM_DISPLAY_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_ROBUSTNESS_2_EXTENSION_NAME "VK_EXT_robustness2"
     * }
     */
    public static MemorySegment VK_EXT_ROBUSTNESS_2_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_ROBUSTNESS_2_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_robustness2");
        }
        return Holder.VK_EXT_ROBUSTNESS_2_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_CUSTOM_BORDER_COLOR_EXTENSION_NAME "VK_EXT_custom_border_color"
     * }
     */
    public static MemorySegment VK_EXT_CUSTOM_BORDER_COLOR_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_CUSTOM_BORDER_COLOR_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_custom_border_color");
        }
        return Holder.VK_EXT_CUSTOM_BORDER_COLOR_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_GOOGLE_USER_TYPE_EXTENSION_NAME "VK_GOOGLE_user_type"
     * }
     */
    public static MemorySegment VK_GOOGLE_USER_TYPE_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_GOOGLE_USER_TYPE_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_GOOGLE_user_type");
        }
        return Holder.VK_GOOGLE_USER_TYPE_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_NV_PRESENT_BARRIER_EXTENSION_NAME "VK_NV_present_barrier"
     * }
     */
    public static MemorySegment VK_NV_PRESENT_BARRIER_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_NV_PRESENT_BARRIER_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_NV_present_barrier");
        }
        return Holder.VK_NV_PRESENT_BARRIER_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_PRIVATE_DATA_EXTENSION_NAME "VK_EXT_private_data"
     * }
     */
    public static MemorySegment VK_EXT_PRIVATE_DATA_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_PRIVATE_DATA_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_private_data");
        }
        return Holder.VK_EXT_PRIVATE_DATA_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_PIPELINE_CREATION_CACHE_CONTROL_EXTENSION_NAME "VK_EXT_pipeline_creation_cache_control"
     * }
     */
    public static MemorySegment VK_EXT_PIPELINE_CREATION_CACHE_CONTROL_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_PIPELINE_CREATION_CACHE_CONTROL_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_pipeline_creation_cache_control");
        }
        return Holder.VK_EXT_PIPELINE_CREATION_CACHE_CONTROL_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_NV_DEVICE_DIAGNOSTICS_CONFIG_EXTENSION_NAME "VK_NV_device_diagnostics_config"
     * }
     */
    public static MemorySegment VK_NV_DEVICE_DIAGNOSTICS_CONFIG_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_NV_DEVICE_DIAGNOSTICS_CONFIG_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_NV_device_diagnostics_config");
        }
        return Holder.VK_NV_DEVICE_DIAGNOSTICS_CONFIG_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_QCOM_RENDER_PASS_STORE_OPS_EXTENSION_NAME "VK_QCOM_render_pass_store_ops"
     * }
     */
    public static MemorySegment VK_QCOM_RENDER_PASS_STORE_OPS_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_QCOM_RENDER_PASS_STORE_OPS_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_QCOM_render_pass_store_ops");
        }
        return Holder.VK_QCOM_RENDER_PASS_STORE_OPS_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_NV_CUDA_KERNEL_LAUNCH_EXTENSION_NAME "VK_NV_cuda_kernel_launch"
     * }
     */
    public static MemorySegment VK_NV_CUDA_KERNEL_LAUNCH_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_NV_CUDA_KERNEL_LAUNCH_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_NV_cuda_kernel_launch");
        }
        return Holder.VK_NV_CUDA_KERNEL_LAUNCH_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_NV_LOW_LATENCY_EXTENSION_NAME "VK_NV_low_latency"
     * }
     */
    public static MemorySegment VK_NV_LOW_LATENCY_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_NV_LOW_LATENCY_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_NV_low_latency");
        }
        return Holder.VK_NV_LOW_LATENCY_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_DESCRIPTOR_BUFFER_EXTENSION_NAME "VK_EXT_descriptor_buffer"
     * }
     */
    public static MemorySegment VK_EXT_DESCRIPTOR_BUFFER_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_DESCRIPTOR_BUFFER_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_descriptor_buffer");
        }
        return Holder.VK_EXT_DESCRIPTOR_BUFFER_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_GRAPHICS_PIPELINE_LIBRARY_EXTENSION_NAME "VK_EXT_graphics_pipeline_library"
     * }
     */
    public static MemorySegment VK_EXT_GRAPHICS_PIPELINE_LIBRARY_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_GRAPHICS_PIPELINE_LIBRARY_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_graphics_pipeline_library");
        }
        return Holder.VK_EXT_GRAPHICS_PIPELINE_LIBRARY_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_AMD_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_EXTENSION_NAME "VK_AMD_shader_early_and_late_fragment_tests"
     * }
     */
    public static MemorySegment VK_AMD_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_AMD_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_AMD_shader_early_and_late_fragment_tests");
        }
        return Holder.VK_AMD_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_NV_FRAGMENT_SHADING_RATE_ENUMS_EXTENSION_NAME "VK_NV_fragment_shading_rate_enums"
     * }
     */
    public static MemorySegment VK_NV_FRAGMENT_SHADING_RATE_ENUMS_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_NV_FRAGMENT_SHADING_RATE_ENUMS_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_NV_fragment_shading_rate_enums");
        }
        return Holder.VK_NV_FRAGMENT_SHADING_RATE_ENUMS_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_NV_RAY_TRACING_MOTION_BLUR_EXTENSION_NAME "VK_NV_ray_tracing_motion_blur"
     * }
     */
    public static MemorySegment VK_NV_RAY_TRACING_MOTION_BLUR_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_NV_RAY_TRACING_MOTION_BLUR_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_NV_ray_tracing_motion_blur");
        }
        return Holder.VK_NV_RAY_TRACING_MOTION_BLUR_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_YCBCR_2PLANE_444_FORMATS_EXTENSION_NAME "VK_EXT_ycbcr_2plane_444_formats"
     * }
     */
    public static MemorySegment VK_EXT_YCBCR_2PLANE_444_FORMATS_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_YCBCR_2PLANE_444_FORMATS_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_ycbcr_2plane_444_formats");
        }
        return Holder.VK_EXT_YCBCR_2PLANE_444_FORMATS_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_FRAGMENT_DENSITY_MAP_2_EXTENSION_NAME "VK_EXT_fragment_density_map2"
     * }
     */
    public static MemorySegment VK_EXT_FRAGMENT_DENSITY_MAP_2_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_FRAGMENT_DENSITY_MAP_2_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_fragment_density_map2");
        }
        return Holder.VK_EXT_FRAGMENT_DENSITY_MAP_2_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_QCOM_ROTATED_COPY_COMMANDS_EXTENSION_NAME "VK_QCOM_rotated_copy_commands"
     * }
     */
    public static MemorySegment VK_QCOM_ROTATED_COPY_COMMANDS_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_QCOM_ROTATED_COPY_COMMANDS_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_QCOM_rotated_copy_commands");
        }
        return Holder.VK_QCOM_ROTATED_COPY_COMMANDS_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_IMAGE_ROBUSTNESS_EXTENSION_NAME "VK_EXT_image_robustness"
     * }
     */
    public static MemorySegment VK_EXT_IMAGE_ROBUSTNESS_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_IMAGE_ROBUSTNESS_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_image_robustness");
        }
        return Holder.VK_EXT_IMAGE_ROBUSTNESS_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_IMAGE_COMPRESSION_CONTROL_EXTENSION_NAME "VK_EXT_image_compression_control"
     * }
     */
    public static MemorySegment VK_EXT_IMAGE_COMPRESSION_CONTROL_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_IMAGE_COMPRESSION_CONTROL_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_image_compression_control");
        }
        return Holder.VK_EXT_IMAGE_COMPRESSION_CONTROL_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_EXTENSION_NAME "VK_EXT_attachment_feedback_loop_layout"
     * }
     */
    public static MemorySegment VK_EXT_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_attachment_feedback_loop_layout");
        }
        return Holder.VK_EXT_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_4444_FORMATS_EXTENSION_NAME "VK_EXT_4444_formats"
     * }
     */
    public static MemorySegment VK_EXT_4444_FORMATS_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_4444_FORMATS_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_4444_formats");
        }
        return Holder.VK_EXT_4444_FORMATS_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_DEVICE_FAULT_EXTENSION_NAME "VK_EXT_device_fault"
     * }
     */
    public static MemorySegment VK_EXT_DEVICE_FAULT_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_DEVICE_FAULT_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_device_fault");
        }
        return Holder.VK_EXT_DEVICE_FAULT_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_ARM_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_EXTENSION_NAME "VK_ARM_rasterization_order_attachment_access"
     * }
     */
    public static MemorySegment VK_ARM_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_ARM_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_ARM_rasterization_order_attachment_access");
        }
        return Holder.VK_ARM_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_RGBA10X6_FORMATS_EXTENSION_NAME "VK_EXT_rgba10x6_formats"
     * }
     */
    public static MemorySegment VK_EXT_RGBA10X6_FORMATS_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_RGBA10X6_FORMATS_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_rgba10x6_formats");
        }
        return Holder.VK_EXT_RGBA10X6_FORMATS_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_VALVE_MUTABLE_DESCRIPTOR_TYPE_EXTENSION_NAME "VK_VALVE_mutable_descriptor_type"
     * }
     */
    public static MemorySegment VK_VALVE_MUTABLE_DESCRIPTOR_TYPE_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_VALVE_MUTABLE_DESCRIPTOR_TYPE_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_VALVE_mutable_descriptor_type");
        }
        return Holder.VK_VALVE_MUTABLE_DESCRIPTOR_TYPE_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_VERTEX_INPUT_DYNAMIC_STATE_EXTENSION_NAME "VK_EXT_vertex_input_dynamic_state"
     * }
     */
    public static MemorySegment VK_EXT_VERTEX_INPUT_DYNAMIC_STATE_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_VERTEX_INPUT_DYNAMIC_STATE_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_vertex_input_dynamic_state");
        }
        return Holder.VK_EXT_VERTEX_INPUT_DYNAMIC_STATE_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_PHYSICAL_DEVICE_DRM_EXTENSION_NAME "VK_EXT_physical_device_drm"
     * }
     */
    public static MemorySegment VK_EXT_PHYSICAL_DEVICE_DRM_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_PHYSICAL_DEVICE_DRM_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_physical_device_drm");
        }
        return Holder.VK_EXT_PHYSICAL_DEVICE_DRM_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_DEVICE_ADDRESS_BINDING_REPORT_EXTENSION_NAME "VK_EXT_device_address_binding_report"
     * }
     */
    public static MemorySegment VK_EXT_DEVICE_ADDRESS_BINDING_REPORT_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_DEVICE_ADDRESS_BINDING_REPORT_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_device_address_binding_report");
        }
        return Holder.VK_EXT_DEVICE_ADDRESS_BINDING_REPORT_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_DEPTH_CLIP_CONTROL_EXTENSION_NAME "VK_EXT_depth_clip_control"
     * }
     */
    public static MemorySegment VK_EXT_DEPTH_CLIP_CONTROL_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_DEPTH_CLIP_CONTROL_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_depth_clip_control");
        }
        return Holder.VK_EXT_DEPTH_CLIP_CONTROL_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_PRIMITIVE_TOPOLOGY_LIST_RESTART_EXTENSION_NAME "VK_EXT_primitive_topology_list_restart"
     * }
     */
    public static MemorySegment VK_EXT_PRIMITIVE_TOPOLOGY_LIST_RESTART_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_PRIMITIVE_TOPOLOGY_LIST_RESTART_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_primitive_topology_list_restart");
        }
        return Holder.VK_EXT_PRIMITIVE_TOPOLOGY_LIST_RESTART_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_HUAWEI_SUBPASS_SHADING_EXTENSION_NAME "VK_HUAWEI_subpass_shading"
     * }
     */
    public static MemorySegment VK_HUAWEI_SUBPASS_SHADING_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_HUAWEI_SUBPASS_SHADING_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_HUAWEI_subpass_shading");
        }
        return Holder.VK_HUAWEI_SUBPASS_SHADING_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_HUAWEI_INVOCATION_MASK_EXTENSION_NAME "VK_HUAWEI_invocation_mask"
     * }
     */
    public static MemorySegment VK_HUAWEI_INVOCATION_MASK_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_HUAWEI_INVOCATION_MASK_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_HUAWEI_invocation_mask");
        }
        return Holder.VK_HUAWEI_INVOCATION_MASK_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_NV_EXTERNAL_MEMORY_RDMA_EXTENSION_NAME "VK_NV_external_memory_rdma"
     * }
     */
    public static MemorySegment VK_NV_EXTERNAL_MEMORY_RDMA_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_NV_EXTERNAL_MEMORY_RDMA_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_NV_external_memory_rdma");
        }
        return Holder.VK_NV_EXTERNAL_MEMORY_RDMA_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_PIPELINE_PROPERTIES_EXTENSION_NAME "VK_EXT_pipeline_properties"
     * }
     */
    public static MemorySegment VK_EXT_PIPELINE_PROPERTIES_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_PIPELINE_PROPERTIES_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_pipeline_properties");
        }
        return Holder.VK_EXT_PIPELINE_PROPERTIES_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_FRAME_BOUNDARY_EXTENSION_NAME "VK_EXT_frame_boundary"
     * }
     */
    public static MemorySegment VK_EXT_FRAME_BOUNDARY_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_FRAME_BOUNDARY_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_frame_boundary");
        }
        return Holder.VK_EXT_FRAME_BOUNDARY_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_EXTENSION_NAME "VK_EXT_multisampled_render_to_single_sampled"
     * }
     */
    public static MemorySegment VK_EXT_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_multisampled_render_to_single_sampled");
        }
        return Holder.VK_EXT_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_EXTENDED_DYNAMIC_STATE_2_EXTENSION_NAME "VK_EXT_extended_dynamic_state2"
     * }
     */
    public static MemorySegment VK_EXT_EXTENDED_DYNAMIC_STATE_2_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_EXTENDED_DYNAMIC_STATE_2_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_extended_dynamic_state2");
        }
        return Holder.VK_EXT_EXTENDED_DYNAMIC_STATE_2_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_COLOR_WRITE_ENABLE_EXTENSION_NAME "VK_EXT_color_write_enable"
     * }
     */
    public static MemorySegment VK_EXT_COLOR_WRITE_ENABLE_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_COLOR_WRITE_ENABLE_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_color_write_enable");
        }
        return Holder.VK_EXT_COLOR_WRITE_ENABLE_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_PRIMITIVES_GENERATED_QUERY_EXTENSION_NAME "VK_EXT_primitives_generated_query"
     * }
     */
    public static MemorySegment VK_EXT_PRIMITIVES_GENERATED_QUERY_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_PRIMITIVES_GENERATED_QUERY_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_primitives_generated_query");
        }
        return Holder.VK_EXT_PRIMITIVES_GENERATED_QUERY_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_GLOBAL_PRIORITY_QUERY_EXTENSION_NAME "VK_EXT_global_priority_query"
     * }
     */
    public static MemorySegment VK_EXT_GLOBAL_PRIORITY_QUERY_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_GLOBAL_PRIORITY_QUERY_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_global_priority_query");
        }
        return Holder.VK_EXT_GLOBAL_PRIORITY_QUERY_EXTENSION_NAME;
    }
    private static final int VK_MAX_GLOBAL_PRIORITY_SIZE_EXT = (int)16L;
    /**
     * {@snippet lang=c :
     * #define VK_MAX_GLOBAL_PRIORITY_SIZE_EXT 16
     * }
     */
    public static int VK_MAX_GLOBAL_PRIORITY_SIZE_EXT() {
        return VK_MAX_GLOBAL_PRIORITY_SIZE_EXT;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_IMAGE_VIEW_MIN_LOD_EXTENSION_NAME "VK_EXT_image_view_min_lod"
     * }
     */
    public static MemorySegment VK_EXT_IMAGE_VIEW_MIN_LOD_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_IMAGE_VIEW_MIN_LOD_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_image_view_min_lod");
        }
        return Holder.VK_EXT_IMAGE_VIEW_MIN_LOD_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_MULTI_DRAW_EXTENSION_NAME "VK_EXT_multi_draw"
     * }
     */
    public static MemorySegment VK_EXT_MULTI_DRAW_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_MULTI_DRAW_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_multi_draw");
        }
        return Holder.VK_EXT_MULTI_DRAW_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_IMAGE_2D_VIEW_OF_3D_EXTENSION_NAME "VK_EXT_image_2d_view_of_3d"
     * }
     */
    public static MemorySegment VK_EXT_IMAGE_2D_VIEW_OF_3D_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_IMAGE_2D_VIEW_OF_3D_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_image_2d_view_of_3d");
        }
        return Holder.VK_EXT_IMAGE_2D_VIEW_OF_3D_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_SHADER_TILE_IMAGE_EXTENSION_NAME "VK_EXT_shader_tile_image"
     * }
     */
    public static MemorySegment VK_EXT_SHADER_TILE_IMAGE_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_SHADER_TILE_IMAGE_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_shader_tile_image");
        }
        return Holder.VK_EXT_SHADER_TILE_IMAGE_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_OPACITY_MICROMAP_EXTENSION_NAME "VK_EXT_opacity_micromap"
     * }
     */
    public static MemorySegment VK_EXT_OPACITY_MICROMAP_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_OPACITY_MICROMAP_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_opacity_micromap");
        }
        return Holder.VK_EXT_OPACITY_MICROMAP_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_LOAD_STORE_OP_NONE_EXTENSION_NAME "VK_EXT_load_store_op_none"
     * }
     */
    public static MemorySegment VK_EXT_LOAD_STORE_OP_NONE_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_LOAD_STORE_OP_NONE_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_load_store_op_none");
        }
        return Holder.VK_EXT_LOAD_STORE_OP_NONE_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_HUAWEI_CLUSTER_CULLING_SHADER_EXTENSION_NAME "VK_HUAWEI_cluster_culling_shader"
     * }
     */
    public static MemorySegment VK_HUAWEI_CLUSTER_CULLING_SHADER_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_HUAWEI_CLUSTER_CULLING_SHADER_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_HUAWEI_cluster_culling_shader");
        }
        return Holder.VK_HUAWEI_CLUSTER_CULLING_SHADER_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_BORDER_COLOR_SWIZZLE_EXTENSION_NAME "VK_EXT_border_color_swizzle"
     * }
     */
    public static MemorySegment VK_EXT_BORDER_COLOR_SWIZZLE_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_BORDER_COLOR_SWIZZLE_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_border_color_swizzle");
        }
        return Holder.VK_EXT_BORDER_COLOR_SWIZZLE_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_PAGEABLE_DEVICE_LOCAL_MEMORY_EXTENSION_NAME "VK_EXT_pageable_device_local_memory"
     * }
     */
    public static MemorySegment VK_EXT_PAGEABLE_DEVICE_LOCAL_MEMORY_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_PAGEABLE_DEVICE_LOCAL_MEMORY_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_pageable_device_local_memory");
        }
        return Holder.VK_EXT_PAGEABLE_DEVICE_LOCAL_MEMORY_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_ARM_SHADER_CORE_PROPERTIES_EXTENSION_NAME "VK_ARM_shader_core_properties"
     * }
     */
    public static MemorySegment VK_ARM_SHADER_CORE_PROPERTIES_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_ARM_SHADER_CORE_PROPERTIES_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_ARM_shader_core_properties");
        }
        return Holder.VK_ARM_SHADER_CORE_PROPERTIES_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_ARM_SCHEDULING_CONTROLS_EXTENSION_NAME "VK_ARM_scheduling_controls"
     * }
     */
    public static MemorySegment VK_ARM_SCHEDULING_CONTROLS_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_ARM_SCHEDULING_CONTROLS_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_ARM_scheduling_controls");
        }
        return Holder.VK_ARM_SCHEDULING_CONTROLS_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_IMAGE_SLICED_VIEW_OF_3D_EXTENSION_NAME "VK_EXT_image_sliced_view_of_3d"
     * }
     */
    public static MemorySegment VK_EXT_IMAGE_SLICED_VIEW_OF_3D_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_IMAGE_SLICED_VIEW_OF_3D_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_image_sliced_view_of_3d");
        }
        return Holder.VK_EXT_IMAGE_SLICED_VIEW_OF_3D_EXTENSION_NAME;
    }
    private static final int VK_REMAINING_3D_SLICES_EXT = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define VK_REMAINING_3D_SLICES_EXT 4294967295
     * }
     */
    public static int VK_REMAINING_3D_SLICES_EXT() {
        return VK_REMAINING_3D_SLICES_EXT;
    }
    /**
     * {@snippet lang=c :
     * #define VK_VALVE_DESCRIPTOR_SET_HOST_MAPPING_EXTENSION_NAME "VK_VALVE_descriptor_set_host_mapping"
     * }
     */
    public static MemorySegment VK_VALVE_DESCRIPTOR_SET_HOST_MAPPING_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_VALVE_DESCRIPTOR_SET_HOST_MAPPING_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_VALVE_descriptor_set_host_mapping");
        }
        return Holder.VK_VALVE_DESCRIPTOR_SET_HOST_MAPPING_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_DEPTH_CLAMP_ZERO_ONE_EXTENSION_NAME "VK_EXT_depth_clamp_zero_one"
     * }
     */
    public static MemorySegment VK_EXT_DEPTH_CLAMP_ZERO_ONE_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_DEPTH_CLAMP_ZERO_ONE_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_depth_clamp_zero_one");
        }
        return Holder.VK_EXT_DEPTH_CLAMP_ZERO_ONE_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_NON_SEAMLESS_CUBE_MAP_EXTENSION_NAME "VK_EXT_non_seamless_cube_map"
     * }
     */
    public static MemorySegment VK_EXT_NON_SEAMLESS_CUBE_MAP_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_NON_SEAMLESS_CUBE_MAP_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_non_seamless_cube_map");
        }
        return Holder.VK_EXT_NON_SEAMLESS_CUBE_MAP_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_ARM_RENDER_PASS_STRIPED_EXTENSION_NAME "VK_ARM_render_pass_striped"
     * }
     */
    public static MemorySegment VK_ARM_RENDER_PASS_STRIPED_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_ARM_RENDER_PASS_STRIPED_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_ARM_render_pass_striped");
        }
        return Holder.VK_ARM_RENDER_PASS_STRIPED_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_QCOM_FRAGMENT_DENSITY_MAP_OFFSET_EXTENSION_NAME "VK_QCOM_fragment_density_map_offset"
     * }
     */
    public static MemorySegment VK_QCOM_FRAGMENT_DENSITY_MAP_OFFSET_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_QCOM_FRAGMENT_DENSITY_MAP_OFFSET_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_QCOM_fragment_density_map_offset");
        }
        return Holder.VK_QCOM_FRAGMENT_DENSITY_MAP_OFFSET_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_NV_COPY_MEMORY_INDIRECT_EXTENSION_NAME "VK_NV_copy_memory_indirect"
     * }
     */
    public static MemorySegment VK_NV_COPY_MEMORY_INDIRECT_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_NV_COPY_MEMORY_INDIRECT_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_NV_copy_memory_indirect");
        }
        return Holder.VK_NV_COPY_MEMORY_INDIRECT_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_NV_MEMORY_DECOMPRESSION_EXTENSION_NAME "VK_NV_memory_decompression"
     * }
     */
    public static MemorySegment VK_NV_MEMORY_DECOMPRESSION_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_NV_MEMORY_DECOMPRESSION_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_NV_memory_decompression");
        }
        return Holder.VK_NV_MEMORY_DECOMPRESSION_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_NV_DEVICE_GENERATED_COMMANDS_COMPUTE_EXTENSION_NAME "VK_NV_device_generated_commands_compute"
     * }
     */
    public static MemorySegment VK_NV_DEVICE_GENERATED_COMMANDS_COMPUTE_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_NV_DEVICE_GENERATED_COMMANDS_COMPUTE_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_NV_device_generated_commands_compute");
        }
        return Holder.VK_NV_DEVICE_GENERATED_COMMANDS_COMPUTE_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_NV_LINEAR_COLOR_ATTACHMENT_EXTENSION_NAME "VK_NV_linear_color_attachment"
     * }
     */
    public static MemorySegment VK_NV_LINEAR_COLOR_ATTACHMENT_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_NV_LINEAR_COLOR_ATTACHMENT_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_NV_linear_color_attachment");
        }
        return Holder.VK_NV_LINEAR_COLOR_ATTACHMENT_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_GOOGLE_SURFACELESS_QUERY_EXTENSION_NAME "VK_GOOGLE_surfaceless_query"
     * }
     */
    public static MemorySegment VK_GOOGLE_SURFACELESS_QUERY_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_GOOGLE_SURFACELESS_QUERY_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_GOOGLE_surfaceless_query");
        }
        return Holder.VK_GOOGLE_SURFACELESS_QUERY_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_EXTENSION_NAME "VK_EXT_image_compression_control_swapchain"
     * }
     */
    public static MemorySegment VK_EXT_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_image_compression_control_swapchain");
        }
        return Holder.VK_EXT_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_QCOM_IMAGE_PROCESSING_EXTENSION_NAME "VK_QCOM_image_processing"
     * }
     */
    public static MemorySegment VK_QCOM_IMAGE_PROCESSING_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_QCOM_IMAGE_PROCESSING_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_QCOM_image_processing");
        }
        return Holder.VK_QCOM_IMAGE_PROCESSING_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_NESTED_COMMAND_BUFFER_EXTENSION_NAME "VK_EXT_nested_command_buffer"
     * }
     */
    public static MemorySegment VK_EXT_NESTED_COMMAND_BUFFER_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_NESTED_COMMAND_BUFFER_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_nested_command_buffer");
        }
        return Holder.VK_EXT_NESTED_COMMAND_BUFFER_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXTENSION_NAME "VK_EXT_external_memory_acquire_unmodified"
     * }
     */
    public static MemorySegment VK_EXT_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_external_memory_acquire_unmodified");
        }
        return Holder.VK_EXT_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_EXTENDED_DYNAMIC_STATE_3_EXTENSION_NAME "VK_EXT_extended_dynamic_state3"
     * }
     */
    public static MemorySegment VK_EXT_EXTENDED_DYNAMIC_STATE_3_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_EXTENDED_DYNAMIC_STATE_3_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_extended_dynamic_state3");
        }
        return Holder.VK_EXT_EXTENDED_DYNAMIC_STATE_3_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_SUBPASS_MERGE_FEEDBACK_EXTENSION_NAME "VK_EXT_subpass_merge_feedback"
     * }
     */
    public static MemorySegment VK_EXT_SUBPASS_MERGE_FEEDBACK_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_SUBPASS_MERGE_FEEDBACK_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_subpass_merge_feedback");
        }
        return Holder.VK_EXT_SUBPASS_MERGE_FEEDBACK_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_LUNARG_DIRECT_DRIVER_LOADING_EXTENSION_NAME "VK_LUNARG_direct_driver_loading"
     * }
     */
    public static MemorySegment VK_LUNARG_DIRECT_DRIVER_LOADING_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_LUNARG_DIRECT_DRIVER_LOADING_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_LUNARG_direct_driver_loading");
        }
        return Holder.VK_LUNARG_DIRECT_DRIVER_LOADING_EXTENSION_NAME;
    }
    private static final int VK_MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT = (int)32L;
    /**
     * {@snippet lang=c :
     * #define VK_MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT 32
     * }
     */
    public static int VK_MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT() {
        return VK_MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_SHADER_MODULE_IDENTIFIER_EXTENSION_NAME "VK_EXT_shader_module_identifier"
     * }
     */
    public static MemorySegment VK_EXT_SHADER_MODULE_IDENTIFIER_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_SHADER_MODULE_IDENTIFIER_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_shader_module_identifier");
        }
        return Holder.VK_EXT_SHADER_MODULE_IDENTIFIER_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_EXTENSION_NAME "VK_EXT_rasterization_order_attachment_access"
     * }
     */
    public static MemorySegment VK_EXT_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_rasterization_order_attachment_access");
        }
        return Holder.VK_EXT_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_NV_OPTICAL_FLOW_EXTENSION_NAME "VK_NV_optical_flow"
     * }
     */
    public static MemorySegment VK_NV_OPTICAL_FLOW_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_NV_OPTICAL_FLOW_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_NV_optical_flow");
        }
        return Holder.VK_NV_OPTICAL_FLOW_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_LEGACY_DITHERING_EXTENSION_NAME "VK_EXT_legacy_dithering"
     * }
     */
    public static MemorySegment VK_EXT_LEGACY_DITHERING_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_LEGACY_DITHERING_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_legacy_dithering");
        }
        return Holder.VK_EXT_LEGACY_DITHERING_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_PIPELINE_PROTECTED_ACCESS_EXTENSION_NAME "VK_EXT_pipeline_protected_access"
     * }
     */
    public static MemorySegment VK_EXT_PIPELINE_PROTECTED_ACCESS_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_PIPELINE_PROTECTED_ACCESS_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_pipeline_protected_access");
        }
        return Holder.VK_EXT_PIPELINE_PROTECTED_ACCESS_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_SHADER_OBJECT_EXTENSION_NAME "VK_EXT_shader_object"
     * }
     */
    public static MemorySegment VK_EXT_SHADER_OBJECT_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_SHADER_OBJECT_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_shader_object");
        }
        return Holder.VK_EXT_SHADER_OBJECT_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_QCOM_TILE_PROPERTIES_EXTENSION_NAME "VK_QCOM_tile_properties"
     * }
     */
    public static MemorySegment VK_QCOM_TILE_PROPERTIES_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_QCOM_TILE_PROPERTIES_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_QCOM_tile_properties");
        }
        return Holder.VK_QCOM_TILE_PROPERTIES_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_SEC_AMIGO_PROFILING_EXTENSION_NAME "VK_SEC_amigo_profiling"
     * }
     */
    public static MemorySegment VK_SEC_AMIGO_PROFILING_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_SEC_AMIGO_PROFILING_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_SEC_amigo_profiling");
        }
        return Holder.VK_SEC_AMIGO_PROFILING_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_QCOM_MULTIVIEW_PER_VIEW_VIEWPORTS_EXTENSION_NAME "VK_QCOM_multiview_per_view_viewports"
     * }
     */
    public static MemorySegment VK_QCOM_MULTIVIEW_PER_VIEW_VIEWPORTS_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_QCOM_MULTIVIEW_PER_VIEW_VIEWPORTS_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_QCOM_multiview_per_view_viewports");
        }
        return Holder.VK_QCOM_MULTIVIEW_PER_VIEW_VIEWPORTS_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_NV_RAY_TRACING_INVOCATION_REORDER_EXTENSION_NAME "VK_NV_ray_tracing_invocation_reorder"
     * }
     */
    public static MemorySegment VK_NV_RAY_TRACING_INVOCATION_REORDER_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_NV_RAY_TRACING_INVOCATION_REORDER_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_NV_ray_tracing_invocation_reorder");
        }
        return Holder.VK_NV_RAY_TRACING_INVOCATION_REORDER_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_NV_EXTENDED_SPARSE_ADDRESS_SPACE_EXTENSION_NAME "VK_NV_extended_sparse_address_space"
     * }
     */
    public static MemorySegment VK_NV_EXTENDED_SPARSE_ADDRESS_SPACE_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_NV_EXTENDED_SPARSE_ADDRESS_SPACE_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_NV_extended_sparse_address_space");
        }
        return Holder.VK_NV_EXTENDED_SPARSE_ADDRESS_SPACE_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_MUTABLE_DESCRIPTOR_TYPE_EXTENSION_NAME "VK_EXT_mutable_descriptor_type"
     * }
     */
    public static MemorySegment VK_EXT_MUTABLE_DESCRIPTOR_TYPE_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_MUTABLE_DESCRIPTOR_TYPE_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_mutable_descriptor_type");
        }
        return Holder.VK_EXT_MUTABLE_DESCRIPTOR_TYPE_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_LAYER_SETTINGS_EXTENSION_NAME "VK_EXT_layer_settings"
     * }
     */
    public static MemorySegment VK_EXT_LAYER_SETTINGS_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_LAYER_SETTINGS_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_layer_settings");
        }
        return Holder.VK_EXT_LAYER_SETTINGS_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_ARM_SHADER_CORE_BUILTINS_EXTENSION_NAME "VK_ARM_shader_core_builtins"
     * }
     */
    public static MemorySegment VK_ARM_SHADER_CORE_BUILTINS_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_ARM_SHADER_CORE_BUILTINS_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_ARM_shader_core_builtins");
        }
        return Holder.VK_ARM_SHADER_CORE_BUILTINS_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_PIPELINE_LIBRARY_GROUP_HANDLES_EXTENSION_NAME "VK_EXT_pipeline_library_group_handles"
     * }
     */
    public static MemorySegment VK_EXT_PIPELINE_LIBRARY_GROUP_HANDLES_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_PIPELINE_LIBRARY_GROUP_HANDLES_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_pipeline_library_group_handles");
        }
        return Holder.VK_EXT_PIPELINE_LIBRARY_GROUP_HANDLES_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_EXTENSION_NAME "VK_EXT_dynamic_rendering_unused_attachments"
     * }
     */
    public static MemorySegment VK_EXT_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_dynamic_rendering_unused_attachments");
        }
        return Holder.VK_EXT_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_NV_LOW_LATENCY_2_EXTENSION_NAME "VK_NV_low_latency2"
     * }
     */
    public static MemorySegment VK_NV_LOW_LATENCY_2_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_NV_LOW_LATENCY_2_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_NV_low_latency2");
        }
        return Holder.VK_NV_LOW_LATENCY_2_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_QCOM_MULTIVIEW_PER_VIEW_RENDER_AREAS_EXTENSION_NAME "VK_QCOM_multiview_per_view_render_areas"
     * }
     */
    public static MemorySegment VK_QCOM_MULTIVIEW_PER_VIEW_RENDER_AREAS_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_QCOM_MULTIVIEW_PER_VIEW_RENDER_AREAS_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_QCOM_multiview_per_view_render_areas");
        }
        return Holder.VK_QCOM_MULTIVIEW_PER_VIEW_RENDER_AREAS_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_NV_PER_STAGE_DESCRIPTOR_SET_EXTENSION_NAME "VK_NV_per_stage_descriptor_set"
     * }
     */
    public static MemorySegment VK_NV_PER_STAGE_DESCRIPTOR_SET_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_NV_PER_STAGE_DESCRIPTOR_SET_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_NV_per_stage_descriptor_set");
        }
        return Holder.VK_NV_PER_STAGE_DESCRIPTOR_SET_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_QCOM_IMAGE_PROCESSING_2_EXTENSION_NAME "VK_QCOM_image_processing2"
     * }
     */
    public static MemorySegment VK_QCOM_IMAGE_PROCESSING_2_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_QCOM_IMAGE_PROCESSING_2_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_QCOM_image_processing2");
        }
        return Holder.VK_QCOM_IMAGE_PROCESSING_2_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_QCOM_FILTER_CUBIC_WEIGHTS_EXTENSION_NAME "VK_QCOM_filter_cubic_weights"
     * }
     */
    public static MemorySegment VK_QCOM_FILTER_CUBIC_WEIGHTS_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_QCOM_FILTER_CUBIC_WEIGHTS_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_QCOM_filter_cubic_weights");
        }
        return Holder.VK_QCOM_FILTER_CUBIC_WEIGHTS_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_QCOM_YCBCR_DEGAMMA_EXTENSION_NAME "VK_QCOM_ycbcr_degamma"
     * }
     */
    public static MemorySegment VK_QCOM_YCBCR_DEGAMMA_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_QCOM_YCBCR_DEGAMMA_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_QCOM_ycbcr_degamma");
        }
        return Holder.VK_QCOM_YCBCR_DEGAMMA_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_QCOM_FILTER_CUBIC_CLAMP_EXTENSION_NAME "VK_QCOM_filter_cubic_clamp"
     * }
     */
    public static MemorySegment VK_QCOM_FILTER_CUBIC_CLAMP_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_QCOM_FILTER_CUBIC_CLAMP_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_QCOM_filter_cubic_clamp");
        }
        return Holder.VK_QCOM_FILTER_CUBIC_CLAMP_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_EXTENSION_NAME "VK_EXT_attachment_feedback_loop_dynamic_state"
     * }
     */
    public static MemorySegment VK_EXT_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_attachment_feedback_loop_dynamic_state");
        }
        return Holder.VK_EXT_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_MSFT_LAYERED_DRIVER_EXTENSION_NAME "VK_MSFT_layered_driver"
     * }
     */
    public static MemorySegment VK_MSFT_LAYERED_DRIVER_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_MSFT_LAYERED_DRIVER_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_MSFT_layered_driver");
        }
        return Holder.VK_MSFT_LAYERED_DRIVER_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_NV_DESCRIPTOR_POOL_OVERALLOCATION_EXTENSION_NAME "VK_NV_descriptor_pool_overallocation"
     * }
     */
    public static MemorySegment VK_NV_DESCRIPTOR_POOL_OVERALLOCATION_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_NV_DESCRIPTOR_POOL_OVERALLOCATION_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_NV_descriptor_pool_overallocation");
        }
        return Holder.VK_NV_DESCRIPTOR_POOL_OVERALLOCATION_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_NV_RAW_ACCESS_CHAINS_EXTENSION_NAME "VK_NV_raw_access_chains"
     * }
     */
    public static MemorySegment VK_NV_RAW_ACCESS_CHAINS_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_NV_RAW_ACCESS_CHAINS_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_NV_raw_access_chains");
        }
        return Holder.VK_NV_RAW_ACCESS_CHAINS_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_NV_SHADER_ATOMIC_FLOAT16_VECTOR_EXTENSION_NAME "VK_NV_shader_atomic_float16_vector"
     * }
     */
    public static MemorySegment VK_NV_SHADER_ATOMIC_FLOAT16_VECTOR_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_NV_SHADER_ATOMIC_FLOAT16_VECTOR_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_NV_shader_atomic_float16_vector");
        }
        return Holder.VK_NV_SHADER_ATOMIC_FLOAT16_VECTOR_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_NV_RAY_TRACING_VALIDATION_EXTENSION_NAME "VK_NV_ray_tracing_validation"
     * }
     */
    public static MemorySegment VK_NV_RAY_TRACING_VALIDATION_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_NV_RAY_TRACING_VALIDATION_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_NV_ray_tracing_validation");
        }
        return Holder.VK_NV_RAY_TRACING_VALIDATION_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_ACCELERATION_STRUCTURE_EXTENSION_NAME "VK_KHR_acceleration_structure"
     * }
     */
    public static MemorySegment VK_KHR_ACCELERATION_STRUCTURE_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_ACCELERATION_STRUCTURE_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_acceleration_structure");
        }
        return Holder.VK_KHR_ACCELERATION_STRUCTURE_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_RAY_TRACING_PIPELINE_EXTENSION_NAME "VK_KHR_ray_tracing_pipeline"
     * }
     */
    public static MemorySegment VK_KHR_RAY_TRACING_PIPELINE_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_RAY_TRACING_PIPELINE_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_ray_tracing_pipeline");
        }
        return Holder.VK_KHR_RAY_TRACING_PIPELINE_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_RAY_QUERY_EXTENSION_NAME "VK_KHR_ray_query"
     * }
     */
    public static MemorySegment VK_KHR_RAY_QUERY_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_RAY_QUERY_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_KHR_ray_query");
        }
        return Holder.VK_KHR_RAY_QUERY_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_MESH_SHADER_EXTENSION_NAME "VK_EXT_mesh_shader"
     * }
     */
    public static MemorySegment VK_EXT_MESH_SHADER_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_MESH_SHADER_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_mesh_shader");
        }
        return Holder.VK_EXT_MESH_SHADER_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_MVK_MACOS_SURFACE_EXTENSION_NAME "VK_MVK_macos_surface"
     * }
     */
    public static MemorySegment VK_MVK_MACOS_SURFACE_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_MVK_MACOS_SURFACE_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_MVK_macos_surface");
        }
        return Holder.VK_MVK_MACOS_SURFACE_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_METAL_SURFACE_EXTENSION_NAME "VK_EXT_metal_surface"
     * }
     */
    public static MemorySegment VK_EXT_METAL_SURFACE_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_METAL_SURFACE_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_metal_surface");
        }
        return Holder.VK_EXT_METAL_SURFACE_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_METAL_OBJECTS_EXTENSION_NAME "VK_EXT_metal_objects"
     * }
     */
    public static MemorySegment VK_EXT_METAL_OBJECTS_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_METAL_OBJECTS_EXTENSION_NAME
                = vulkan_h.LIBRARY_ARENA.allocateFrom("VK_EXT_metal_objects");
        }
        return Holder.VK_EXT_METAL_OBJECTS_EXTENSION_NAME;
    }
}

